{"meta":{"title":"ANLY'S BLOG","subtitle":"看看书, 写写字; 捣鼓捣鼓小技术.","description":"Android, iOS, Mobile Dev/Test, Web, Python","author":"anly_jun","url":"http://blog.lmj.wiki"},"pages":[{"title":"about me","date":"2016-08-30T16:15:09.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.lmj.wiki/about/index.html","excerpt":"","text":"初级全栈工程师/Android架构师/产品研发管理 StuQ技能图谱 Android App/ROM技能图谱 作者简书作者稀土掘金联合编辑/原创作者 关注: Android/iOS Web Python Shell 产品管理 团队管理/提升 工作流 移动互联网产品架构 UI/UE 产品演进"},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2017-09-12T15:16:05.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.lmj.wiki/categories/index.html","excerpt":"","text":""},{"title":"读书","date":"2017-09-12T15:16:05.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"reading/index.html","permalink":"http://blog.lmj.wiki/reading/index.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2017-09-12T15:16:05.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.lmj.wiki/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"阿里内推职位","slug":"others/内推职位","date":"2017-09-07T14:59:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2017/09/07/others/内推职位/","link":"","permalink":"http://blog.lmj.wiki/2017/09/07/others/内推职位/","excerpt":"","text":"阿里内推职位以下职位工作地杭州, 阿里最前沿的国际化无线团队, Alibaba.com对应的App开发团队.简历发至: an.lypear@gmail.com iOS高级开发工程师/架构师 三年以上IOS开发经验 精通Objective-C、Mac OS X、Xcode 有多个完整的IOS项目经验，至少参加过一个完整的商业级手机应用或游戏开发项目 精通常用软件架构模式，熟悉各种算法与数据结构 个性乐观开朗，逻辑思维强，善于团队合作 Android高级开发工程师/架构师 3年以上客户端开发经验，精通Android手机平台。 熟悉掌握至少一种主流手机平台编程语言（C，C++或Java等），有Java相关开发经验不少于2年 精通一主流手机平台下的高性能编程及性能调优，精通一个系列以上的高市场占有率的手机环境 开发基础良好，理解设计模式，在项目或产品中有很好的设计实践； 有强烈的责任心和团队精神，善于沟通和合作；能独立完成设计和编码； 对Android的UI控件有实际使用和优化经验者优先；有前端开发经验者优先；","categories":[{"name":"Others","slug":"Others","permalink":"http://blog.lmj.wiki/categories/Others/"}],"tags":[{"name":"Others","slug":"Others","permalink":"http://blog.lmj.wiki/tags/Others/"},{"name":"内推","slug":"内推","permalink":"http://blog.lmj.wiki/tags/内推/"},{"name":"职位","slug":"职位","permalink":"http://blog.lmj.wiki/tags/职位/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"http://blog.lmj.wiki/categories/Others/"}]},{"title":"采购申请的处理流程---责任链模式","slug":"design-pattern/chain","date":"2017-02-22T15:51:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2017/02/22/design-pattern/chain/","link":"","permalink":"http://blog.lmj.wiki/2017/02/22/design-pattern/chain/","excerpt":"前情提要上集讲到小光梳理了公司的组织架构, 利用组合模式建立起了一个可扩展变化的多层的组织架构体系. 更清晰地明确了公司各个层级, 各个部门的职责. 大家明确职责, 通力合作, 让”小光热干面”这个招牌越做越好. 然而, 小光毕竟是经历过几任大企业的人啊, 弄好组织结构只是小光企业管理的第一步, 接下来小光准备要梳理下工作流了.","text":"前情提要上集讲到小光梳理了公司的组织架构, 利用组合模式建立起了一个可扩展变化的多层的组织架构体系. 更清晰地明确了公司各个层级, 各个部门的职责. 大家明确职责, 通力合作, 让”小光热干面”这个招牌越做越好. 然而, 小光毕竟是经历过几任大企业的人啊, 弄好组织结构只是小光企业管理的第一步, 接下来小光准备要梳理下工作流了. 所有示例源码已经上传到Github, 戳这里 比如采购的审批流程刚开始, 小光只有光谷一个店的时候, 很多时候采购某些东西也就没有什么流程, 大家一商量, 小光拍板, 就派人去采购了. 然而, 现在发展到好几个分店了, 小光肯定不能做到事事过问了, 故而会有一些放权, 但是某些情况(大件的采购)小光肯定还是想要到自己这里审批的. 想到这些, 小光想着第一个需要建立的就是这个采购审批流程了. 做一个采购审批系统先分析问题那么该怎么做呢?正所谓问对了问题, 也就解决了一半. 小光一贯的做法, 是先想清楚问题是什么, 然后再针对性的出解决方案. 那么, 再回头看看, 问题具体是什么呢? 一个采购申请的审批流程系统 不同物件采购的审批流程并不是一样的(有的可能会到小光那儿, 有的没有必要) 同一个审批流程也可能会有变化(如上期组织结构所言, 公司组织结构会不断调整, 肯定会影响到采购审批层级的变化). 相应的解决点问清楚了问题, 小光针对性的想了下方案的特性: 首先肯定是一个流程化的东东, 也就是说类似流水线的处理审批单. 例如采购员提出采购单, 采购部经理审批盖章, 到总经理审批… 不只是一条这样的流水线, 不同类型审批单的流水线不一致, 故而应该是有几条流水线. 因为流水线上的操作员(由于公司层级的调整, 部门变化)会变化, 故而流水线的每个节点最好是可定制的. 解决之道了解了问题及其对应的特性, 小光开始了自己的采购审批系统设计. 首先, 对于第一个特性, 小光心想, 这很简单, 实际上就是一个指向性的调用嘛, A调用B, B再调用C…如此这般即可. 当然, 小光面向对象的编程思想已经深入脑髓, 他将采购员, 采购经理, 总经理都对象化了. 另外, 采购经理和总经理以及小光, 都视为是可以处理采购申请的人, 故而抽象出了一个RequestHandler: RequestHandler(采购申请处理人) 123456789101112131415161718192021222324252627public abstract class RequestHandler &#123; // 上一级的处理人员 private RequestHandler mNext; public RequestHandler(RequestHandler next) &#123; this.mNext = next; &#125; /** * 处理采购需求 * @param req */ public void handleRequest(Request req) &#123; printHandling(req); if (mNext != null) &#123; mNext.handleRequest(req); &#125; &#125; protected void printHandling(Request req) &#123; System.out.println(this.toString() + \"审批了:\" + req); &#125; @Override public abstract String toString();&#125; 采购经理: 123456789101112131415public class PurchasingManager extends RequestHandler &#123; /** * 构造时, 传入下一个处理人 * @param next 下一个处理人 */ public PurchasingManager(RequestHandler next) &#123; super(next); &#125; @Override public String toString() &#123; return \"采购部经理\"; &#125;&#125; 总经理和小光的实现与采购经理类似, 在此略过, 大家可以参看github上的源码. 为了满足问题的第2点: 不同物件采购的审批流程并不是一样的(有的可能会到小光那儿, 有的没有必要) 还需要有一些定制的流程: 1234567891011121314151617181920212223public class RequestFlow &#123; public static final int TYPE_SMALL_REQUEST = 1; public static final int TYPE_NORMAL_REQUEST = 2; public static final int TYPE_BIG_REQUEST = 3; public static RequestHandler getRequestChain(int type) &#123; switch (type) &#123; // 小物件, 只需采购经理审批 case TYPE_SMALL_REQUEST: return new PurchasingManager(null); // 一般物件, 需要总经理审批 case TYPE_NORMAL_REQUEST: return new PurchasingManager(new GeneralManager(null)); // 大件物品, 需要小光审批 case TYPE_BIG_REQUEST: default: return new PurchasingManager(new GeneralManager(new XiaoGuang(null))); &#125; &#125;&#125; 让我们看看采购员的请求方式: 12345678910111213141516171819// 采购员public class Buyer &#123; public static void main(String[] args) &#123; // 小需求 Request smallRequest = new Request(\"10箱饮料\"); RequestFlow.getRequestChain(RequestFlow.TYPE_SMALL_REQUEST).handleRequest(smallRequest); // 一般需求 Request normalRequest = new Request(\"10套桌椅\"); RequestFlow.getRequestChain(RequestFlow.TYPE_NORMAL_REQUEST).handleRequest(normalRequest); // 大需求 Request bigRequest = new Request(\"一套同步电子显示大屏\"); RequestFlow.getRequestChain(RequestFlow.TYPE_BIG_REQUEST).handleRequest(bigRequest); &#125;&#125; 1234567891011// 小需求 输出:采购经理审批了:10箱饮料采购申请// 一般需求 输出:采购经理审批了:10套桌椅采购申请总经理审批了:10套桌椅采购申请// 大需求 输出:采购经理审批了:一套同步电子显示大屏采购申请总经理审批了:一套同步电子显示大屏采购申请小光审批了:一套同步电子显示大屏采购申请 可以看到, 小光目前设计的这套系统是可以业务审批流程的需求的. 我们这里RequestFlow实际上采用简单工厂的模式, 适用于流程数比较少的情况. 如果考虑到后续的组织架构的变化影响什么的, 这块是值得重构一下的. 另外一个可优化的是, 我们实际上并不需要这么多的流水线, 可能只需要定制最长的那条, 然后在每个节点上根据传过来的审批请求来决定是否在当前节点就消化掉, 还是说还要传给上一级处理. 大家可以自己尝试修改下~~ 故事之后故事情节相对简单, 然而确确实实这个就是责任链模式的一个应用. 照例, 我们上UML类图, 看下各个部分的关系(为了清晰展示链的关系, 类图中国舍弃RequestFlow这个工厂): 责任链模式很多对象由每一个对象对其下家的引用(mNext)而连接起来形成一条链. 请求在这个链上传递, 直到链上的某一个对象决定处理此请求.行为解耦的一种模式, 调用者并不确切知道也无需知道行为的执行者是谁. 扩展阅读一开发Android的同学可能都用过大名鼎鼎的OkHttp了, OkHttp的核心其实就是其拦截器链(interceptor chain)的实现. 个人认为其最巧妙的也是这个拦截器链的实现了, 完美契合. 让我们先简单缕下OkHttp的request流程: 简单分析CacheInterceptor(OkHttp的缓存实现): 123456789101112131415161718192021222324252627282930313233@Override public Response intercept(Chain chain) throws IOException &#123; ... // 取缓存的Response Response cacheResponse = strategy.cacheResponse; // 如果缓存满足要求, 直接返回. 相当于采购经理能够审批该采购请求, 无需上报给总经理. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; // 如果不能, 则交给链路的下一个责任人来处理. try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; ... &#125; // 对一个链点返回的response做处理, 看是否要缓存起来. Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (HttpHeaders.hasBody(response)) &#123; CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache); response = cacheWritingResponse(cacheRequest, response); &#125; return response;&#125; 大家可以看到, 只是一个典型的责任链模式的运用.牛逼的是, OkHttp中的拦截器(interceptor)不仅仅是单向的一个链点, 而是一个双向的回路. 每个链路节点, 在request的过程中会做一次拦截处理, 诸如是否直接返回缓存, 加上统一的UserAgent等; 在response回来之后会再做一次拦截处理, 例如缓存, 根据response header做相关处理等. 如下: 强烈建议Android开发的同学可以深入研究下OkHttp的interceptor链这块的处理, 肯定是受益匪浅~ 搭建后初步的审批体系, 小光又开始畅想未来了~~ 最近工作真的是太忙了, 本系列延期了又延期, 抱歉. 借自己的广告位, 广告一波大量高级Android坑位求自荐, 求推荐.关键词:alibaba.com这个App的开发坐标杭州3年及以上Android平台开发经验简历请发至anly_jun@163.com, 谢谢.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"梳理公司的组织架构---组合模式","slug":"design-pattern/composite","date":"2017-01-18T14:01:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2017/01/18/design-pattern/composite/","link":"","permalink":"http://blog.lmj.wiki/2017/01/18/design-pattern/composite/","excerpt":"题外话本来是周更的频率, 因为真实的”小光”真实地逃离了北京, 回了武汉, 回了老家, 处理了一些私人事务. 也就有快一个月时间没有更新了, 抱歉. 年终总结也都没有时间写, 抽空写这么一篇, 提前祝大家新年快乐, 过年回家路上平安顺利. 前情提要上集讲到, 小光统一了各个分店的制作热干面的流程, 并且引入模板方法在不改变热干面的制作流程基础上可以定制其中某些步骤. 通过这些措施, 小光热干面的品牌性也是更加深入人心, 生意红红火火. 此时的小光, 有了更多的时间去思考公司的前程, 他认为, 一个良好的有序的组织架构是公司发展的必要点. 而此时, 小光也有觉得是时候梳理下公司的组织架构了.","text":"题外话本来是周更的频率, 因为真实的”小光”真实地逃离了北京, 回了武汉, 回了老家, 处理了一些私人事务. 也就有快一个月时间没有更新了, 抱歉. 年终总结也都没有时间写, 抽空写这么一篇, 提前祝大家新年快乐, 过年回家路上平安顺利. 前情提要上集讲到, 小光统一了各个分店的制作热干面的流程, 并且引入模板方法在不改变热干面的制作流程基础上可以定制其中某些步骤. 通过这些措施, 小光热干面的品牌性也是更加深入人心, 生意红红火火. 此时的小光, 有了更多的时间去思考公司的前程, 他认为, 一个良好的有序的组织架构是公司发展的必要点. 而此时, 小光也有觉得是时候梳理下公司的组织架构了. 所有示例源码已经上传到Github, 戳这里 组织架构小光参考了当前很多公司的一些架构方式, 根据分店, 职责简单梳理了下目前小光热干面的架构: 整个就是一个树形结构. 小光热干面总部下面管理着各个分店, 也有其自己的部门. 各个分店也有着自己的部门. 设计一套系统来表达这个组织架构梳理完组织关系后, 小光觉得有必要设计一套系统来管理这个关系图, 以便后续能方便的查看和管理这个架构, 并能很清晰地讲解给新员工. 简单的开始一开始, 小光并没有想太多, 按照不同的层级, 分别创建了总公司, 分店, 部门三个类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// 部门public class Department &#123; private String name; public Department(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"部门:\" + name; &#125;&#125;// 分店public class BranchOffice &#123; private String name; public BranchOffice(String name) &#123; this.name = name; &#125; private List&lt;Department&gt; departments = new ArrayList&lt;&gt;(); public void add(Department sub) &#123; departments.add(sub); &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(\"分公司:\" + name); for (Department dept : departments) &#123; builder.append(\" - \" + dept.toString()); &#125; return builder.toString(); &#125;&#125;// 总公司public class HeadOffice &#123; private String name; public HeadOffice(String name) &#123; this.name = name; &#125; private List&lt;Department&gt; departments = new ArrayList&lt;&gt;(); public void add(Department sub) &#123; departments.add(sub); &#125; private List&lt;BranchOffice&gt; branches = new ArrayList&lt;&gt;(); public void add(BranchOffice branchOffice) &#123; branches.add(branchOffice); &#125; public void print() &#123; System.out.println(\"总公司:\" + name); for (BranchOffice branch : branches) &#123; System.out.println(\" - \" + branch); &#125; for (Department dept : departments) &#123; System.out.println(\" - \" + dept); &#125; &#125;&#125;``` 利用这些层次的类来组成小光的组织架构:```javapublic class XiaoGuang &#123; public static void main(String[] args) &#123; HeadOffice headOffice = new HeadOffice(\"小光热干面\"); Department financeDept = new Department(\"财务部\"); Department strategyDept = new Department(\"策划部\"); BranchOffice ov = new BranchOffice(\"光谷分店\"); ov.add(financeDept); ov.add(strategyDept); BranchOffice huashan = new BranchOffice(\"花山分店\"); huashan.add(financeDept); huashan.add(strategyDept); headOffice.add(financeDept); headOffice.add(strategyDept); headOffice.add(ov); headOffice.add(huashan); headOffice.print(); &#125;&#125; 结果如下, 达到要求: 12345总公司:小光热干面 - 分公司:光谷分店 - 部门:财务部 - 部门:策划部 - 分公司:花山分店 - 部门:财务部 - 部门:策划部 - 部门:财务部 - 部门:策划部 小光的思考看着这新鲜出炉的架构程序, 小光总觉得哪儿不对劲儿. 毕竟小光是历经了北上广各种类型公司的人才啊, 回想起上班敲代码的日子, 小光想起了哪儿不妥了. 公司总会发展, 发展过程中总会有一些战略调整, 从而导致公司部门的各种变化. 目前小光设计的组织架构是三层架构, 但是随着公司的发展壮大, 很有可能层级会变得更多. 比如说, 总部的采购部壮大了, 可能会增加下一级的食材采购部和设备采购部. 甚至可能现在的层级还会随着公司的战略调整而升降. 例如, 如果分店开到别的城市了, 可能会在总部和分店之间插入一层”子公司”来分别管理各地的分店. 如下: 那么就出现了一个我们一直在强调的问题: 有些东西可能会一直有变化, 而我们从产品角度肯定会想要拥抱变化, 然而代码层面上我们又不想修改代码(修改原有代码意味着还有对原有逻辑负责). 那应该怎么办呢? 有没有更好的方式来表达这种树形的组织架构关系呢? 以便能够很容易地扩展层次呢? 小光又回想起了自己的码农时代, 回想当年这种问题的解决方案: 既然是因为变化, 扩展而引起的问题, 我们最重要是要先找出系统中可变和不可变的部分, 封装不可变(使其修改关闭), 拥抱可变(使其扩展开放). 小光的解决之道那么具体到这个组织系统架构的问题, 又该怎么做呢? 小光可不想每增加一个层级都要重新为其增加一个类, 然后改变原有系统. 特别是有些情况下, 曾加的类(子公司)中可能会包含分店和自己的部门. 随着类别的增加, 每次增加一个层级将会越来越难. 小光想到着, 突然想到: 每个部门/分店/子公司乃至总公司不都是部门的集合吗?部门可能有下属部门, 可能没有分店下有部门子公司下有分店, 可能还有自己的部门总公司下有子公司, 分店, 自己的部门 所以说, 所有实体(总公司/子公司/分店/部门)实际上都是由部门组成的. 这些实体也都可以看着是一个部门. 想到做到: 首先定义出基础的部门: 1234567891011121314151617181920212223242526public class Department &#123; private String name; public Department(String name) &#123; this.name = name; &#125; private List&lt;Department&gt; subDepartments = new ArrayList&lt;&gt;(); public void add(Department sub) &#123; subDepartments.add(sub); &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(name); for (Department dept : subDepartments) &#123; builder.append(\"\\n\"); builder.append(\" - \" + dept.toString()); &#125; return builder.toString(); &#125;&#125; 来看下, 利用Department这一个类别怎么搭建组织: 123456789101112131415161718192021222324252627282930public class XiaoGuang &#123; public static void main(String[] args) &#123; Department financeDept = new Department(\"财务部\"); Department strategyDept = new Department(\"策划部\"); Department ovBranchOffice = new Department(\"光谷分店\"); ovBranchOffice.add(financeDept); ovBranchOffice.add(strategyDept); Department huashanBranchOffice = new Department(\"花山分店\"); huashanBranchOffice.add(financeDept); huashanBranchOffice.add(strategyDept); Department wuhanChildOffice = new Department(\"武汉子公司\"); wuhanChildOffice.add(ovBranchOffice); wuhanChildOffice.add(huashanBranchOffice); Department changshaChildOffice = new Department(\"长沙子公司\"); Department xiaoguang = new Department(\"小光热干面\"); xiaoguang.add(wuhanChildOffice); xiaoguang.add(changshaChildOffice); xiaoguang.add(financeDept); xiaoguang.add(strategyDept); System.out.println(xiaoguang); &#125;&#125; 输出如下 1234567891011小光热干面 - 武汉子公司 - 光谷分店 - 财务部 - 策划部 - 花山分店 - 财务部 - 策划部 - 长沙子公司 - 财务部 - 策划部 输出稍有调整, 以显示直观的层级. 大家可以自行修改下代码, 来给department加入level属性, 以便输出更完美的结构. 到此, 我们算是解决了组织架构的问题了, 以后不管是增加了什么层级, 我们都只需要使用Department来表示即可, 而无需增加一个类了. 故事之后照例, 我们来缕缕小光设计的这套系统的”类关系”: 结构相当简单, 实际上就是一个类, 其中关键的是: 这个类中有一个list属性(subDepartments)包含的是一组该类. 有点递归的感觉. 这个就是我们今天想说的 — 组合模式 组合模式又叫部分整体模式，通过组合的方式, 创建一个包含了一组自己的对象组(List)的类(Department). 从而达成了用一个类来递归地表示一个整体. 组合模式通常用来解决树形结构的表达问题, 例如本例中的组织结构.所谓组合的方式, 就是创建一个包含了一组自己的对象组的类 注: 我们这里实现的相对简单, 旨在说明模式的形式.实际场景中, Department可能是一个抽象的, 例如有一个抽象方法来执行该部门的职责, 有不同的具体部门实现来实现其职责. 从而有不同的”Department实现”来组合另一个大的Department节点. 扩展阅读一前面说到, 组合模式通常用来处理树形结构的表达问题. 而我们的用户界面实现通常就是一个UI元素的节点树. 例如HTML中的div中可能有button, 还会有其他div层级, 依次往下; Java SE中的界面实现AWT和Swing包也到处是组合模式的体现; Android中的View体系, View和ViewGroup, Layout层级树也都是组合模式的体现. 在此我们以Android的View体系为例, 简单描述下.众所周知, Android的界面实际上就是一颗大树, Hierarchy Viewer中展示的就是一个树形结构. 我们来看下Android是怎么利用组合模式实现的. 如下: ViewGroup就是相当于例子中的Department, 这里面比我们的例子复杂的是, ViewGroup是扩展自View的, View实际上我们可以理解为是叶子节点, 也就是最小的组成单元了, 不再有以下的层级了. ViewGroup中包含了一组View对象, 因为ViewGroup是View的子类, 故而我们也可以说ViewGroup中包含了一组ViewGroup和/或View. 进入形成了我们之前说的递归, 生成一个树形结构. 关于View的体系, 在此不细述了. 搭建好弹性可扩展的组织架构体系, 小光又开始将眼光转移到市场, 转移到业务了, 准备着新年大展拳脚~","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"统一热干面的制作流程---模板方法","slug":"design-pattern/template_method","date":"2016-12-22T09:00:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/12/22/design-pattern/template_method/","link":"","permalink":"http://blog.lmj.wiki/2016/12/22/design-pattern/template_method/","excerpt":"前情提要上集讲到, 小光引入了日报制度, 用来从各个分店店长那儿收集信息. 如此一来, 小光每天就通过日报系统了解到各个分店的销售情况, 问题所在, 也好根据收集到的用户反馈来改善系统, 改善经营了. 不多久, 就有一个来自用户的反馈, 通过店长的日报到了小光这边:","text":"前情提要上集讲到, 小光引入了日报制度, 用来从各个分店店长那儿收集信息. 如此一来, 小光每天就通过日报系统了解到各个分店的销售情况, 问题所在, 也好根据收集到的用户反馈来改善系统, 改善经营了. 不多久, 就有一个来自用户的反馈, 通过店长的日报到了小光这边: 有用户反馈不同分店的热干面味道不太一样 所有示例源码已经上传到Github, 戳这里 统一热干面的制作流程小光是想将品牌做大, 做统一的. 当然是需要在任何分店给用户都是统一的体验啊. 所以, 小光很重视这个问题, 马上投入了这个问题的解决中. 上次在弄分店的标准时并没有统一规划下热干面的制作方法流程, 现在小光想借这个机会正好弄一套, 于是小光做了一个热干面的制作规范: 1234567891011121314151617181920212223242526272829303132333435public class HotDryNoodlesMaker &#123; public void make() &#123; // 1, 烫面 tangmian(); // 2, 装碗 zhuangwan(); // 3, 加调料(盐，鸡精，胡椒粉之类) jiatiaoliao(); // 4, 加芝麻酱 jiazhimajiang(); &#125; // 原谅我, 这些个英文真是不知道怎么说了, 以下方法名用拼音吧... // 非我所愿 private void tangmian() &#123; System.out.println(\"热干面入沸水锅焯烫十几秒\"); &#125; private void zhuangwan() &#123; System.out.println(\"热干面捞出, 装入大碗中\"); &#125; private void jiatiaoliao() &#123; System.out.println(\"加调料\"); &#125; private void jiazhimajiang() &#123; System.out.println(\"加芝麻酱\"); &#125;&#125; 各分店都用这套流程来制作热干面: 12345678public class XiaoGuang &#123; public static void main(String[] args) &#123; HotDryNoodlesMaker maker = new HotDryNoodlesMaker(); maker.make(); &#125;&#125; 1234热干面入沸水锅焯烫十几秒热干面捞出, 装入大碗中加调料加芝麻酱 看起来没有问题. 小光是个谨慎的人, 在全面启用这套流程之前, 小光决定现在光谷店试用下. 试用出了问题果然, 只有经过用户的检验的产品才是好产品, 刚试用第一天, 小光的热干面制作流程就经受考验, 出了问题. 吃客们, 有的是在店吃的, 有的是打包带走的.当初小光为了品牌性, 在店吃都是用的带有小光热干面专属标志的消毒碗的, 外带是定制的一次性碗具 现在在”装碗”这个环节出了问题~~ 解决问题解决问题的第一步是描述问题. 小光深入思考, 探索问题的本质, 发现现在的问题是: 热干面制作必须是这个流程, 而中间的某些步骤又必须可以根据实际场景改变. 也就是说, 不能改变热干面的制作流程, 但是又可以改变(重新定义)这个流程中的某一步(装碗). 如此, 小光想到了一个办法: 用一个抽象的类来定义操作步骤(当然并不会抽象所有的步骤), 由具体的子类来实现中间需要定制的步骤. 抽象的制作流程: 12345678910111213141516171819202122232425262728293031public abstract class Maker &#123; public void make() &#123; // 1, 烫面 tangmian(); // 2, 装碗 zhuangwan(); // 3, 加调料(盐，鸡精，胡椒粉之类) jiatiaoliao(); // 4, 加芝麻酱 jiazhimajiang(); &#125; private void tangmian() &#123; System.out.println(\"热干面入沸水锅焯烫十几秒\"); &#125; private void jiatiaoliao() &#123; System.out.println(\"加调料\"); &#125; private void jiazhimajiang() &#123; System.out.println(\"加芝麻酱\"); &#125; // 将装碗这一步抽象出来, 由具体的子类实现 abstract void zhuangwan();&#125; 然后分别弄一个对应的打包的maker和一个堂食的maker: 1234567891011121314151617// 打包public class PackingMaker extends Maker &#123; @Override void zhuangwan() &#123; System.out.println(\"热干面捞出, 装入一次性碗\"); &#125;&#125;// 堂食public class EatInMaker extends Maker &#123; @Override void zhuangwan() &#123; System.out.println(\"热干面捞出, 装入店内消毒碗\"); &#125;&#125; 如此这般, 制作的流程有maker控制, 但是也给了不同实现(打包, 堂食)一些自主化空间: 1234567891011121314151617Maker packingMaker = new PackingMaker();packingMaker.make();// output热干面入沸水锅焯烫十几秒热干面捞出, 装入一次性碗加调料加芝麻酱Maker eatInMaker = new EatInMaker();eatInMaker.make();// output热干面入沸水锅焯烫十几秒热干面捞出, 装入店内消毒碗加调料加芝麻酱 达成要求. 故事之后照例我们先缕缕类的关系: 在故事过程中, 我们描述了问题及其解决之道. 实际上这个解决之道就是我们今天要说的模板方法模式. 模板方法模式定义一个操作中的算法骨架(热干面的制作流程), 而将某些步骤实现延迟到子类中. 使得子类可以根据实际情况不改变算法骨架(热干面的制作流程), 但是可以重新定义或改变该算法中的某些特定步骤(例如装碗). 扩展阅读一模板方法是代码复用的基本技术, 基本上随处可见. 我们平常编码上, 如果想复用一些代码, 基本上第一个想到的就是提取父类, 抽象可变, 然后子类实现抽象部分的方式来复用. 没错, 这种用法往往你就用到模板方法模式. 所以说, 设计模式并不高深, 它实际上就是一种良好编程习惯的提炼. 我们可能随处再用, 只是有的时候我们并没有意识到. 这种代码复用的方式在一些底层库, SDK中更是被频繁使用. 例如Android中最为复杂之一的View, 就用到木板方法模式. 其draw()方法就是模板方法, onDraw()是抽象的可定制的原语操作: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 代码节选自View.java// draw()方法相当于定义了一个View的绘制算法结构, 其中的onDraw的可变的原语操作.public void draw(Canvas canvas) &#123; // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // we're done... return; &#125;&#125; /*** Implement this to do your drawing.** @param canvas the canvas on which the background will be drawn*/// 原语操作, 由子类实现, 来定制protected void onDraw(Canvas canvas) &#123;&#125; 扩展阅读二很多继承关系中, 我们都能找到模板方法的影子, 但是并非所有的继承就是用到了模板方法模式. 有的同学可能会回想起我们之前提到的策略模式. 二者看起来很像啊, 貌似都是跟替换算法有关的. 在这里简单区别下二者: 二者都是通过用继承关系来达到”算法替换”的目的.但是模板方法是不改变算法结构, 只替换/改变其中的步骤.而策略模式是改变了整个算法. 打个比方, 我从北京到武汉的过程, 定义一个回家算法 — 做火车回家, 分成几步: 上火车站买票 检票上车 一路顺风回家 如果我改变了买票的方式, 例如我不想去火车站买票了, 在网上买, 或是电话买. 但是算法结构不变, 还是做火车, 还是这三步, 那么这个就是模板方法模式. 但是如果我不想做火车了, 我开车, 我坐飞机回家, 那么就相当于替换了整个算法, 这个就是策略模式. 总之, 小光又解决了一个问题, 解决用户痛点是产品呢生存之道, 小光知道自己的热干面正在变得越来越好…哈哈.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"日报表格只有一份---单例模式","slug":"design-pattern/singleton","date":"2016-12-20T04:00:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/12/20/design-pattern/singleton/","link":"","permalink":"http://blog.lmj.wiki/2016/12/20/design-pattern/singleton/","excerpt":"前情提要上集讲到, 小光建立了开分店的标准(工厂), 以后开分店都按照这套标准执行(从CompanyFactory的实现中生产开分店的必须东西), 开分店变得更加容易了. 小光也是马上将自己的这套”开分公司的工厂”投入使用了, 开出了花山软件新城分店. 随着分店越来越多, 小光也请了分别请了店长来”代理”小光之前的职责. 当然, 小光可不能完全放任不管啊, 他想着我至少得知道下每天各个店的基本情况吧.","text":"前情提要上集讲到, 小光建立了开分店的标准(工厂), 以后开分店都按照这套标准执行(从CompanyFactory的实现中生产开分店的必须东西), 开分店变得更加容易了. 小光也是马上将自己的这套”开分公司的工厂”投入使用了, 开出了花山软件新城分店. 随着分店越来越多, 小光也请了分别请了店长来”代理”小光之前的职责. 当然, 小光可不能完全放任不管啊, 他想着我至少得知道下每天各个店的基本情况吧. 所有示例源码已经上传到Github, 戳这里 日报制度小光想到了当时做程序猿时, 敏捷开发每天站立会议的三个问题: 昨天完成了什么 今天要做什么 有什么困难, 阻力 心想, 我也可以根据这个弄个日报制度啊, 让各个店长按照这个格式汇报下当天的战绩: 表格: 12345678910111213public class Form &#123; private ArrayList&lt;String&gt; mFormData = new ArrayList&lt;&gt;(); public void write(String data) &#123; mFormData.add(data); &#125; @Override public String toString() &#123; return \"表格:\" + this.hashCode() + \", 数据:\" + mFormData; &#125;&#125; 每天让各个店子在打烊之前在系统中拿当日的表格(如果还没有, 就创建一个)来填写数据, 然后提交. 出了问题想法挺好, 但是刚刚用上, 就出了问题: 光谷店店长表妹登录系统, 发现2016-12-16这个文件夹中还没有表格文件, 于是本地创建了一个, 用来填写数据, 准备稍后提交. 然而此时, 花山店的店长小章也登录了系统, 也发现还没有表格文件, 也创建了一个… 让我们来看下操作: 表妹: 12345678public class Cousins &#123; public Form submitReport() &#123; Form form = new Form(); form.write(\"光谷店数据\"); return form; &#125;&#125; 小章: 12345678public class XiaoZhang &#123; public Form submitReport() &#123; Form form = new Form(); form.write(\"花山店数据\"); return form; &#125;&#125; 两人的使用流程: 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; Cousins cousins = new Cousins(); Form form = cousins.submitReport(); System.out.println(form); XiaoZhang xiaoZhang = new XiaoZhang(); Form form2 = xiaoZhang.submitReport(); System.out.println(form2); &#125;&#125; 来看下结果: 12表格:1639705018, 数据:[光谷店数据]表格:1627674070, 数据:[花山店数据] 最终这个文件夹中有了两个(不同的)表格, 小光看起来很是不方便… 表格应该只能有一份表格只能有一份, 小光心想. 那么怎么保证呢, 很简单, 我提前给创建好, 大家通过统一的接口来取这个文件, 而不能自己创建. 这样就不会有问题了: 12345678910111213public class HungryForm extends Form &#123; // 提前创建好 private static HungryForm sInstance = new HungryForm(); // 私有化的构造, 避免别人直接创建表格 private HungryForm() &#123;&#125; // 店长们通过这个接口来取表格 public static HungryForm getInstance() &#123; return sInstance; &#125;&#125; 店长们这样提交报告: 12345678910111213141516171819202122232425public class Cousins &#123; public Form submitReport() &#123; // 直接新建一个表格 // Form form = new Form(); // 从固定的接口取表格 Form form = HungryForm.getInstance(); form.write(\"光谷店数据\"); return form; &#125;&#125;public class XiaoZhang &#123; public Form submitReport() &#123; // 直接新建一个表格 // Form form = new Form(); // 从固定的接口取表格 Form form = HungryForm.getInstance(); form.write(\"花山店数据\"); return form; &#125;&#125; 提交方式不变: 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; Cousins cousins = new Cousins(); Form form = cousins.submitReport(); System.out.println(form); XiaoZhang xiaoZhang = new XiaoZhang(); Form form2 = xiaoZhang.submitReport(); System.out.println(form2); &#125;&#125; 来看下现在的结果: 12表格:1639705018, 数据:[光谷店数据]表格:1639705018, 数据:[光谷店数据, 花山店数据] 可以看到两人用的是同一份表格(hashCode一样的), 生成的数据也没有问题了. 故事之后看到这, 同学们应该都看出来了, 小光这就是使用了大名鼎鼎的单例模式.照例, 看下类图, 这个应该是最简单的类图了: 单例模式保证一个类(HungryForm)仅有一个实例(sInstance), 并提供一个访问该实例的全局访问点(getInstance).这就意味着单例通常有如下两个特点: 构造函数是私有的(避免别的地方创建它) 有一个static的方法来对外提供一个该单例的实例. 扩展阅读一同学们可能注意到了, 我们在这个单例模式中使用了Hungry这个词, 没错, 我们这里实现单例的方式使用的就是饿汉式. 1, 饿汉式单例 饿汉式单例顾名思义, 就是很饿, 不管三七二十一先创建了一个实例放着, 而不管最终用不用. 然而, 这个单例可能最终并不需要, 如果提前就创建好, 就会浪费内存空间了.例如, 我们这个故事中, 年底假期中, 所有店子都歇业十天, 这十天就没有任何店长会去访问这个表格, 然而小光还是都每天都创建了, 这就造成了空间浪费(假设这个表格数据(对象实例)很大…) 2, 懒汉式单例那么怎么办呢?我们可以使用懒汉式单例: 1234567891011121314151617public class LazyForm extends Form &#123; private static LazyForm sInstance; // 私有化的构造, 避免别人直接创建表格 private LazyForm() &#123;&#125; // 店长们通过这个接口来取表格 public static LazyForm getInstance() &#123; // 在有店长访问该文件时才创建, 通过判断当前文件是否存在(sInstance == null)来避免重复创建 if (sInstance == null) &#123; sInstance = new LazyForm(); &#125; return sInstance; &#125;&#125; 懒汉式单例“懒”, 也就是现在懒得创建, 等有用户要用的时候才创建. 3, 线程安全的懒汉式单例但是这样创建也会有问题啊, 因为他是通过sInstance == null判断当前是否已经存在表格文件的, 假设有两个店长同时调用getInstance来取文件, 同时走到sInstance == null判断这一步, 就会出问题了 — 有可能创建了两个文件(实例), 就达不到单例的目的了. 所以说这种懒汉式是线程不安全的, 在多线程环境下, 并不能做到单例. 那么, 该如何做, 既能懒加载, 又线程安全呢?我们都知道Java中多线程环境往往会用到synchronized关键字, 通过他来做线程并发性控制. synchronized方法控制对类成员变量的访问, 每个类实例对应一把锁, synchronized修饰的方法必须获得调用该方法的类实例的锁方能执行, 否则所属线程阻塞. 方法一旦执行, 就独占该锁. 直到从该方法返回时才将锁释放. 此后被阻塞的线程方能获得该锁, 重新进入可执行状态. 让我们来看下线程安全的懒汉式单例: 12345678910111213141516171819public class SynchronizedLazyForm extends Form &#123; private static SynchronizedLazyForm sInstance; // 私有化的构造, 避免别人直接创建表格 private SynchronizedLazyForm() &#123;&#125; // 店长们通过这个接口来取表格 // 注意, 这是一个synchronized方法 // 参考https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html public static synchronized SynchronizedLazyForm getInstance() &#123; // 在有店长访问该文件时才创建, 通过判断当前文件是否存在(sInstance == null)来避免重复创建 if (sInstance == null) &#123; sInstance = new SynchronizedLazyForm(); &#125; return sInstance; &#125;&#125; 线程安全的懒汉式单例利用synchronized关键字来修饰对外提供该类唯一实例的接口(getInstance)来确保在一个线程调用该接口时能阻塞(block)另一个线程的调用, 从而达到多线程安全, 避免重复创建单例. 然而, synchronized有很大的性能开销. 而且在这里我们是修饰了getInstance方法, 意味着, 如果getInstance被很多线程频繁调用时, 每次都会做同步检查, 会导致程序性能下降. 实际上我们要的是单例, 当单例已经存在的时候, 我们是不需要用同步方法来控制的. 一如我们第一种单例的实现—饿汉模式单例, 我们一开始就创建好了单例, 就无需担心线程同步问题. 但是饿汉模式是提前创建, 那么我们怎么能做到延迟创建, 且线程安全, 且性能有所提升呢? 4, 双重检查锁定DCL(Double-Checked Locking)单例如上所言, 我们想要的是单例, 故而单例已经存在的情况下我们无需做同步检查, 如下实现: 12345678910111213141516171819202122232425public class DCLForm extends Form &#123; // 注意, 这里我们引入了volatile关键字 private volatile static DCLForm sInstance; // 私有化的构造, 避免别人直接创建表格 private DCLForm() &#123;&#125; // 店长们通过这个接口来取表格 public static DCLForm getInstance() &#123; // 第一次检查 if (sInstance == null) &#123; // 第一次调用getInstance时, sInstance为空, 进入此分支 // 使用synchronized block来确保多线程的安全 synchronized (DCLForm.class) &#123; // 第二次检查 if (sInstance == null) &#123; sInstance = new DCLForm(); &#125; &#125; &#125; return sInstance; &#125;&#125; 舍弃了同步方法 在getInstance时, 先检查单例是否已经存在, 如果存在了, 我们无需同步操作了, 任何线程过来直接取单例就行, 大大提升了性能. 若单例不存在(第一次调用时), 使用synchronized同步代码块, 来确保进入的只有一个线程, 在此再做一次单例存在与否的检查, 进而创建出单例. 这样就保证了: 在单例还没有创建时, 多个线程同时调用getInsance时, 保证只有一个线程能够执行sInstance = new DCLForm()创建单例. 在单例已经存在时, getInsance没有加锁, 直接访问, 访问创建好的单例, 从而达到性能提升. 注意这里我们对sInstance使用的volatile关键字具体原因和原理, 请参考这篇文章, 讲的很详细. 然而, 使用volatile关键字的双重检查方案需要JDK5及以上(因为从JDK5开始使用新的JSR-133内存模型规范，这个规范增强了volatile的语义). 那么我们还有什么更通用的方式能保证多线程单例创建, 以及懒加载方式呢? 5, 静态内部类单例123456789101112131415public class StaticInnerClassForm extends Form &#123; // 私有化的构造, 避免别人直接创建表格 private StaticInnerClassForm() &#123;&#125; // 店长们通过这个接口来取表格 public static StaticInnerClassForm getInstance() &#123; return FormHolder.INSTANCE; &#125; // 在静态内部类中实例化该单例 private static class FormHolder &#123; private static final StaticInnerClassForm INSTANCE = new StaticInnerClassForm(); &#125;&#125; 这种方式, 通过JVM的类加载方式(虚拟机会保证一个类的初始化在多线程环境中被正确的加锁、同步), 来保证了多线程并发访问的正确性. 另外, 由于静态内部类的加载特性 — 在使用时才加载, 这种方式也达成了懒加载的目的. 显然, 这种方式是一种比较完美的单例模式. 当然, 它也有其弊端, 依赖特定编程语言, 适用于JAVA平台. 还有很多单例的实现模式, 例如利用JDK 5起的Enum 枚举单例模式, 使用容器类管理的单例模式等, 在此就不一一说了, 网上都比较泛滥了… 从使用上, 如果是单线程环境的, 个人推荐使用第二种懒汉式单例, 简单便捷. 如果考虑多线程同步的话, 推荐使用第五种静态内部类单例, 确保同步且懒加载完美结合. 好了, 小光创建并改善了一套完整的日报系统. 这样, 他每天就可以看到各个分店的战况了, 也能根据各个店的问题, 来及时协调资源解决, 保证各个分店的良好运转了.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"是时候弄一套开分店的标准了---抽象工厂","slug":"design-pattern/abstract_factory","date":"2016-12-15T08:27:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/12/15/design-pattern/abstract_factory/","link":"","permalink":"http://blog.lmj.wiki/2016/12/15/design-pattern/abstract_factory/","excerpt":"前情提要上集讲到, 小光(利用原型模式)Copy了光谷店的模式, 成功开张了创业街分店. 现在两家分店都运营得不错, 小光闲暇之时, 又陷入了思考(思考是个好习惯). 琢磨着, 这次开分店, 我是完全clone了光谷店的那一套, 然后修改了一些个属性(例如分店名字什么的). 但是, 以后小光热干面的发展, 还会开出很多分店呢, 而且没家分店可能不仅仅是名字不一样, 还有一些诸如饮料杯上的地址什么的也会不一样, clone起来是很方便, 但是万一哪次忘了改属性了, 就麻烦了. 想到着, 小光心想, 是时候制定一套开分店的标准流程/方式了.","text":"前情提要上集讲到, 小光(利用原型模式)Copy了光谷店的模式, 成功开张了创业街分店. 现在两家分店都运营得不错, 小光闲暇之时, 又陷入了思考(思考是个好习惯). 琢磨着, 这次开分店, 我是完全clone了光谷店的那一套, 然后修改了一些个属性(例如分店名字什么的). 但是, 以后小光热干面的发展, 还会开出很多分店呢, 而且没家分店可能不仅仅是名字不一样, 还有一些诸如饮料杯上的地址什么的也会不一样, clone起来是很方便, 但是万一哪次忘了改属性了, 就麻烦了. 想到着, 小光心想, 是时候制定一套开分店的标准流程/方式了. 所有示例源码已经上传到Github, 戳这里 分店都有什么根据现有的经验, 小光很快总结出来了目前按照他的方式开一家热干面店基本包括的一系列东西: 店铺 收银台 杯具餐具 热干面流程 饮料机套路 活动策略 … 为便于区分讲解, 我们以前三个为例. 建立开分店的标准方式制定每项东西标准本着良好的面向接口编程思维, 小光照例给这些东西制定了一些标准(接口). 门面: 12345678public interface Store &#123; // 地址 String getAddress(); // 店铺名 String getName();&#125; 收银台: 12345public interface Checkstand &#123; // 银行账户 String getAccount();&#125; 12345public interface Tableware &#123; // 标签 String getLabel();&#125; 统一配置生产接下来, 小光要做的就是想着统一下每个分店开店的标准, 既要避免开分店时别遗漏了什么, 也能根据不同分店的配置开出不一样的分店. (开闭原则) 开分店的标准如下: 12345678public interface CompanyFactory &#123; Store createStore(); Checkstand createCheckstand(); Tableware createTableware();&#125; 按照这个方式开分店好的, 让我们来试下按照这个标准套路来开出SBI创业街分店. 先实现创业街分店的Store, Checkstand和Tableware: 123456789101112131415161718192021222324252627public class SbiStore implements Store &#123; @Override public String getAddress() &#123; return \"关山创业街\"; &#125; @Override public String getName() &#123; return \"SBI店\"; &#125;&#125;public class SbiCheckStand implements Checkstand &#123; @Override public String getAccount() &#123; return \"招商银行:620123131231233\"; &#125;&#125;public class SbiTableware implements Tableware &#123; @Override public String getLabel() &#123; return \"SBI\"; &#125;&#125; 然后, 实现一个SBI的专属工厂来生成这些东西: 12345678910111213141516public class SbiCompanyFactory implements CompanyFactory &#123; @Override public Store createStore() &#123; return new SbiStore(); &#125; @Override public Checkstand createCheckstand() &#123; return new SbiCheckStand(); &#125; @Override public Tableware createTableware() &#123; return new SbiTableware(); &#125;&#125; 让我们利用SBI工厂生成的东西组建一个分店吧: 123456789101112public class XiaoGuang &#123; public static void main(String[] args) &#123; CompanyFactory factory = new SbiCompanyFactory(); // 来根据factory生产出来的东西构建一个分店: Company sbiCompany = new Company(factory.createStore(), factory.createCheckstand(), factory.createTableware()); System.out.println(sbiCompany); &#125;&#125; 结果: 1分店&#123;地址:关山创业街, 名字:SBI店, 收银账户:招商银行:620123131231233, 杯具餐具标签:SBI&#125; 不负众望啊, 创建出来SBI店了. 以后我们就可以根据这种方式开分店了例如, 如果想开一家花山软件新城店, 按照上面开创业街店的方式: 实现花山店的店铺 HuashanStore. 实现花山店的收银台 HuashanCheckStand. 实现花山店的餐具 HuashanTableware. 实现生产花山店的这些东西的工厂 HuashanCompanyFactory. 代码就不一一贴了, 完整代码戳这里. 来看下怎么开出花山分店: 1234567// 创建Huashan工厂factory = new HuashanCompanyFactory();// 根据factory生产出来的东西构建花山店:Company huashanCompany = new Company(factory.createStore(), factory.createCheckstand(), factory.createTableware());System.out.println(huashanCompany); 结果: 1分店&#123;地址:花山软件新城, 名字:花山店, 收银账户:建设银行:62610000000000, 杯具餐具标签:HS&#125; 好的, 花山店创建完毕. 故事之后在这次建立创建分店的标准中, 小光一直想做就是: 确定分店的开设方式标准, 避免修改原有的分店产品, 方便扩展开出新的分店. 这个实际上就是我们屡次提到的开闭原则的思想, 即对修改关闭(不修改原有的), 对扩展开放(方便扩展出新的产品/实例). 惯例, 我们来梳理下类之间的关系: 没错, 这个就是我们今天的主角 — 抽象工厂模式. 抽象工厂提供一个创建一系列相关或互相依赖的对象的接口, 而无需指定它们的具体实现. 在本例中这个接口就是CompanyFactory, 它创建了一系列相关的对象(Store, Checkstand, Tableware), 并且这些对象并非具体实现(也是接口). 具体的对象实例是由实现了CompanyFactory接口的HuashanCompanyFactory, SbiCompanyFactory来创建的. 扩展阅读一到目前为止, 算上这个, 我们提到了三种工厂: 小光热干面提供饮料了 — 简单工厂 光氏饮品升级了 — 工厂方法 是时候弄一套开分店的标准了 — 抽象工厂 那么这三者有什么区别呢? 我们首先来对比下三者的类图: 简单工厂实际上我们可以理解为是一种编程习惯, 将类似对象的初始化放下一个地方, 便于管理.它提供了一个工厂(表妹), 来根据不同的指令(drinkType)来生产不同的饮料产品(橙汁, 可乐, 酸梅汤).相对简单, 适用于要创建类似(实现同一接口的)的产品, 且产品种类不多, 扩展可能性不大的情况. 当需要增加一中饮料时, 我们需要修改工厂(表妹)的实现, 增加drinkType的对应实现. 工厂方法顾名思义, 有一个工厂, 工厂(饮料机)里有那么一个方法(定义了一个创建对象的接口makeDrink), 可以生产产品(Drink). 由实现了这个工厂方法的类来决定具体生产出什么产品(可以是可乐, 橙汁, 奶茶等). 相比于简单工厂, 工厂方法有良好的扩展性, 当我们需要增加一种饮料时, 不需要去修改工厂, 只需扩展一个新的工厂, 实现其工厂方法, 提供新的饮料即可. 这实际上就是典型的, 通过继承/实现, 来达成了对修改关闭, 对扩展开放的效果. 另外, 从简单工厂到工厂方法, 我们也可以理解为是一次Switch Statements的重构. 对于”Switch Statements的重构”, 有兴趣的同学可以参看&lt;&lt;重构–改善既有代码的设计&gt;&gt;一书的3.10节. 那是一本好书, 2010年的时候华为的一位技术经理推荐给我的, 感谢他. 另外, 并不是我们以后遇到Switch就要想着改造, 遇到简单工厂就想着用工厂方法…还需根据实际情况取用合适的. 抽象工厂同样, 从名字中, 我们大致能了解, 抽象工厂描述的一个抽象的工厂, 其可以生产一系列的相关的或是互相依赖的产品. 抽象工厂和工厂方法有很多类似之处, 都是创建产品, 都是通过继承/实现, 来达成了对修改关闭, 对扩展开放的效果. 然而, 抽象工厂相较于工厂方法, 它的重点, 是它解决的是一个产品族(相关的, 或是互相依赖的产品们)的创建问题, 而非仅仅是一类产品. 以本故事来说, 工厂方法是用来创建一类产品, 通过他创建出来的都是饮料. 而抽象工厂是用来创建一系列产品, 包括店铺, 收银台, 餐具等, 这些产品是相关的, 都是一个分店所需要的. 打个比方, 如果我有一个轮胎工厂, 我生产的东西都是轮胎, 只是规格不同, 我就可以使用工厂方法; 如果我是一个汽车工厂, 我生产汽车, 它需要轮胎, 车架, 发动机… 那么我就应用使用抽象工厂. 扩展阅读二前文, 原型模式我们讲到, 原型工厂, 会经常跟工厂一起用. 那么它一般会与哪种工厂一起用呢, 没错, 就是我们今天说的抽象工厂. 为什么呢?我们回过头来看下, 我们抽象工厂创建的过程, 是不是创建了很多对象啊. 是的, 抽象工厂如果生产的产品系列很多的话, 我们会发现我们会创建很多很多的对象(产品), 而这些对象有的时候是可能一样的, 有可能是很类似的. 例如, 我们的分店工厂创建了收银台(Checkstand), 这个不同的分店的收银台可能都是一样的, 稍微有点不同可能是仅仅是账户不一样, 我们没有必要去重新创建一个. 回想下, 原型模式的使用 — 使用clone的方式来快速创建一个新的(与原型对象实例一致的)对象实例. 这种方法可以避免我们屡次复杂的创建. 我们当前的Checkstand创建可能相对简单, 想象下, 如果Checkstand足够复杂的时候, clone将会是很有用的. 具体的实现, 大家可以私下去改造下本例代码, 融合下原型模式, 体验下. OK, 创建出开分店的标准了, 小光想着, 以后开分店都不用我亲力亲为的…哈哈.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"创业街分店开张啦---原型模式","slug":"design-pattern/prototype","date":"2016-12-04T11:07:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/12/04/design-pattern/prototype/","link":"","permalink":"http://blog.lmj.wiki/2016/12/04/design-pattern/prototype/","excerpt":"前情提要上集讲到, 小光请来堂哥大龙作为自己的代理与饮品供应商谈判, 最终大龙用自己丰富的商场经验帮小光拿到合适的价格. 小光也是尝到了代理的甜头, 开始将店里的更多工作交给表妹来打理, 自己腾出功夫去选新的分店地址了.","text":"前情提要上集讲到, 小光请来堂哥大龙作为自己的代理与饮品供应商谈判, 最终大龙用自己丰富的商场经验帮小光拿到合适的价格. 小光也是尝到了代理的甜头, 开始将店里的更多工作交给表妹来打理, 自己腾出功夫去选新的分店地址了. 所有示例源码已经上传到Github, 戳这里 新店建设根据光谷店的经营经验, 很快, 小光就选好了分店的地址—创业街. 还是为了造福广大屌丝单身程序猿们啊, 哈哈. 分店的建设相对第一家店的开辟来说也是简单了很多, 在光谷店的探索, 诸如热干面生产流程, 饮料机机制, 活动策略等都可以复制过来用. 简单来说, 就是复制成功原型, 如下: 照例, 抽象出一个公司的类: 12345678910111213141516171819202122232425262728293031323334353637383940public class Company implements Cloneable &#123; // 此处我们假装省略了N多, 诸如活动策略, 饮料机, 热干面生产流程等. // 再此仅以饮品为例 private ArrayList&lt;String&gt; drinks = new ArrayList&lt;&gt;(); private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void addDrink(String drink) &#123; drinks.add(drink); &#125; @Override protected Company clone() &#123; Company company = null; try &#123; company = (Company) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return company; &#125; @Override public String toString() &#123; return \"&#123;\" + \"名字: '\" + getName() + '\\'' + \", 饮品: \" + drinks + '\\'' + '&#125;'; &#125;&#125; 光谷店: 123456789public class OpticalValleyCompany extends Company &#123; public OpticalValleyCompany() &#123; setName(\"光谷软件园分店\"); addDrink(\"橙汁\"); addDrink(\"可乐\"); addDrink(\"酸梅汤\"); &#125;&#125; 看下小光是如何复制光谷店的成功, 创建新的创业街分店的: 1234567891011121314public class XiaoGuang &#123; public static void main(String[] args) &#123; // new 光谷店 Company ovCompany = new OpticalValleyCompany(); System.out.println(\"光谷店: \" + ovCompany); // 在光谷店的基础上clone SBI店 Company sbiCompany = ovCompany.clone(); sbiCompany.setName(\"创业街分店\"); System.out.println(\"SBI店: \" + sbiCompany); &#125;&#125; output: 12光谷店: &#123;名字: '光谷软件园分店', 饮品: [橙汁, 可乐, 酸梅汤]'&#125;SBI店: &#123;名字: '创业街分店', 饮品: [橙汁, 可乐, 酸梅汤]'&#125; 看样子很成功, 小光开始准备试运营了. 试运营小光信心满满的开始了新店的试运营. 为了庆祝分店开张, 小光新拿了一款饮料XDrink在新店做活动, 买热干面赠送饮料. 12345678// 在光谷店的基础上clone SBI店Company sbiCompany = ovCompany.clone();sbiCompany.setName(\"创业街分店\"); // 给SBI店新增一款饮品sbiCompany.addDrink(\"雪碧\"); System.out.println(\"SBI店: \" + sbiCompany); 这时, SBI店的饮品列表是: 1SBI店: &#123;名字: &apos;创业街分店&apos;, 饮品: [橙汁, 可乐, 酸梅汤, 雪碧]&apos;&#125; 看着很好, Perfect.然而, 这时, 表妹打来电话了, 说我光谷店这边的菜单系统怎么无端多出一款雪碧的饮料啊, 我这没有提供的啊, 怎么给客户啊. 小光立马打印了下光谷店的信息(基于上面的修改): 1234567891011// 在光谷店的基础上clone SBI店Company sbiCompany = ovCompany.clone();sbiCompany.setName(&quot;创业街分店&quot;);// 给SBI店新增一款饮品sbiCompany.addDrink(&quot;雪碧&quot;);System.out.println(&quot;SBI店: &quot; + sbiCompany);// 打印下光谷店ovCompanySystem.out.println(&quot;光谷店: &quot; + ovCompany); 果然, 光谷店新增了”雪碧”, 12SBI店: &#123;名字: '创业街分店', 饮品: [橙汁, 可乐, 酸梅汤, 雪碧]'&#125;光谷店: &#123;名字: '光谷软件园分店', 饮品: [橙汁, 可乐, 酸梅汤, 雪碧]'&#125; 这样当然是不好的咯, 小光只想复制光谷店的基本流程架构过来, 后续两个店的某些方面还是要分开发展的, 可不能一改俱改啊. 改进之路小光又开始了clone的改进之路. 先回头看下, 小光之前是怎么clone的: 1234567891011@Overrideprotected Company clone() &#123; Company company = null; try &#123; company = (Company) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return company;&#125; 我们注意到, 这个clone只是clone了Company, 并没有clone Company内部的引用(ArrayList drinks). 也就是说clone出来的对象和之前的对象会使用同一份drinks列表注1, 这显然不是小光愿意看到的. 小光也很快想到了解决方案, 改造了clone过程: 1234567891011121314@Overrideprotected Company clone() &#123; Company company = null; try &#123; company = (Company) super.clone(); // 对于对象的属性也加以clone company.drinks = (ArrayList&lt;String&gt;) this.drinks.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return company;&#125; 这次小光不仅clone了Company, 还clone了其属性值drinks注2. 让我们来看下小光的成果: 和之前同样的使用: 12345678910111213// new 光谷店Company ovCompany = new OpticalValleyCompany();System.out.println(\"光谷店: \" + ovCompany);// 在光谷店的基础上clone SBI店Company sbiCompany = ovCompany.clone();sbiCompany.setName(\"创业街分店\");// 给SBI店新增一款饮品sbiCompany.addDrink(\"雪碧\");System.out.println(\"SBI店: \" + sbiCompany);System.out.println(\"光谷店: \" + ovCompany); 改造后的结果: 123光谷店: &#123;名字: '光谷软件园分店', 饮品: [橙汁, 可乐, 酸梅汤]'&#125;SBI店: &#123;名字: '创业街分店', 饮品: [橙汁, 可乐, 酸梅汤, 雪碧]'&#125;光谷店: &#123;名字: '光谷软件园分店', 饮品: [橙汁, 可乐, 酸梅汤]'&#125; 我们看到, 光谷店不会因为SBI店的改变而改变了.小光热干面SBI店试运营正式开始, 欢迎大家光临咯… 故事之后我们在故事中多次提到了clone, 原型. 没错, 这个就是原型模式. 照例, 我们来梳理下类之间的关系, 相对简单: 原型模式:通过原型对象实例, 使用clone的方式来快速创建一个新的(与原型对象实例一致的)对象实例. 由于原型模式较为通用, 且相对简单, Java中的最基类Object已经提供了clone方法, 来方便我们复制出新的对象实例. 扩展阅读一上述故事中, 我们在某些加了注1, 注2的标签. 这就是我们今天的扩展阅读一要注意的内容: 注1 浅拷贝注2 深拷贝 其实, 跟随故事我们也大致了解了浅拷贝和深拷贝的区别: 浅拷贝对于要克隆的对象, 会复制其基本数据类型(包括String)的属性(本例中的name属性)的值给新的对象. 而对于非基本数据类型的属性(本例中的drinks), 仅仅复制一份引用给新产生的对象, 即新产生的对象和原始对象中的非基本数据类型的属性都指向的是同一个对象. 深拷贝 对于要克隆的对象, clone出的非基本数据类型的属性(要求属性也实现了Cloneable接口, ArrayList就已经自带实现了)不再是和原对象指向同一个对象了, 而是一个新的clone出来的属性对象实例. 如下: 扩展阅读二如果我们查看java源码, 可以发现, 我们调用的clone()方法是Object对象的. 而不是Cloneable接口的. 那么我们为什么要实现Cloneable接口呢? 不识闲Cloneable接口可否调用Object的clone()方法呢? 我们先来看下Cloneable接口的源码: 12public interface Cloneable &#123;&#125; 发现其中并没有任何方法. 幸运的是Java源码的java doc注释足够清晰: 1234567891011121314151617181920/** * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to * indicate to the &#123;@link java.lang.Object#clone()&#125; method that it * is legal for that method to make a * field-for-field copy of instances of that class. * &lt;p&gt; * Invoking Object&apos;s clone method on an instance that does not implement the * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown. * &lt;p&gt; * By convention, classes that implement this interface should override * &lt;tt&gt;Object.clone&lt;/tt&gt; (which is protected) with a public method. * See &#123;@link java.lang.Object#clone()&#125; for details on overriding this * method. * &lt;p&gt; * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &lt;tt&gt;clone&lt;/tt&gt; method. * Therefore, it is not possible to clone an object merely by virtue of the * fact that it implements this interface. Even if the clone method is invoked * reflectively, there is no guarantee that it will succeed. */ 大体我们可以理解几点: Cloneable可以看着是一个标识, 实现了改接口的类才能合法地调用其从Object类中继承而来的clone()方法. 如果没有实现Cloneable接口而调用clone()方法, 会触发CloneNotSupportedException异常. 实现Cloneable接口的类应当重写Object的clone()方法. 扩展阅读三原型模式也是一种创建型的设计模式, 一般会结合工厂模式一起使用, 来构建对象. 本例中就不扩展了. 好了, 小光热干面创业街分店开张啦, 吃热干面赠雪碧了, 欢迎大家光临, 欢迎大家关注.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"大龙帮忙去谈判---代理模式","slug":"design-pattern/proxy","date":"2016-11-28T08:07:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/11/28/design-pattern/proxy/","link":"","permalink":"http://blog.lmj.wiki/2016/11/28/design-pattern/proxy/","excerpt":"前情提要上集讲到, 小光利用装饰者模式调校好了饮品加料(糖, 冰, 蜂蜜…)的流程. 从此再也不怕客户的各种要求了. 各式饮品也成了小光热干面店的一大特色. 当然, 饮品的试喝也不是无期限了. 试喝期快结束了, 小光跟表妹商量了下, 结合顾客们的反馈, 他们选定了其中三家, 到底使用哪家还需要跟商家再谈判下决定.","text":"前情提要上集讲到, 小光利用装饰者模式调校好了饮品加料(糖, 冰, 蜂蜜…)的流程. 从此再也不怕客户的各种要求了. 各式饮品也成了小光热干面店的一大特色. 当然, 饮品的试喝也不是无期限了. 试喝期快结束了, 小光跟表妹商量了下, 结合顾客们的反馈, 他们选定了其中三家, 到底使用哪家还需要跟商家再谈判下决定. 所有示例源码已经上传到Github, 戳这里 小光的烦恼临近和供应商的谈判期了, 小光有点发怵了. 以往都是跟计算机打交道, 与人交道少, 何况还是商场…虽然自己是采购方, 不免还是有点虚. 先来看看要签单的小光: 123456789101112131415161718// 照例抽象了一个Person接口:public interface Person &#123; /** * 签单 * @param price */ void signing(int price);&#125;// 心底发虚的小光:public class XiaoGuang implements Person &#123; @Override public void signing(int price) &#123; System.out.println(\"小光以\" + price + \"每箱的价格签单.\"); &#125;&#125; 大龙出场于是, 小光找来了做建材生意的堂哥大龙, 让大龙帮忙去谈判. 大龙欣然接受, 带着小光的底线就去了. 12345678910111213141516171819202122232425// 大龙public class DaLong implements Person &#123; private Person person; public DaLong(Person person) &#123; this.person = person; &#125; @Override public void signing(int price) &#123; System.out.println(\"对方报价:\" + price); if (price &lt; 100) &#123; this.person.signing(price); &#125; else &#123; negotiate(price); &#125; &#125; public void negotiate(int price) &#123; System.out.println(\"不接受, 要求降价\" + (price - 80)); &#125;&#125; 大龙也继承自Person, 有签单的职责. 但是除了signing, 大龙还肩负谈判(negotiate)的职责. 在签单上也有一些限制(小光给他的底线是100每箱). 当然, 谈下来了, 签字还是需要小光签的. 谈判开始大龙虽然比小光大不了几岁, 但可以说是商场老手了. 拿到小光的底线后, 他自己在这个基础上再砍了20, 然后去跟饮品供应商谈判了. 12345678910111213141516public class Demo &#123; public static void main(String[] args) &#123; DaLong daLong = new DaLong(new XiaoGuang()); // 第一轮, 对方报价120. daLong.signing(120); // 第二轮, 对方报价100. daLong.signing(100); // 第三轮, 对方报价90. daLong.signing(90); &#125;&#125; 酒桌上, 拉锯三轮, 拿下: 123456789// output对方报价:120不接受, 要求降价40对方报价:100不接受, 要求降价20对方报价:90小光以90每箱的价格签单. 果然还是大龙技高一筹啊, 以比小光预期更少的价格成交.小光也是从中学习到不少技巧…拜服大龙哥. 故事之后照例, 故事之后, 我们用UML类图来梳理下上述的关系: 相比于之前的关系, 这个相对简单, 就两个角色, 小光和大龙, 都实现了Person接口. 关键点在于: 大龙是直接和供应商打交道的, 但是实际的决策和行为(签单)是由小光来做的. 也就是说大龙是小光的代理. 这就是我们所要说的代理模式:为其他对象(小光)提供一个代理(大龙)以控制对这个对象的访问. 在我们这个例子, 由于小光怯场, 不方便直接和供应商谈判, 故而派出了代理大龙来直面供应商. 扩展阅读一细心的同学可能有发现, 这个例子的模式貌似和前文装饰模式有点类似啊. 这里大龙也相当于给小光装饰上了新的职责(谈判negotiate): 123public void negotiate(int price) &#123; System.out.println(\"不接受, 要求降价\" + (price - 80));&#125; 那么代理模式相比与装饰模式有什么区别呢? 让我们再带上重点符来重温下二者: 代理模式旨在为一个对象提供一个代理, 来控制对这个对象的访问. 装饰模式旨在为一个对象动态添加职责, 增加这个对象的行为/属性. 二者虽然都会有代理类/装饰类实际调用被代理对象/被装饰对象的行为. 然而代理模式重在控制, 而装饰模式重在添加. 例如本例中, 大龙代理了小光的签单(signing)行为, 但不仅仅是像装饰模式那样, 加上某些行为/属性后就交给小光处理的. 大龙还加了控制: 1234567891011public void signing(int price) &#123; System.out.println(\"对方报价:\" + price); if (price &lt; 100) &#123; this.person.signing(price); &#125; // 如果对方报价大于等于100的时候, 大龙并没有让小光处理. else &#123; negotiate(price); &#125;&#125; 如果对方报价大于等于100的时候, 大龙并没有让小光处理. 也就是说大龙是有控制权的. 扩展阅读二上面说到大龙是有控制权的, 也就是说, 这种代理实际上是一种控制代理, 也可以称之为保护代理. 代理模式除了这种控制访问/保护性的, 常常用到的场景还有: 远程代理: 为一个在不同的地址空间的对象提供局部代表, 从而可以隐藏这个被代理对象存在于不同地址空间的事实. 这个代表有点类似于大使, 故而也可以称之为”大使模式”. 智能引用代理: 在代理中对被代理对象的每个操作做些额外操作, 例如记录每次被代理对象被引用, 被调用的次数等. 有点像引用计数的感觉. 扩展阅读三说到远程代理, 就有必要聊聊Android中著名的AIDL了. 熟悉AIDL的同学, 应该比较清晰了解了, AIDL就是一个典型的远程代理模式的运用. 创建一个简单的AIDL文件: 123456789101112// IRemoteService.aidlpackage com.anly.samples;// Declare any non-default types here with import statementsinterface IRemoteService &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void signing(int price);&#125; 生成的文件IRemoteService.java文件如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* * This file is auto-generated. DO NOT MODIFY. * Original file: /Users/mingjun/Dev/my_github/AndroidLessonSamples/app/src/main/aidl/com/anly/samples/IRemoteService.aidl */package com.anly.samples;// Declare any non-default types here with import statementspublic interface IRemoteService extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.anly.samples.IRemoteService &#123; private static final java.lang.String DESCRIPTOR = \"com.anly.samples.IRemoteService\"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.anly.samples.IRemoteService interface, * generating a proxy if needed. */ public static com.anly.samples.IRemoteService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.anly.samples.IRemoteService))) &#123; return ((com.anly.samples.IRemoteService) iin); &#125; return new com.anly.samples.IRemoteService.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_signing: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _result = this.signing(_arg0); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.anly.samples.IRemoteService &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public int signing(int price) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(price); mRemote.transact(Stub.TRANSACTION_signing, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; static final int TRANSACTION_signing = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); &#125; public int signing(int price) throws android.os.RemoteException;&#125; AIDL自动生成的java文件格式比较乱, 格式化了一下.有几个关键点: IRemoteService是一个接口, 有signing方法 IRemoteService中有一个静态抽象内部类Stub, 实现了IRemoteService接口.(集成了Binder再次就不讨论了) Stub中有一个asInterface方法, 返回一个IRemoteService, 实际上是Proxy. Stub中有一个私有的内部类Proxy. 这个内部类的机制是为了增加内聚, 一个AIDL生成的文件理论上是一个业务服务体系, 故而放在一起. 我们实现下Proxy和Stub, 然后用UML图来梳理下: 客户端AidlSampleActivity: 1234567891011121314// 绑定服务的ServiceConnection中获取Proxy:public void onServiceConnected(ComponentName name, IBinder service) &#123; mRemoteService = IRemoteService.Stub.asInterface(service); isBound = true; if (mRemoteService != null) &#123; try &#123; mCurrentPrice = mRemoteService.signing(mCurrentPrice); mResult.setText(\"Result:\" + mCurrentPrice); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 服务RemoteService继承Stub生成的IBinder: 12345678private IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; @Override public int signing(int price) throws RemoteException &#123; int signingPrice = price - 10; Log.d(\"mingjun\", \"signing: \" + signingPrice); return signingPrice; &#125;&#125;; 为了更清晰表达这是一个远程代理, 我们将RemoteService开辟在了其他进程中: 1&lt;service android:name=\".aidl.RemoteService\" android:process=\"com.anly.other\"/&gt; 本文不深入AIDL的应用和原理, 具体客户端(AidlSampleActivity)和服务(RemoteService)的代码就不贴了, 完整代码点这里. OK, 这就是我们今天要说的代理模式.有了代理模式, 尤其是远程代理, 小光发现有时候自己都可以不用亲临店了呢, 有了更多的时间出去考察新店地址了…哈哈.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"可乐要加冰才好喝啊---装饰模式","slug":"design-pattern/decorator","date":"2016-11-22T14:00:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/11/22/design-pattern/decorator/","link":"","permalink":"http://blog.lmj.wiki/2016/11/22/design-pattern/decorator/","excerpt":"前情提要上集讲到, 小光利用策略模式搞起了回馈顾客的活动. 还别说, 客流量增大不少. 然而, 随之而来的, 顾客的声音也不少: 可乐能不能加冰啊 绿豆汤加点糖呗 …… 众口难调嘛, 大家的需求不一, 有的要冰有的不要, 有的加糖有的不要… 小光带着客户的意见, 开始了饮品的改进之路.","text":"前情提要上集讲到, 小光利用策略模式搞起了回馈顾客的活动. 还别说, 客流量增大不少. 然而, 随之而来的, 顾客的声音也不少: 可乐能不能加冰啊 绿豆汤加点糖呗 …… 众口难调嘛, 大家的需求不一, 有的要冰有的不要, 有的加糖有的不要… 小光带着客户的意见, 开始了饮品的改进之路. 改进之路第一套方案很快, 小光想出了第一套的解决方案: 我把加冰和不加冰的的饮料看成是两种不同的饮料, 借助上次设计的工厂方法模式的饮料机, 可以很轻易的扩展实现用户不同需求, 而不修改原来的实现啊. 小光的第一套方案: 然而, 还没有投入使用呢, 小光就发现了问题: 我这不定期会从饮料商户那儿拿到一些不同的饮品, 每种都有可能要加冰, 加糖, 还可能加蜂蜜呢…那我不用干别的啦, 天天折腾这些饮料机就够够的啦. 装饰出场那么有什么更好的办法呢? 小光又陷入了冥想.这时, 表妹过来了, 兴高采烈的, 看到小光傻傻的样子, 问: “表哥, 你想啥呢, 看看我刚新买的头花好看不?”小光: “你怎么又换头花了啊?”表妹: “女孩子嘛, 当然要换着花样打扮装饰自己啊, 好不好看嘛?”“好看好看.” 小光敷衍答道. 突然, 小光像是想起了什么, 喃喃自语道, “打扮”, “装饰”, “对啊, 我也可以用冰啊, 糖啊, 蜂蜜什么的来装饰我的饮料啊.” 说做就做, 小光先从可乐入手: 良好的面向接口编程习惯, 小光抽象了一个饮料类Drink 1234public interface Drink &#123; String make();&#125; 实现一杯可乐: 123456public class Coke implements Drink &#123; @Override public String make() &#123; return \"这是一杯可乐\"; &#125;&#125; 加了冰块的饮料还应该是饮料, 故而, 冰块这个装饰也实现了Drink接口, 加冰这个装饰是在饮料的基础上的, 所以我们还持有了一个Drink对象: 123456789101112public class Ice implements Drink &#123; private Drink originalDrink; public Ice(Drink originalDrink) &#123; this.originalDrink = originalDrink; &#125; @Override public String make() &#123; return originalDrink.make() + \", 加一块冰\"; &#125;&#125; 来实验下: 1234567891011public class XiaoGuang &#123; public static void main(String[] args) &#123; Drink coke = new Coke(); System.out.println(coke.make()); Drink iceCoke = new Ice(new Coke()); System.out.println(iceCoke.make()); &#125;&#125; 结果: 12这是一杯可乐这是一杯可乐, 加一块冰 持续改进小光看到实验结果, 哈哈大笑, 实验成功, 且看我推广到所有饮料, 所有加料中. 小光想到, 加料可能是糖, 可能是冰, 还可能蜂蜜, 还有很多未知的, 为了满足开闭原则, 我还是先抽象一个配料出来吧: 1234567891011121314public abstract class Stuff implements Drink &#123; private Drink originalDrink; public Stuff(Drink originalDrink) &#123; this.originalDrink = originalDrink; &#125; @Override public String make() &#123; return originalDrink.make() + \", 加一份\" + stuffName(); &#125; abstract String stuffName();&#125; 冰块原料改为继承Stuff: 1234567891011public class Ice extends Stuff &#123; public Ice(Drink originalDrink) &#123; super(originalDrink); &#125; @Override String stuffName() &#123; return \"冰\"; &#125;&#125; 小光还据此增加了糖Sugar, 和蜂蜜Honey原料. 具体代码就不在此贴出来了, 全部代码在这里. 投入使用经过大量验证后, 小光将新的程序投入了使用, 现在是这样子的… “老板, 来一杯可乐, 加冰” 1234Drink iceCoke = new Ice(new Coke());System.out.println(iceCoke.make());这是一杯可乐, 加一份冰 “老板, X饮料, 加冰, 加糖” 1234Drink iceSugarXDrink = new Ice(new Sugar(new XDrink()));System.out.println(iceSugarXDrink.make());这是一杯X牌饮料, 加一份糖, 加一份冰 “可乐, 加两份冰, 加蜂蜜” 1234Drink doubleIceHoneyCoke = new Ice(new Ice(new Honey(new Coke())));System.out.println(doubleIceHoneyCoke.make()); 这是一杯可乐, 加一份蜂蜜, 加一份冰, 加一份冰 完美表现.小光再也不怕顾客们的各种奇怪的加料要求了. 故事之后照例, 故事之后, 我们用UML类图来梳理下上述的关系: 其中Stuff类中值得注意的两个关系: 我们的Stuff(料)也是实现了Drink接口的, 这是为了说明加了料(Stuff)的饮料还是饮料. Stuff中还聚合了一个Drink(originalDrink)实例, 是为了说明这个料是加到饮料中的. 对, 这个就是一个标准的装饰者模式的类图. 装饰者模式就是用来动态的给对象加上额外的职责.Drink是被装饰的对象, Stuff作为装饰类, 可以动态地给被装饰对象添加特征, 职责. 扩展阅读一有的同学可能会说, 我完全可以通过继承关系, 在子类中添加职责的方式给父类以扩展啊. 是的, 没错, 继承本就是为了扩展. 然而, 装饰者模式和子类继承扩展的最大区别在于: 装饰者模式强调的是动态的扩展, 而继承关系是静态的. 由于继承机制的静态性, 我们会为每个扩展职责创建一个子类, 例如IceCoke, DoubleIceCoke, SugarXDrink, IceSugarXDrink等等…会造成类爆炸. 另外, 这里引入一条新的面向对象编程原则:组合优于继承, 大家自行体会下. 扩展阅读二还有的同学说, 这种按需定制的方式貌似跟之前讲的Builder模式有点像啊, 那为什么不用Builder模式呢. 这里先说明下二者的本质差异: Builder模式是一种创建型的设计模式. 旨在解决对象的差异化构建的问题.装饰者模式是一种结构型的设计模式. 旨在处理对象和类的组合关系. 实际上在这个例子中, 我们是可以用Builder模式的, 但就像使用继承机制一样, 会有些问题.首先, Builder模式是构建对象, 那么实际上要求我们是必须事先了解有哪些属性/职责供选择. 这样我们才可以在构建对象时选择不同的Build方式. 也就是说: Builder模式的差异化构建是可预见的, 而装饰者模式实际上提供了一种不可预见的扩展组合关系. 例如, 如果用户要了一杯带蜂蜜的X饮料, 如果是Builder模式, 我们可能是这样的: 123XDrink xDrink = new XDrink.Builder() .withHoney() .build() 但是如果饮料拿出来后, 用户还想加冰怎么办呢? 这就是Builder模式在这种动态扩展情景下的局限. 看看装饰模式怎么做: 1234567891011// 加蜂蜜的X饮料Drink honeyXDrink = new Honey(new XDrink());System.out.println(honeyXDrink.make());这是一杯X牌饮料, 加一份蜂蜜// 还要加冰Drink iceHoneyXDrink = new Ice(honeyXDrink);System.out.println(iceHoneyXDrink.make());这是一杯X牌饮料, 加一份蜂蜜, 加一份冰 直接在honeyXDrink的基础上再装饰一份冰即可. 另外, 大家也都看到了, 由于我们的面向接口编程方式, 装饰者(冰块, 蜂蜜, 糖)可不是只能用来装饰特定的被装饰对象(诸如可乐), 它们可以被用来装饰所有种类的饮料(Drink)对象. 个中好处大家自行体会下. 扩展阅读三我们一直在说的, 装饰者模式是动态给对象加上额外的职责, 这个职责实际上包括修饰(属性), 也包括行为(方法). 例如我们上面讨论的例子, 就是单纯得给饮料加上了一些修饰, 是饮料编程了加冰的饮料, 加糖的饮料. 我们也可以给对象加上行为, 例如, 一部手机, 我们可以通过装饰模式给它加上红外遥控的功能, 还可以给他加上NFC支付的功能. Android中鼎鼎大名的Context体系, 实际上就是装饰模式的体现, 通过装饰模式来给Context扩展了一系列的功能. 如下: 还是比较清晰的, 典型的使用装饰者模式来扩展功能的实践, 相比于我们的例子, 更注重功能扩展, 体现了开闭原则. 再重申下, 面向对象编程是一种思想, 设计模式都是这些思想的具体实践和体现. 学习设计模式可以让我们更好的理解编程思想, 而非固定套用. 我们的目的是无招胜有招. 另外, 具体的环境中设计模式一般不是单一地用的, 往往是各种设计模式融合在一起的. 例如我们这个装饰者里面, 各种new对象, 实际上就可以用到我们学习的工厂方法的模式进行处理. 好了, 让我们充分发挥自己的想象力, 多弄些原料来装饰我们的饮料吧, 说不定我们能调出一种前所未有的饮品呢, 哈哈. 系列文在此: 小光的开店之路–设计模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"回馈顾客, 活动搞起---策略模式","slug":"design-pattern/strategy","date":"2016-11-21T14:00:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/11/21/design-pattern/strategy/","link":"","permalink":"http://blog.lmj.wiki/2016/11/21/design-pattern/strategy/","excerpt":"前情提要上集讲到, 小光引入了饮料机(工厂方法模式)改进了光氏饮品的生产过程. 现在如果要新上什么饮品, 改变配方什么的, 都很简单了, 直接增加一个饮料机, 或是替换/拿掉一个饮料机就可以了. 表妹再也不抱怨了. 小光也找了些饮料厂商拿到了一些试喝的饮料新品. 心想, 正好临近感恩节, 圣诞节, 双十二啥的, 我可以拿这些饮料新品来做些活动啊, 感恩下新老顾客啊… 这些新品小光可是自己亲身试喝过的, 绝对好喝, 小光不做奸商, :)","text":"前情提要上集讲到, 小光引入了饮料机(工厂方法模式)改进了光氏饮品的生产过程. 现在如果要新上什么饮品, 改变配方什么的, 都很简单了, 直接增加一个饮料机, 或是替换/拿掉一个饮料机就可以了. 表妹再也不抱怨了. 小光也找了些饮料厂商拿到了一些试喝的饮料新品. 心想, 正好临近感恩节, 圣诞节, 双十二啥的, 我可以拿这些饮料新品来做些活动啊, 感恩下新老顾客啊… 这些新品小光可是自己亲身试喝过的, 绝对好喝, 小光不做奸商, :) 所有示例源码已经上传到Github, 戳这里 活动策划小光以其独特的码农生意人思维(我也不知道这是什么…), 很快想出了几条活动方案: 即日起, 到感恩节(11/24)那天, 所有饮品6折优惠. 双十二当天, 满12立减2元. 12月20号到圣诞节(12/25), 买热干面+饮料套餐送大苹果. 小光想出这些活动方案后, 屁颠屁颠去拿给表妹看. 没曾想, 表妹一脸不愉快, 这么多方案, 还这么负责, 我怎么记得住…(单细胞的表妹). 怎么办了, 小光可不想放弃自己好不容易想出的这些方案, 而且活动方案肯定会因为是不同节日而有所改变嘛. 解决之道很快, 小光就想到了解决办法, 他将三种活动方案的算法做好, 内置在收银台. 在不同的日子里选用不用的算法策略. “我真是个天才, 哈哈哈哈”, 小光想着都快笑出声了… 照例, 收银员无需关注是什么具体的算法, 故而抽象出一个父级接口: 1234public interface ActivityStrategy &#123; String getActivityPrice();&#125; 每个方案对应一个算法策略: 1234567891011121314151617181920212223242526272829303132333435363738// 感恩节活动算法public class ThanksGivingDayStrategy implements ActivityStrategy &#123; @Override public String getActivityPrice() &#123; // 经过一系列算法 return \"(感恩节)所有饮品一律5折\"; &#125;&#125;// 双十二算法public class DoubleTwelveDayStrategy implements ActivityStrategy &#123; @Override public String getActivityPrice() &#123; // 经过一系列算法 return \"(双十二)满12立减2元\"; &#125;&#125;// 圣诞节算法public class ChristmasStrategy implements ActivityStrategy &#123; @Override public String getActivityPrice() &#123; // 经过一系列算法 return \"(圣诞节)买热干面+饮品套餐, 送大苹果一个\"; &#125;&#125;// 默认算法(注意这个, 稍后的扩展阅读会说下这个Default实现的意义)public class DefaultActivityStrategy implements ActivityStrategy &#123; @Override public String getActivityPrice() &#123; // 什么都不做 return \"没有活动\"; &#125;&#125; 支持各种活动策略算法的收银台: 123456789101112131415161718192021// 收银台public class Checkstand &#123; private ActivityStrategy mActivityStrategy; public Checkstand() &#123; mActivityStrategy = new DefaultActivityStrategy(); &#125; public Checkstand(ActivityStrategy activityStrategy) &#123; this.mActivityStrategy = activityStrategy; &#125; public void setActivityStrategy(ActivityStrategy activityStrategy) &#123; this.mActivityStrategy = activityStrategy; &#125; public void printBill() &#123; System.out.println(\"本次账单活动:\" + mActivityStrategy.getActivityPrice()); &#125;&#125; 投入使用活动方案算法和收银台完工之后, 小光立马投入了使用: 123456789101112131415161718192021public class XiaoGuang &#123; public static void main(String[] args) &#123; // 收银台, 默认 Checkstand checkstand = new Checkstand(); checkstand.printBill(); // 感恩节期间 checkstand.setActivityStrategy(new ThanksGivingDayStrategy()); checkstand.printBill(); // 双十二 checkstand.setActivityStrategy(new DoubleTwelveDayStrategy()); checkstand.printBill(); // 圣诞节期间 checkstand.setActivityStrategy(new ChristmasStrategy()); checkstand.printBill(); &#125;&#125; 结果, 也正如小光预料的: 1234本次账单活动:没有活动本次账单活动:(感恩节)所有饮品一律5折本次账单活动:(双十二)满12立减2元本次账单活动:(圣诞节)买热干面+饮品套餐, 送大苹果一个 活动一经推出, 顾客果然是比以前更多了…大家还对小光新推出的那些试喝饮料赞不绝口, 都觉得味道不错, 还很着很有意思的名字… 故事之后照例, 故事之后, 我们用UML类图来梳理下上述的关系(关注收银台与活动策略算法之间的关系): 大家可能已经看出端倪了, 没错, 这就是策略模式. 策略模式(Strategy Pattern):定义一组算法, 并将每一个单独算法封装起来, 让它们可以相互替换. 策略模式让算法独立于使用它的客户而变化, 例如如果明年小光的双十二活动改变了, 只需单独修改这个DoubleTwelveDayStrategy即可, 客户类(收银台Checkstand)无需改变, 也无需关注每个算法的具体实现. 扩展阅读一实际上策略模式也还是利用抽象, 封装, 继承, 多态的面向对象特性, 来达到封装变化, 解耦合的. 典型的开闭原则的实践. 另外, 眼尖的同学可能看到, 貌似这个类图似曾相识啊. 前面讲的简单工厂和工厂方法中的类图与此极其相似: 比较上图三个模式的红框部分, 我们可以发现, 相当一致. 在此明确下三者的关系与区别: 首先简单工厂和工厂方法是创建型的模式, 而策略模式是行为型的模式. 所谓创建型就是说用来生产对象的, 注重的生产(new)这个部分, 用创建型的模式来代替直接new一个实例, 更多是想将直接的实例依赖通过不同的方法转化接口依赖. 所谓行为型模式更多是描述一种行为, A使用B, 怎么使用的这个关系上. 实际上, 在上个工厂方法的故事中, 我们就已经使用到了策略模式. 表妹选择不同的饮料机来那饮料, 这个行为实际上就是一个策略模式的体现, 回顾下表妹的代码: 1234567891011121314151617181920212223242526272829303132public class Cousins &#123; private IBeverageMachine mBeverageMachine; private void setBeverageMachine(IBeverageMachine machine) &#123; this.mBeverageMachine = machine; &#125; private Drink takeDrink() &#123; if (mBeverageMachine == null) throw new NullPointerException(\"Should set Beverage Machine firstly.\"); return mBeverageMachine.makeDrink(); &#125; public static void main(String[] args) &#123; Cousins cousins = new Cousins(); // for A cousins.setBeverageMachine(new OrangeJuiceMachine()); Drink drink = cousins.takeDrink(); System.out.println(drink); // for B cousins.setBeverageMachine(new CokeMachine()); System.out.println(cousins.takeDrink()); // for D cousins.setBeverageMachine(new MilkTeaMachine()); System.out.println(cousins.takeDrink()); &#125;&#125; 和我们这个收银台(Checkstand)是一样一样的, 上例中的模式使用实际可以理解成是这样: 蓝色部分是工厂方法模式的使用, 作用在于生产出不同的饮品. 红色部分是策略模式的使用, 作用在于让表妹根据实际情况选择不同的饮料机. 所以说模式的运用, 往往不是简单而单一, 很多时候是很多模式合在一起的. 扩展阅读二在展示本例策略模式的UML类图时, 我们将DefaultActivityStrategy类标记成红色了, 这是为什么呢? 是因为这里我们用的这个DefaultActivityStrategy实际上也是一种设计模式的体现. 这个模式不在GoF的23中设计模式内, 但是绝对是一个很常用, 很实用的模式 — 空对象模式. 空对象模式（Null Object Pattern):用一个空(什么都不做的)对象来代替NULL. 空对象模式是一个很简单的设计模式, 也可以看成是一种编码习惯. 它小但是作用大: 使用空对象模式可以减少很多我们对于对象是否为空的判断. 例如本例中, 如果Checkstand的无参构造函数我们没有new一个空对象, 那么后续的对于Checkstand实例各种调用我们可能就需要判断其mActivityStrategy是否为空. 如果遗漏, 很有可能导致null pointer异常. 另外对于一些可以链式调用的对象, 如果我们要每次都判断是否为空会很影响我们的链式调用. 空对象模式经常会用来作为策略模式算法族中的一个, 来提供空策略. 扩展阅读三策略模式由于其优秀的对外扩展性和对内封装性, 在一些SDK或是优秀开源库中会经常用到. 还是以Glide为例, 其图片的磁盘缓存就使用了策略模式, 并提供了很多策略供用户选择: 优秀源码总是设计巧妙但又易懂不晦涩. 活动搞起了, 小光热干面欢迎大家常来光临啊, 喜欢您就收藏, 喜欢您就关注…","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"光氏饮品升级了---工厂方法模式","slug":"design-pattern/factory_method","date":"2016-11-16T14:00:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/11/16/design-pattern/factory_method/","link":"","permalink":"http://blog.lmj.wiki/2016/11/16/design-pattern/factory_method/","excerpt":"前情提要上集讲到, 小光的热干面店, 开始搭配提供饮料了. 再加上美女表妹的助阵, 生意是红红火火啊. 然而, 事情也不是尽善尽美的, 慢慢小光就听到了一些的客户的声音: 酸梅汤太酸了, 能调好点吗? 天冷了能来点热饮吗? 客户可是上帝啊, 小光立马就着手改进.","text":"前情提要上集讲到, 小光的热干面店, 开始搭配提供饮料了. 再加上美女表妹的助阵, 生意是红红火火啊. 然而, 事情也不是尽善尽美的, 慢慢小光就听到了一些的客户的声音: 酸梅汤太酸了, 能调好点吗? 天冷了能来点热饮吗? 客户可是上帝啊, 小光立马就着手改进. 所有示例源码已经上传到Github, 戳这里 表妹的抱怨带着客户的声音, 小光找表妹聊了下, 想让表妹修改下当前的酸梅汤泡制比例, 另外再增加一些热饮的泡制. 没想到, 表妹一听到着就很反对: “我现在已经记得太多了, 你这么不定时的修改, 增加, 我更容易记混, 到时候更出问题了”. (职责太重) 小光一想, 是啊, 我把自己从做热干面添加各种配料的烦恼中释放出来了(通过Builder模式). 不能让表妹也陷入这样的烦恼啊. 解决之路可是怎么才能更好的解决这个问题呢?要是我有很多个表妹就好了, 每个表妹负责一种饮料的泡制, 小光想着. 嗯~, 很多个表妹?! 小光微微一笑, 计上心头. 小光买来很多个迷你饮水机, 一个装一种饮料, 并且贴上相应的标签, 如此这般: 每个迷你饮水机作为一个饮料机, 用来生产不同的饮料. 表妹只有根据用户的需求选择不同的饮料机打出饮料即可. 这样, 表妹也无需关注饮料的生产过程了, 不用记那么多的饮料配置方式了. 如果想要新增饮品, 再弄一台饮料机就行了. 来看看对应关系这是没有标签的饮水机(饮料机): 1234public interface IBeverageMachine &#123; Drink makeDrink();&#125; 这是贴了不同饮料类型的饮料机: 1234567891011121314151617181920public class OrangeJuiceMachine implements IBeverageMachine &#123; @Override public Drink makeDrink() &#123; return new OrangeJuice().make(); &#125;&#125;public class CokeMachine implements IBeverageMachine &#123; @Override public Drink makeDrink() &#123; return new Coke().make(); &#125;&#125;public class PlumJuiceMachine implements IBeverageMachine &#123; @Override public Drink makeDrink() &#123; return new PlumJuice().make(); &#125;&#125; 这是那些饮料(还是有一个抽象继承关系): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class Drink &#123; private String name; private String instantPackage; public Drink make() &#123; this.name = getName(); this.instantPackage = getInstantPackage(); return this; &#125; abstract String getInstantPackage(); abstract String getName(); @Override public String toString() &#123; return \"This is a cup of:\" + this.name; &#125;&#125;public class Coke extends Drink &#123; @Override String getInstantPackage() &#123; return \"速溶可乐粉\"; &#125; @Override String getName() &#123; return \"可乐\"; &#125;&#125;public class OrangeJuice extends Drink &#123; @Override String getInstantPackage() &#123; return \"速溶橙汁粉\"; &#125; @Override String getName() &#123; return \"橙汁\"; &#125;&#125;public class PlumJuice extends Drink &#123; @Override String getInstantPackage() &#123; return \"速溶酸梅粉\"; &#125; @Override String getName() &#123; return \"酸梅汤\"; &#125;&#125; 相比上一篇简单工厂中的饮料, 我们将打包这个操作从饮料这个对象中移除了, 目前的饮料对象中只是一些简单的属性.为什么要这么做呢? 大家可以用自己面向对象编程思想的脑洞自由发挥下, 下期说说我的想法. 现在表妹的工作就变得简单了: 12345678910111213141516171819202122232425262728public class Cousins &#123; private IBeverageMachine mBeverageMachine; private void setBeverageMachine(IBeverageMachine machine) &#123; this.mBeverageMachine = machine; &#125; private Drink takeDrink() &#123; if (mBeverageMachine == null) throw new NullPointerException(\"Should set Beverage Machine firstly.\"); return mBeverageMachine.makeDrink(); &#125; public static void main(String[] args) &#123; Cousins cousins = new Cousins(); // for A cousins.setBeverageMachine(new OrangeJuiceMachine()); Drink drink = cousins.takeDrink(); System.out.println(drink); // for B cousins.setBeverageMachine(new CokeMachine()); System.out.println(cousins.takeDrink()); &#125;&#125; 当A要橙汁时, 表妹去OrangeJuiceMachine装一杯, 当B需要可乐时, 表妹再去CokeMachine拿: 12This is a cup of:橙汁This is a cup of:可乐 表妹的工作变得更简单了, 工作效率也更高了, 也更能微笑面对顾客了, 哈哈… 想要奶茶的C顾客这天, 来了一位顾客D, 问: “老板, 有没有热奶茶啊?”. 考验小光的程序的时候到了. 很快, 小光copy出了一个奶茶机(扩展开放), 同时也无需修改原来的那些个饮料机程序(修改关闭), 不会因此而耽误生意. 新增奶茶饮料: 12345678910111213141516171819202122public class MilkTea extends Drink &#123; @Override String getInstantPackage() &#123; return \"速溶奶茶粉\"; &#125; @Override String getName() &#123; return \"奶茶\"; &#125;&#125;```` **奶茶机:**````javapublic class MilkTeaMachine implements IBeverageMachine &#123; @Override public Drink makeDrink() &#123; return new MilkTea().make(); &#125;&#125; 现在的台面: 表妹的工作也很简单, 去奶茶机那儿接奶茶就是了: 123// for Dcousins.setBeverageMachine(new MilkTeaMachine());System.out.println(cousins.takeDrink()); D拿到的: 1This is a cup of:奶茶 故事之后照例, 我们先来画出现在的类对应关系: 实际上这个就是工厂方法模式. 几个点:1, 为何叫工厂方法, 是因为每个工厂有一个方法来创建产品.2, 每个产品对应一个工厂实例来生产这个产品实例.3, 因为产品和其对应的工厂都与其他产品分离, 我们可以很轻易的去增加新的产品和其对应的工厂, 而不改变原来的结构. (开闭原则, 实际上还蕴含了职责单一) 扩展阅读工厂方法模式如同Buidler模式, 是一些开源库中非常常见的用来创建实例的设计模式. 例如OkHttp中ModelLoader相关的实现: 看对应关系就跟清晰了, 就不一一类比了. 小光看着这一排饮料机, 成就感悠然而生, 仿佛又回到了那个彻夜编码的岁月.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"小光热干面提供饮料了---简单工厂","slug":"design-pattern/simple_factory","date":"2016-11-14T15:00:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/11/14/design-pattern/simple_factory/","link":"","permalink":"http://blog.lmj.wiki/2016/11/14/design-pattern/simple_factory/","excerpt":"前情提要 本意是想像美剧的previously那样, 不知道怎么翻译好, 求翻译达人赐教… 上集讲到, 小光辞了工作, 开起了热干面的店子, 用Builder模式改造了热干面的构建过程, 是日渐稳定有效起来, 生意也是越来越好. 但是小光是善于观察的同学啊, 他发现热干面真的好干啊(好像一般人也都能发现, 鬼脸~). 心想, 解决用户痛点才产品的存在根本啊, 是时候推出新东西了. 于是他决定跟推出自己的光氏饮料产品.","text":"前情提要 本意是想像美剧的previously那样, 不知道怎么翻译好, 求翻译达人赐教… 上集讲到, 小光辞了工作, 开起了热干面的店子, 用Builder模式改造了热干面的构建过程, 是日渐稳定有效起来, 生意也是越来越好. 但是小光是善于观察的同学啊, 他发现热干面真的好干啊(好像一般人也都能发现, 鬼脸~). 心想, 解决用户痛点才产品的存在根本啊, 是时候推出新东西了. 于是他决定跟推出自己的光氏饮料产品. 饮料的制作经过一番调查和走访, 小光发现几个特点: 大家对这个饮料要求不高(码农的屌丝特性啊) , 解渴为主. 因为赶着上班, 一般要求要快, 最好可以直接拿走. 品种要丰富, 大家口味不一啊. 于是, 小光选用了最新的XX牌 (有广告商找我吗? 哈哈.) 速溶饮料. 制作饮料的过程很简单, 很快, 小光做出了第一杯饮料—橙汁: 12345678910111213141516public class OrangeJuice &#123; public void make() &#123; // 1. 拿出一次性饮料杯 System.out.println(\"拿出一次性饮料杯\"); // 2. 加入速溶橙汁粉 System.out.println(\"加入速溶橙汁粉\"); // 3. 加水冲兑 System.out.println(\"加水\"); // 4. 加盖, 打包 System.out.println(\"加盖, 打包\"); &#125;&#125; 小光的思考看起来, 程序似乎是可以运转了, 让我们投入生产吧…然而, 小光何许人啊, 毕竟是在码农界混了好些年的同志啊. 还没有投入使用, 就发现了”问题”: 饮料有很多种, 过程都类似, 只是放的速溶包不一样. 如果我每个都这么写, 改天真有人找我打广告, 杯子上印个二维码什么的, 我不是每个饮料的制作过程都要改啊 灵光一现, 小光想起了面向对象思想中提到的抽象, 封装, 于是乎, 小光改写了自己的程序: 他抽象出来一个”Drink”类: 123456789101112131415161718public abstract class Drink &#123; public void make() &#123; // 1. 拿出一次性饮料杯 System.out.println(\"拿出一次性饮料杯\"); // 2. 加入速溶橙汁粉 System.out.println(\"加入\" + getInstantPackage()); // 3. 加水冲兑 System.out.println(\"加水\"); // 4. 加盖, 打包 System.out.println(\"加盖, 打包\"); &#125; abstract String getInstantPackage();&#125; 可乐, 酸梅汤, 橙汁皆继承了Drink: 1234567891011121314151617181920public class Coke extends Drink &#123; @Override String getInstantPackage() &#123; return \"速溶可乐粉\"; &#125;&#125;public class PlumJuice extends Drink &#123; @Override String getInstantPackage() &#123; return \"速溶酸梅粉\"; &#125;&#125;public class OrangeJuice extends Drink &#123; @Override String getInstantPackage() &#123; return \"速溶橙汁粉\"; &#125;&#125; 开卖制作完饮料, 准备开卖了, 是这样的: 12345678public class XiaoGuang &#123; public static void main(String[] args) &#123; OrangeJuice orangeJuice = new OrangeJuice(); orangeJuice.make(); &#125;&#125; 第二天, 生意实在太好, 小光请了表妹临时来帮忙泡制饮料. 而且, 小光还发现自己也无需关注用户要什么饮料了, 直接让用户告诉表妹, 表妹直接制作饮料给用户就行~ 表妹负责根据用户要求生产饮料: 1234567891011121314151617181920public class Cousins &#123; public static Drink create(String drinkType) &#123; // Java7开始, switch支持String switch (drinkType) &#123; case \"橙汁\": return new OrangeJuice(); case \"酸梅汤\": return new PlumJuice(); case \"可乐\": return new Coke(); default: return new OrangeJuice(); &#125; &#125;&#125; 小光不再关注饮料具体种类: 12345678public class XiaoGuang &#123; public static void main(String[] args) &#123; Drink drink = Cousins.create(\"可乐\"); drink.make(); &#125;&#125; 加上饮料套餐之后, 生意果然越来越好, 估计也有美女助阵的加成, 哈哈… 故事之后可能有些同学已经看出一点熟悉感了, 我们把这些关系一个UML表示下: 如此, 应该就比较清晰了, 这个就是我们今天的主题—简单工厂. 严格来说, 简单工厂并非一种设计模式, 可以说是一种编码习惯. 那么我们为什么要使用简单工厂, 或者说这么做有什么好处呢? 从我们这个例子中, 可以看到, 小光(Client类)不需要去关注饮料泡制(Drink make)这个过程了, 有更多的时间去接待客户, 只需从表妹(工厂类)那拿到相应的饮料给客户即可. 这个其实是蕴含了单一职责的编程思想: 小光的职责是接待客户 表妹的职责是泡制饮料 简单工厂一般来说, 使用一个静态方法来生产产品, 故而有时也称之为静态工厂方法模式. 扩展阅读在这个故事的过程中, 我们提到了面向对象的抽象, 封装特性. 实际上我们所有的OOD原则, 设计模式, 都是基于面向对象的思想的, 离不开抽象, 封装, 继承, 多态几大特性. 随着对这些设计模式的分析, 也可以让我们加深面向对象的编程思想. 以Glide为例, 其中的DefaultConnectivityMonitorFactory.java就是一个类似的简单工厂实现: 123456789101112131415public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory &#123; @NonNull public ConnectivityMonitor build( @NonNull Context context, @NonNull ConnectivityMonitor.ConnectivityListener listener) &#123; final int res = context.checkCallingOrSelfPermission(\"android.permission.ACCESS_NETWORK_STATE\"); final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED; if (hasPermission) &#123; return new DefaultConnectivityMonitor(context, listener); &#125; else &#123; return new NullConnectivityMonitor(); &#125; &#125;&#125; 与表妹Cousins(工厂)的实现很类似, 只是这个Factory具体创建什么产品不是由传入的参数决定的, 是在内部的逻辑决定的. 转化为类图关系, 更加清晰: 一直在说的话: 所谓架构, 设计模式都是一种思想, 没有固定的招式, 所有的这些招式都是让我们入门, 了解面向对象的基础思想, 然后能运用无形. 共勉. 留个尾子大家可能有发现, 简单工厂的弊端也是很多的, 表妹(工厂)的责任太重, 包含(UML依赖关系)了所有的具体产品的实现. 另外, 如果需要修改或增加产品, 我们就得改变工厂类的实现. 这显然违反了开闭原则. 故而, 简单工厂, 一般来说, 适用于产品类别较少, 且固定的场景.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"卖热干面的启发---Builder模式","slug":"design-pattern/builder","date":"2016-11-13T15:25:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/11/13/design-pattern/builder/","link":"","permalink":"http://blog.lmj.wiki/2016/11/13/design-pattern/builder/","excerpt":"看个故事互联网寒冬来袭, 小光越来越觉得码农这个行当不太好混了. 年关将至, 思乡之情也是倍切. 心底一横, 要不直接回老家做点小买卖得了~ 说做就做, 小光辞了工作, 回到老家武汉, 做起了卖热干面的行当.小光秉着科学开店, 合理经营的心思, 走访老店, 探索人流, 最终把店开在了软件园旁边.","text":"看个故事互联网寒冬来袭, 小光越来越觉得码农这个行当不太好混了. 年关将至, 思乡之情也是倍切. 心底一横, 要不直接回老家做点小买卖得了~ 说做就做, 小光辞了工作, 回到老家武汉, 做起了卖热干面的行当.小光秉着科学开店, 合理经营的心思, 走访老店, 探索人流, 最终把店开在了软件园旁边. 经过仔细他发现, 每个人点热干面时, 要的配料还各不相同, 有的要葱花, 有的不要葱花要香菜, 有的不要辣, 有的要加酸菜……小光心想, 这可难不倒我, 你要什么不要什么一次性告诉我, 不就得了. 很快, 热干面程序出炉: 1234567891011121314151617181920212223242526272829303132333435363738public class HotDryNoodles &#123; private boolean addShallot; private boolean addParsley; private boolean addChili; private boolean addSauerkraut; public HotDryNoodles(boolean shallot, boolean parsley, boolean chili, boolean sauerkraut) &#123; this.addShallot = shallot; this.addParsley = parsley; this.addChili = chili; this.addSauerkraut = sauerkraut; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(\"A bowl of hot-dry noodles has:\"); if (this.addShallot) &#123; builder.append(\"葱花.\"); &#125; if (this.addParsley) &#123; builder.append(\"香菜.\"); &#125; if (this.addChili) &#123; builder.append(\"辣椒.\"); &#125; if (this.addSauerkraut) &#123; builder.append(\"酸菜.\"); &#125; return builder.toString(); &#125;&#125; 注意: 构造函数的参数是有顺序的(葱花.香菜.辣椒.酸菜). 你还别说, 大武汉的码农们还真挺爱吃热干面, 一会生意就上门了: A: 老板, 热干面一份, 加葱, 加香菜, 放点酸菜.B: 老板, 热干面, 加葱, 放点酸菜. 小光, 一声”好嘞”, 立马开工: 12345678910111213public class XiaoGuang &#123; public static void main(String[] args) &#123; // A HotDryNoodles noodlesA = new HotDryNoodles(true, true, false, true); System.out.println(\"Customer A wants: \" + noodlesA); // B HotDryNoodles noodlesB = new HotDryNoodles(true, false, false, true); System.out.println(\"Customer B wants: \" + noodlesB); &#125;&#125; 很快出炉: 12Customer A wants: A bowl of hot-dry noodles has:葱花.香菜.酸菜.Customer B wants: A bowl of hot-dry noodles has:葱花.酸菜. 完美~ 这时, 来了一哥们儿: 老板, 一碗热干面, 加辣椒, 不放葱.小光吭哧吭哧忙活上了, 结果一端出来, 人哥们儿不乐意了, 怎么就放葱了啊, 还没有放辣椒~~原来是小光搞错了顺序(参数顺序)~ (也怪这哥们不按套路出牌啊) 没有办法, 重做一份咯~ (为了用户体验) 收摊之后, 小光是痛定思痛啊, 现在的工序的确很容易出问题啊: 目前的(参数)顺序是固定的, 客户要求各异, 根本不按套路来, 就很容易出错. 目前的(参数)个数是固定的, 大多数客户都选择默认, 只额外提一两个要求. 小光思考着怎么改进, 突然灵光一现: 这个不就是构建对象时有大量可选参数的问题吗?我可以使用Builder模式来解决这个问题啊. 原来编程无处不在, 小光暗思. 然后就开始动手改造工序了: 他买了张桌子, 用来作为配料台(Builder) 把配料(葱花.香菜.辣椒.酸菜)从他的热干面(HotDryNoodlesWithBuilder)构造中移到配料台放着了. 让客户自己选择添加什么配料, 自己从配料台上选择添加. 那么, 添加配料的过程编程自取了: 如此一来, 他不仅仅释放了自己的劳动力, 也不用费力去记客户到底要哪些不要哪些的, 把基本的面做好, 放在调料台, 让用户自己添加吧~~ 改造后的热干面工序: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class HotDryNoodlesWithBuilder &#123; private boolean addShallot; private boolean addParsley; private boolean addChili; private boolean addSauerkraut; public HotDryNoodlesWithBuilder(Builder builder) &#123; this.addShallot = builder.addShallot; this.addParsley = builder.addParsley; this.addChili = builder.addChili; this.addSauerkraut = builder.addSauerkraut; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(\"A bowl of hot-dry noodles has:\"); if (this.addShallot) &#123; builder.append(\"葱花.\"); &#125; if (this.addParsley) &#123; builder.append(\"香菜.\"); &#125; if (this.addChili) &#123; builder.append(\"辣椒.\"); &#125; if (this.addSauerkraut) &#123; builder.append(\"酸菜.\"); &#125; return builder.toString(); &#125; public static class Builder &#123; private boolean addShallot; private boolean addParsley; private boolean addChili; private boolean addSauerkraut; public Builder() &#123; &#125; public Builder withShallot() &#123; this.addShallot = true; return this; &#125; public Builder withParsley() &#123; this.addParsley = true; return this; &#125; public Builder withChili() &#123; this.addChili = true; return this; &#125; public Builder withSauerkraut() &#123; this.addSauerkraut = true; return this; &#125; public HotDryNoodlesWithBuilder build() &#123; return new HotDryNoodlesWithBuilder(this); &#125; &#125;&#125; 来看看用户怎么用的: 1234567891011121314151617181920public class XiaoGuang &#123; public static void main(String[] args) &#123; // with builder HotDryNoodlesWithBuilder noodlesC = new HotDryNoodlesWithBuilder.Builder() .withChili() .withParsley() .build(); System.out.println(\"Customer C wants: \" + noodlesC); HotDryNoodlesWithBuilder noodlesD = new HotDryNoodlesWithBuilder.Builder() .withChili() .withParsley() .withSauerkraut() .withShallot() .build(); System.out.println(\"Customer D wants: \" + noodlesD); &#125;&#125; 结果不能太满意: 12Customer C wants: A bowl of hot-dry noodles has:香菜.辣椒.Customer D wants: A bowl of hot-dry noodles has:葱花.香菜.辣椒.酸菜. 再也没有用户抱怨说小光搞错了, 想要什么自己加, 顺序也无所谓了. 小光也有更多的时间服务更多的客户了…看着来来往往的吃客, 小光憧憬着: 眼看就可以开分店, 连锁店, 上市, 当董事长, 迎娶白富美, 走上人生巅峰了, 哈哈哈哈哈. 故事之后让我们重温下GoF设计模式中的Builder模式: Buidler模式, 是一种创建型的设计模式.通常用来将一个复杂的对象的构造过程分离, 让使用者可以根据需要选择创建过程.另外, 当这个复杂的对象的构造包含很多可选参数时, 那Builder模式可以说是不二之选了. 从这个故事中, 我们可以看到, 当热干面的配料参数太多时, 我们很难去控制, 一旦弄错了参数顺序, 客户就无法接受~ 再来看下本故事中改造后的工序对应Builder模式的关系: 一般来说, Builder常常作为实际产品的静态内部类来实现(提高内聚性).故而Product,Director, Builder常常是在一个类文件中, 例如本例中的HotDryNoodlesWithBuilder.java.这里为了更好的对应Builder模式的类图关系, 将HotDryNoodlesWithBuilder画了两个~. 扩展阅读作为Java/Android开发者, 如果你想设计一个通用的库, Builder模式几乎肯定是会用到的, 我们需要提供良好的入口/接口来使用者可以弹性地构造他们需要的对象. 像一些优秀的开源库, 例如Glide, OkHttp等都在构造Glide, OkHttpClient时用到Builder模式, 例如OkHttpClient的创建, 如下节选OkHttpClient.java的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class OkHttpClient implements Cloneable, Call.Factory &#123; public OkHttpClient() &#123; this(new Builder()); &#125; private OkHttpClient(Builder builder) &#123; this.dispatcher = builder.dispatcher; this.proxy = builder.proxy; this.protocols = builder.protocols; this.connectionSpecs = builder.connectionSpecs; this.interceptors = Util.immutableList(builder.interceptors); this.networkInterceptors = Util.immutableList(builder.networkInterceptors); this.proxySelector = builder.proxySelector; this.cookieJar = builder.cookieJar; this.cache = builder.cache; this.internalCache = builder.internalCache; this.socketFactory = builder.socketFactory; // more code... &#125; public static final class Builder &#123; public Builder() &#123; ... &#125; public Builder cache(Cache cache) &#123; ... &#125; public Builder dispatcher(Dispatcher dispatcher) &#123; ... &#125; public Builder protocols(List&lt;Protocol&gt; protocols) &#123; ... &#125; public List&lt;Interceptor&gt; networkInterceptors() &#123; ... &#125; public Builder addNetworkInterceptor(Interceptor interceptor) &#123; ... &#125; public OkHttpClient build() &#123; return new OkHttpClient(this); &#125; &#125;&#125; 是不是和小光设计的HotDryNoodlesWithBuilder很像… 生活还将继续, 小光继续奋斗着, 憧憬自己的人生巅峰梦~","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/tags/设计模式/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.lmj.wiki/categories/设计模式/"}]},{"title":"App性能优化系列结语篇","slug":"app-opti/app_opt_summary","date":"2016-11-06T15:10:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/11/06/app-opti/app_opt_summary/","link":"","permalink":"http://blog.lmj.wiki/2016/11/06/app-opti/app_opt_summary/","excerpt":"关于Android App的优化, 从第一篇的计划开始, 到内存优化的系列文结束, 不知不觉近三个月的时间, 写了十五六篇相关的博文, 算是对自己的知识的一个系统化, 也希望能给大家一些帮助. 在此有对此做一个总结.","text":"关于Android App的优化, 从第一篇的计划开始, 到内存优化的系列文结束, 不知不觉近三个月的时间, 写了十五六篇相关的博文, 算是对自己的知识的一个系统化, 也希望能给大家一些帮助. 在此有对此做一个总结. 路线 1, App性能优化要怎么做在系列的开篇文中, 我们聊到了本系列的一个缘由, 和当时的一个计划, 系列也基本是朝着这个这个方向走的. 2, 性能分析工具在此介绍了一些惯用的性能分析工具, 包括官方, 第三方的, 内存分析的, UI分析的, 执行时间性能分析等等. 关于工具的使用, 还有一篇番外篇–adb的使用 3, App启动速度优化第一篇真正动手的优化项目, App的启动速度优化. 这里实际上有一个小系列, 为了将问题说得更清楚, 加入了一篇系列之外的译文–Application的启动流程分析, 然后是启动速度优化的理论和实例挑战. 4, Layout怎么摆介绍了Layout分析的工具, 并以实例说明了其使用. 提出了一些关于Layout优化的建议. 5, ANR详解从ANR的概念, ANR的产生原因, 如何避免ANR这几个角度来”剖析”了下ANR. 提供了如何分析ANR的方法, 并深入分析了ANR的集中产生原因和其解决之道. 6, 消除卡顿讲解了卡顿的产生原因, 并引入工具实例分析如何避免卡顿. 7, 内存优化这是一个大的子集, 分成了五篇来写, 分别包括: 7.1 垃圾回收的基础知识—GC那些事儿简单解析了GC的机制, 旨在让大家对于垃圾回收有一个理论理论基础, 对于GC Roots, 活对象, 死对象等有个概念. 7.2 Android是如何管理App内存的以Android的VM为基础, 说明了Android App的内存限制, App切换时的内存管理机制, 进程优先级等. 7.3 内存分析工具详解介绍了一系列内存分析工具的使用. 7.4 以一个内存泄露代码为例讲解内存问题分析的过程基于上篇的内存分析工具, 对一个内存泄露的实例代码进行分析, 找出内存泄露的原因. 这么一个过程, 实际上也是对于前面理论基础, 工具使用的一个实践. 7.5 内存使用小结算是对内存优化系列的一个小结, 对于常见的内存泄露机器解决方案, 内存使用等有一个概览. 着重对于内存泄露的分析和解决有一个说明. 8, 电量省着用电量使用优化是一个不太被关注的优化, 还是以工具入手, 介绍电量使用的分析方式, 并给出常见的耗电项极其优化方案. 9, 高效网络请求从网络流量对用户的影响切入, 介绍了App网络的分析, 各方面网络优化的方案等. 对于网络缓存的使用, 引用了MVP架构Github客户端之网络缓存篇. 说明如系列开篇中所言, 本系列可以算是一个基于实际线上App的性能优化的笔记. 并非App优化, 就算是单说性能优化, 此系列也并没有能涵括所有. App的优化是一个持续的工作, 需要我们持续的关注. 实际上, 关注代码质量, 也是App优化的一个方面. 结语照例, 加个结语, 算是对自己的一个小结, 有些东西也希望分享出来大家共勉. 首先, 对于写文, 一概的态度是相对严肃的, 总认为, 毕竟的对外传输知识, 内容可能会少, 但不希望有错. 希望没有把大家带到坑里~~哈哈. 然后, 实际上一直强调, 授之以渔. 重要的是教方法, 所以, 可以看到这个系列中很多是在讲解一些工具的使用, 结合案例的分析过程. 并非单纯的摆出性能优化应该怎么做balabala, 一二三四五六点. 再然后, 并非没有理论. 正所谓知其然知其所以然, 引入了好几篇的理论文章作为衔接, 是想让大家能在同一个理论基础上去加深对工具使用和分析过程的理解. 最后, 上面几点其实都是废话, 大家点赞就好. 共勉的话学知识, 知其然知其所以然讲知识, 授之以渔而非鱼","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"内存使用总结篇 -- Android内存优化第五弹","slug":"app-opti/app_opt_mem_summary","date":"2016-11-04T10:10:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/11/04/app-opti/app_opt_mem_summary/","link":"","permalink":"http://blog.lmj.wiki/2016/11/04/app-opti/app_opt_mem_summary/","excerpt":"前面几弹从Android内存管理, GC机制理论, 到内存分析工具, 内存泄露实例分析等几个方面聊了下Android App中关于内存优化的一些个知识. 本篇作为Android App内存优化的第五弹, 也是最后一弹, 将对Andorid中的内存优化做一个简单的总结.","text":"前面几弹从Android内存管理, GC机制理论, 到内存分析工具, 内存泄露实例分析等几个方面聊了下Android App中关于内存优化的一些个知识. 本篇作为Android App内存优化的第五弹, 也是最后一弹, 将对Andorid中的内存优化做一个简单的总结. 1, 回顾系列文链接: 1.GC那些事儿2.Android的内存管理3.内存分析工具4.内存泄露实例分析 几个要点: Android的App运行在Dalvik/ART这种类JVM环境的, 使用的是自动内存管理方式, 也就是通常说的GC机制. 每个App默认单独运行在一个VM进程内, 其内存使用是有上限的. 所谓GC就是回收垃圾对象. 所谓垃圾, 就是GC Roots不可达的对象, 也就是死对象(相对于活对象). 对象占用内存(Retained Size)是其所支配(Dominate)的所有子对象的占用内存之和. 故而我们找内存消耗点, 和内存泄露的时候都是关注对象的Retained Size. 所谓内存分析, 最多是就是使用工具定位是哪个对象支配着某个Retained Size很大的对象, 进而定位出内存消耗或内存泄露点. 回顾之后, 我们再来看下内存问题. 2, 内存问题从大的分类上来说, Android App中关于内存的问题大致可以分成如下三类: 内存泄露 内存消耗过大 内存抖动 前二者, 内存泄露和内存消耗过大, 最终的结果就是我们常见的OutOfMemoryException, 今天我们的内存使用总结也主要是针对这二者. 关于内存抖动我们在App优化之消除卡顿一文中有描述. 3, 常见的内存泄露及其解决方案 以下关于泄露的名字, 个人根据自己的习惯起的, 并非哪儿的官方称呼, 希望没有误导到吃瓜群众. 3.1 Context泄露Context使用不当导致的内存泄露.一般来说是因为某些全部的对象, 理当使用Application级别的Context, 而使用了指定Activity的Context, 导致该Activity无法释放. 例如, 某个单例中需要一个Context, 传入了一个Activity的Context, 导致其被这个单例持续引用而无法回收. 这类泄露的解决方案, 就是根据组件的生命周期来正确使用Context, 全局引用使用Application Context. 关于各种Context的说明和使用请参看这篇译文.Context泄露的实例还可以看下android dev blog中的这篇, 需翻墙. 3.2 内部类泄露由于(匿名)内部类隐式地持有一个外部类的引用, 故而当内部类中执行的事情长于外部类的生命周期时, 就会导致外部类的泄露. 常见的此类泄露包括Handler泄露, Thread泄露…, 这些也是我们经常会作为(匿名)内部类在Activity中使用的. 下面以HandlerLeak为例: 如下: 1234567891011121314151617181920public class HandlerLeakActivity extends AppCompatActivity &#123; private BigObject mBigObject = new BigObject(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_memory_leak); mHandler.sendEmptyMessageDelayed(1, 60 * 1000); &#125; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;;&#125; 这段代码我们实际上非常多的使用, 然而如果我们用android lint工具检测的话, 会有一段这样的提示: 也就是说这个Handler类可能会导致内存泄露, 建议我们使用static方式. 点开”more”, 我们来看下官方的建议解决方案: 123456789Since this Handler is declared as an inner class, it may prevent the outerclass from being garbage collected. If the Handler is using a Looper orMessageQueue for a thread other than the main thread, then there is no issue.If the Handler is using the Looper or MessageQueue of the main thread, youneed to fix your Handler declaration, as follows: Declare the Handler as astatic class; In the outer class, instantiate a WeakReference to the outerclass and pass this object to your Handler when you instantiate the Handler;Make all references to members of the outer class using the WeakReferenceobject. 阅读这段”more”的前半段, 我们分析下泄露是怎么产生的: 因为这个Handler是一个内部类(默认持有一个外部类也就是我们的HandlerLeakActivity的引用), 如果这个Handler的Looper/MQ所在的Thread与Main Thread不同, 则没有问题. 但是如果Handler的Looper/MQ就是Main Thread(本例中就是), 那么问题就来了: 这个Handler发送的message会放到MQ中, 这个message会对Handler有一个引用, 而Handler有HandlerLeakActivity的引用. 当我们进入这个Activity, 然后退出, 理当销毁这个Activity并回收了. 但是因为这个message会延时60s, 故而导致这个mHandler被引用, 从而activity被引用着, 而无法回收释放内存. 在GC那些事儿中, 我们就讲到, 运行中的Thread就是GC Root之一, 根据上面的分析, 得出: HandlerLeakActivity到GC Roots可达, 故而无法回收. 我们用LeakCanary来验证下我们的分析: 可以看到, 果然如我们分析的. 那么此类问题怎么解决呢, 可能很多同学也直接使用加上@SuppressLint(“HandlerLeak”)的方式来避免lint提示了, 如下: 1234567@SuppressLint(\"HandlerLeak\")private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125;&#125;; 然而这并非解决之道, 其实这段”more”的后半段也给了我们解决方案 — 使用Static + WeakReference的方式, 具体如下: 123456789101112131415161718192021222324252627282930313233343536public class HandlerLeakActivity extends AppCompatActivity &#123; private BigObject mBigObject = new BigObject(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_memory_leak); new DemoHandler(this).sendEmptyMessageDelayed(1, 60 * 1000); &#125; private static class DemoHandler extends Handler &#123; private final WeakReference&lt;HandlerLeakActivity&gt; mActivity; private DemoHandler(HandlerLeakActivity activity) &#123; this.mActivity = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); HandlerLeakActivity activity = mActivity.get(); if (activity != null) &#123; activity.doSomething(); &#125; &#125; &#125; private void doSomething() &#123; &#125;&#125; 留下一个问题, 为什么说这个Handler不在Main Thread的时候不会有问题, 大家可以自行研究下, 有机会就HandlerLeak这个话题我们再深入研究下. 3.3 Register泄露对于观察者, 广播, Listener等, 注册和注销没有成对出现而导致的内存泄露. 内存泄露实例中那个例子, 就是这种泄露, 在此不在细述了. 解决方案就是编码的时候多注意吧, add/remove, register/unregister, bind/unbind什么的~. 3.4 资源泄露常见的数据库查询Cursor, 文件读写流等, 用完没有关闭导致的内存泄露. 例如: 123456789101112131415161718public class CursorLeakActivity extends AppCompatActivity &#123; private BigObject mBigObject = new BigObject(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_memory_leak); Cursor cursor = getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null); if (cursor != null) &#123; cursor.moveToFirst(); // do something. &#125; &#125;&#125; 这个cursor就可能泄露, 实际上android lint也给了我们提示: 此类问题的解决方案, 一般我们使用try-catch-finally的结构, 在finally中关闭并释放资源.如下: 1234567891011121314151617181920212223242526272829public class CursorLeakActivity extends AppCompatActivity &#123; private BigObject mBigObject = new BigObject(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_memory_leak); Cursor cursor = getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null); try &#123; if (cursor != null) &#123; cursor.moveToFirst(); // do something. &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) &#123; cursor.close(); cursor = null; &#125; &#125; &#125;&#125; 3.5 Bitmap泄露Bitmap没有及时调用recycle()回收导致的泄露. 对于Bitmap是使用, 一直就是Android开发者的痛, 特别是对大图片的处理. 可以说我们大多数的报出来的OutOfMemory异常基本都是因为要给某个Bitmap分配内存, 而可用内存不够导致的. 3.6 内存泄露小结对于内存泄露, 我们尽量是以防为主. 根据上面的常见内存泄露, 我们需要注意以下几点: Context的(根据组件生命周期)合理使用. 避免在Activity中使用非静态内部类, 可以静态内部类+WeakReference达成目的. 注意add/remove, register/unregister, bind/unbind的成对使用. 资源及时关闭, 释放. 4, 有效使用内存的建议 本节大部分内容来自官方开发文档. 合理使用Service Service的及时关闭可以让我们节省内存消耗, 对于一次性的任务, 建议使用IntentService. 使用优化后的数据容器 使用Android提供的SparseArray, SparseBooleanArray, LongSparseArray来代替HashMap的使用. 关于HashMap，ArrayMap，SparseArray, 这篇文章有个比较直观的比较, 可以看下. 少用枚举enum结构 相比于静态常量(static final), enum会耗费双倍的内存. 避免创建不必要的对象 诸如一些临时对象, 特别是循环中的. 考虑实现onTrimMemory(), 在此根据当前的内存状态做些处理. Bitmap的合理有效使用. 对于Bitmap的使用, 建议直接查看官方开发文档中的高效显示Bitmap(需翻墙). 结语至此, Android App内存优化的5发子弹就打完了, 关于App内存优化的部分, 我们就先到这里了, 可能还有很多遗漏的内容. 再次表明下我写文的思想: 一个是想记录下自己的一个解决问题的思路和经验, 再一个是想传达如何去解决问题的思想. 故而, 文章并不是一开始就说有哪些内存问题, 怎么解. 而是从理论基础到分析工具的使用, 案例的分析去一步步的让大家学会怎么处理这类问题. 希望大家能从中得到一些关于解决问题的启发, 而非被灌输一些强记下的知识. 感谢相随…","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"内存泄露实例分析 -- Android内存优化第四弹","slug":"app-opti/app_opt_mem_leak","date":"2016-10-31T10:10:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/10/31/app-opti/app_opt_mem_leak/","link":"","permalink":"http://blog.lmj.wiki/2016/10/31/app-opti/app_opt_mem_leak/","excerpt":"引言前文内存分析工具集中介绍了一系列的内存分析工具及其基本使用, 诸如Memory Monitor, HPROF Viewer, MAT等等. 实际上了解了工具的使用, 我们就已经掌握了如何分析内存问题了. 为了能对工具的使用更加深入, 本篇将一个代码片段为例, 从时序的角度讲解下如何使用这些工具来分析一个内存泄露.","text":"引言前文内存分析工具集中介绍了一系列的内存分析工具及其基本使用, 诸如Memory Monitor, HPROF Viewer, MAT等等. 实际上了解了工具的使用, 我们就已经掌握了如何分析内存问题了. 为了能对工具的使用更加深入, 本篇将一个代码片段为例, 从时序的角度讲解下如何使用这些工具来分析一个内存泄露. 系列文:1.GC那些事儿2.Android的内存管理3.内存分析工具4.内存泄露实例分析 1, 例子假设有一个单例的ListenerManager, 可以add / remove Listener, 有一个Activity, 实现了该listener, 且这个Activity中持有大对象BigObject, BigObject中包含一个大的字符串数组和一个Bitmap List. 代码片段如下: ListenerManager 1234567891011121314151617181920212223public class ListenerManager &#123; private static ListenerManager sInstance; private ListenerManager() &#123;&#125; private List&lt;SampleListener&gt; listeners = new ArrayList&lt;&gt;(); public static ListenerManager getInstance() &#123; if (sInstance == null) &#123; sInstance = new ListenerManager(); &#125; return sInstance; &#125; public void addListener(SampleListener listener) &#123; listeners.add(listener); &#125; public void removeListener(SampleListener listener) &#123; listeners.remove(listener); &#125;&#125; MemoryLeakActivity 1234567891011121314151617public class MemoryLeakActivity extends AppCompatActivity implements SampleListener &#123; private BigObject mBigObject = new BigObject(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_memory_leak); ListenerManager.getInstance().addListener(this); &#125; @Override public void doSomething() &#123; &#125;&#125; 具体代码参看Github. 2, 使用Android Studio的自带工具来分析根据前文的工具介绍, Android Studio自带了Memory Monitor, HPROF Viewer &amp; Analyzer来分析内存使用及内存问题. 2.1 查看Memory使用, 并导出hprof文件启动我们要检测的Activity(MemoryLeakActivity), 然后退出, 在monitor中查看内存变化: 2.2 在HPROF Viewer界面, 开始分析 第一步 点击”Analyzer Tasks”视图中的启动按钮, 启动分析 第二步 查看”Analysis Result”中的分析结果, 点击”Leaked Activityes”中的具体实例, 该实例的引用关系将会展示在”Reference Tree”视图中. 第三步 根据”Reference Tree”视图中的引用关系找到是谁让这个leak的activity活着的, 也就是谁Dominate这个activity对象. 此例中, 比较简单, 可以很清晰看到是ListenerManager的静态单例sInstance最终支配了MemoryLeakActivity. sIntance连接到GC Roots, 故而导致MemoryLeakActivity GC Roots可达, 无法被回收. 关于Dominate, GC Roots, GC Roots可达, 活对象等概念, 请结合前两篇的理论文1, 2观看. 2.3 使用Heap Viewer查看内存消耗上述步骤, 可以让我们快速定位可能的内存泄露. 当然, 内存问题, 除了内存泄露, 还有内存消耗过大. 我们可以在Heap Viewer中查看分析内存的消耗点, 如下: 3, MAT让我们看的更多就单纯的分析Android App的内存使用和内存泄露来说, 个人觉得Android Studio自带的工具已经足够好了, 而且再持续变得更好, 也更便于Android的开发人员去理解. 故而其实一开始在Android性能分析工具一文中, 我就没有详细去提MAT. 相对与Android Studio中的Memory Monitor, HPROF工具来说, MAT的使用显得更加生涩, 难以理解. 关于MAT的帮助文档, 个人翻译了一份, 需要的同学戳这里. 当然, 如果我们想对内存的使用相关知识了解得更多, 还是有必要了解下MAT的…下面我们以几个角度来了解下MAT的基本使用: 再次:Android Studio导出的hprof文件需要转换下才可以在MAT中使用. 1$ hprof-conv com.anly.samples_2016.10.31_15.07.hprof mat.hprof 3.1 Histogram视图定位内存消耗 MAT中很多视图的第一行, 都可以输入正则, 来匹配我们关注的对象实例. 3.2 Dominate Tree视图查看支配关系 3.3 使用OQL查询相关对象对于Android App开发来说, 大部分的内存问题都跟四大组件, 尤其是Activity相关, 故而我们会想查出所有Activity实例的内存占用情况, 可以使用OQL来查询: 具体OQL语法看这里. 3.4 GC路径定位问题上面几个视图都可以让我们很快速的找到内存的消耗点, 接下来我们要分析的就是为何这些个大对象没有被回收. 根据第一弹:GC那些事儿所言, 对象没有被回收是因为他有到GC Roots的可达路径. 那么我们就来分析下这条路径(Path to GC Roots), 看看是谁在这条路中”搭桥”. 如下, 进入该对象的”path2gc”视图: 同样, 与HPROF Analyzer异曲同工, 找出了是ListenerManager的静态实例导致了MemoryLeakActivity无法回收. 4, LeakCanary让内存泄露无处可藏大道至简, 程序员都应该”懒”, 故而我们都希望有更方便快捷的方式让我们发现内存泄露. 伟大的square发挥了这一优良传统, LeakCanary面世. 4.1 加入LeakCanaryapp的build.gradle中加入: 12345dependencies &#123; debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5&apos; releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos; testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos; &#125; Application中加入: 123456789public class SampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); LeakCanary.install(this); &#125;&#125; 4.2 操作要检测的界面, 查看结果当发生可疑内存泄露时, 会在桌面生成一个”Leaks”的图标, 点击进去可以看到内存泄露的疑点报告: 可以看到, 结果与前二者的分析结果”惊人”一致, 不一致就出事儿了, :) 足够方便且直观吧, 赶快用起来吧.当然, 内存问题不仅仅是内存泄露, 还有内存占用过多等, 这时我们就需要借助前两种工具了. 结语综上, 建议LeakCanary集成作为App的必选项, 大多数情况下我们可以用LeakCanary结合Android Studio自带的工具分析内存问题. 如果有精力, 还是建议深入了解下MAT, 能让我们更深入了解GC的机制, 相关概念, MAT还有很多更高端的功能值得我们探索, 例如Heap比较等. 其实, 内存问题的分析, 无外乎分析对象的内存占用(Retained Size), 找出Retained Size大的对象, 找到其直接支配(Immediate Dominator), 跟踪其GC可达路径(Path to GC Roots), 从而找到是谁让这个大对象活着. 找到问题症结, 对症下药.","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"Tools, 出来接活了--Android内存优化第三弹","slug":"app-opti/app_opt_mat","date":"2016-10-25T13:44:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/10/25/app-opti/app_opt_mat/","link":"","permalink":"http://blog.lmj.wiki/2016/10/25/app-opti/app_opt_mat/","excerpt":"引言欲善其事, 先利其器.","text":"引言欲善其事, 先利其器. 1, 一图看懂Memory MonitorMemory Monitor 是 Android Studio内置的, 官方的内存监测工具. 图形化的展示当前应用的内存状态, 包括已分配内存, 空闲内存, 内存实时动态等. 顶部矩形指示当前调试的设备以及应用进程. 图形区域: 横向时间轴, 内存检测时间, 跟随滚动. 纵向内存轴, 内存使用量, 根据应用使用动态分配. 蓝色区域表示当前已分配使用的内存量. 灰色区域表示剩余可使用的内存量. 红色圈圈指示的是系统GC事件(内存有一定量的回收). 工具栏: ① GC按钮, 点击执行一次GC操作. ② Dump Java Heap按钮, 点击会在该调试工程的captures目录生成一个类似这样”com.anly.githubapp_2016.09.21_23.42.hprof”命名的hprof文件, 并打开Android Studio的HPROF Viewer显示该文件内容. ③ Allocation Traking按钮, 点击一次开始, 再次点击结束, 同样会在captrures目录生成一个文件, 类似”com.anly.githubapp_2016.09.21_23.48.alloc”, alloc后缀的文件, 并打开Allocation Tracker视图展示该文件内容. 2, 使用HPROF Viewer &amp; Analyzer来分析hprof文件Memory Monitor通过Dump Java Heap可以生成一个hprof的文件, 这个文件是Android特定的Heap和CPU分析文件, 记录了这段时间内的Java Heap变化. 2.1 关于Java Heap由Java Heap文件可以看到如下数据: 按类型显示对象申请的内存快照(内存大小); 每次自动或手动触发GC时的样本数据; 协助定位可能发生的内存泄露点: 所有已经被destroyed的activity, 还可以从GC Root访问到. 重复的String实例. 2.2 HPROF Viewer怎么看还是用图说话: HPROF Viewer分成三个大块, 分别介绍下: 2.2.1 Class View图中标①的View. 显示当前选中的Heap中的所有Class. 上方有两个可选列表, 分别是用来选择Heap区域, 和Class View的展示方式的. Heap类型分为: App Heap – 当前App使用的Heap Image Heap – 磁盘上当前App的内存映射拷贝 Zygote Heap – Zygote进程Heap(每个App进程都是从Zygote孵化出来的, 这部分基本是framework中的通用的类的Heap) 可选展示方式: Class List View – 类列表方式 Package Tree View – 根据包结构的树状显示 列 解释 Class Name 类名 Total Count 该类的实例个数 Heap Count 选定的Heap中该实例的个数 Sizeof 每个该实例占用的内存大小 Shallow Size 所有该类的实例占用的内存大小 Retained Size 该类的所有实例可支配的内存大小 2.2.2 Instance View图中标②的View.根据在Class View中选中的Class, 列表方式展示其所有实例的内存占用情况. 列 解释 Instance 该类的实例 Depth 深度, 从任一GC Root点到该实例的最短跳数 Dominating Size 该实例可支配的内存大小 2.2.3 Reference Tree图中标③的View.根据在Instance View中选中的实例, 显示其引用关系树. 此View中的列含义与Instance View一致. 在此View中可以右键点击instance, 进入代码: 2.3 HPROF Analyzer另外, 在HPROF Viewer的右侧有一个”Analyzer Tasks”的按钮, 点击会进入HPROF Analyzer的hprof的分析界面: 分析任务包括: 检测泄露的Activity 查找重复的String实例 点击开始按钮后, 会在Analysis Results区域显示分析结果. HPROF Viewer &amp; Analyzer 可以用来对App的运行中的Java Heap做一个整体分析, 展示当前内存的具体到类和实例的分配情况, 以便检测到可能的内存泄露和重复实例. 3, Allocation TrackerHPROF Viewer &amp; Analyzer是整体的, 那么Allocation Tracker则是针对操作的分析. Allocation Tracker可以协助我们分析在一个特定操作时, 有哪些对象被分配内存了. 这可以很方便的让我们知道方法调用的情况, 以便针对性的优化, 以提升性能和内存使用. 在Android Studio的Memory Monitor中点击”Start Allocation Tracking”, 在device中执行一个要分析的操作, 然后再次点击. 如下所示: 会生成一个alloc文件, 并打开: 可以按照两种方式展示: Group by Method – 按照线程方法分组显示 Group by Allocator – 按照包分组显示 Method视图中的列含义如下: 列 解释 Method 方法 Count 该方法分配的实例总数 Size 该方法分配的内存总量(byte) 可以根据Count和Size分别排序, 找出产生实例多, 耗费内存多的方法, 结合代码分析, 以提升其性能. 4, MATEclipse MAT是一个快速且功能丰富的Java Heap分析工具, 可以帮助我们寻找内存泄露, 减少内存消耗. MAT可以分析程序(成千上万的对象产生过程中)生成的Heap dumps文件, 它会快速计算出对象的Retained Size, 来展示是哪些对象没有被GC, 自动生成内存泄露疑点的报告. 具体MAT的使用请移步鄙人翻译整理的MAT的使用手册 5, LeakCanaryLeakCanary是大名鼎鼎的square出的一款开源的用来做内存泄露检测的工具. 具体植入方式, 请参考LeakCanary README文档, 略过. App植入LeakCanary之后, 在检测可能的内存泄露后, 会弹出Toast提示: 并在测试手机桌面生成一个Leaks的icon: 点击该icon进入Leaks界面, 可以比较清晰的看到内存泄露疑点: 6, adb shell dumpsys在之前的一篇关于ADB使用的文中有聊到adb shell dumpsys命令, 该命令可以用户输出当前的系统状态信息. 其中就有关于内存的选项: 1$ adb shell dumpsys meminfo com.udinic.perfdemo 输出信息如下: 该命令常用来查看当前进程的的内存使用状态, 是一个总体的预览. 结语正所谓善其事先利其器, 了解了内存分析工具的使用, 我们才能更好的分析内存问题, 从而得出解决方案或是明白从哪些方面去避免内存问题. 下一篇将以代码实例形式来说明下上面这些工具的具体使用, 敬请期待.","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"Android是如何管理App内存的--Android内存优化第二弹","slug":"app-opti/app_opt_mem_android","date":"2016-10-19T14:10:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/10/19/app-opti/app_opt_mem_android/","link":"","permalink":"http://blog.lmj.wiki/2016/10/19/app-opti/app_opt_mem_android/","excerpt":"引言前文我们普及了下关于GC的一些事, 对GC的一些个概念, 流程有个大概的了解. 在Application的启动流程一文中, 我们有提到, Android中每个App默认情况下是运行在一个独立进程中的, 而这个独立进程正是从Zygote孵化出来的VM进程. 也就是说, 每个App是运行在独立的VM空间的. 那么Android是怎么管理这些App的内存的呢, 这些独立运行的VM中的内存管理又是怎样的呢? 今天我们就来聊下Android中的内存管理.","text":"引言前文我们普及了下关于GC的一些事, 对GC的一些个概念, 流程有个大概的了解. 在Application的启动流程一文中, 我们有提到, Android中每个App默认情况下是运行在一个独立进程中的, 而这个独立进程正是从Zygote孵化出来的VM进程. 也就是说, 每个App是运行在独立的VM空间的. 那么Android是怎么管理这些App的内存的呢, 这些独立运行的VM中的内存管理又是怎样的呢? 今天我们就来聊下Android中的内存管理. 1, Dalvik &amp; ARTAndroid在4.4之前一直使用的Dalvik虚拟机作为App的运行VM的, 4.4中引入了ART作为开发者备选, 5.0起正式将ART作为默认VM了. 我们首先来简单了解下二者: 1.1 Dalvik如果只是想简单了解, 个人觉得百度百科上这个Dalvik的介绍基本就满足要求了. 如果大家想深入, 可以看下老罗的Android之旅中Dalvik的相关博文, 从代码层面上分析了Dalvik的启动, 运行机制等. 值得一看. 需要说明的是, Dalvik采用的是JIT技术, 在应用程序启动时, JIT通过进行连续的性能分析来优化程序代码的执行, 在程序运行的过程中, Dalvik在不断的进行将字节码编译成机器码的工作. 1.2 ARTART 取自 Android RunTime. Android用其取代Dalvik, 主要目的就是为了提升运行性能. 所以, ART相比Dalvik有几个关键的提升: 引入AOT(ahead-of-time)预编译技术在安装apk的过程中, ART会使用dex2oat程序所有的字节码预编译成了机器码. 应用程序运行过程中无需进行实时的编译工作, 只需要进行直接调用. 故而提高了应用程序的运行效率. GC效率 由原来的两次GC暂停减少为一次. 以较少的GC时间回收最近分配的, 短命的对象. 提升GC工程学, 使并发GC更及时. 压缩GC, 以减少后台内存使用和内存碎片. 开发和调试 支持内存/方法执行的采样分析. 支持更多的调试技. 在Crash report中提供更多信息. 2, Android的内存管理方式ART和Dalvik都是使用paging和memory-mapping(mmapping)来管理内存的. 这就意味着, 任何被分配的内存都会持续存在, 唯一的释放这块内存的方式就是释放对象引用(让对象GC Root不可达), 故而让GC程序来回收内存. 2.1 App的内存分配和回收对于每个App进程来说, Heap内存被限制在一个虚拟的内存区间内. 且定义了逻辑上的使用的Heap Size, 这个Heap Size在系统限制的最大值之内是随着应用的使用情况而变化的. Heap内存的逻辑大小和实际物理内存的大小是不相同的. 后面我们在使用Memory Monitor等内存分析工具分析内存时, 会看到一个叫做Proportional Set Size (PSS)的值, 这个值才是系统认为的你的App所占用的物理内存大小. 这个PSS值也就是实际物理内存大小, 统计包括了你的应用进程所占用的内存大小, 和共享内存中占用的内存大小(比例分配方式计算). Android VM不会压缩Heap内存的逻辑大小, 故而无法通过碎片整理的方式来释放Heap空间, 而只能通过回收Heap尾部的空内存块来压缩逻辑内存大小. 这时, 我们的GC就出场了, GC之后, VM会遍历Heap找到不被使用的pages, 通过madvise函数将其返回给内核, 从而释放这块被逻辑Heap使用的物理内存. 2.2 App内存限制Android是一个多任务系统, 为了保证多任务的运行, Android给每个App可使用的Heap大小设定了一个限定值. 这个值是系统设置的prop值, 系统编译时内置的, 保存在system/build.prop中. 一般国内的手机厂商都会做修改, 根据手机配置不同而不同, 可以通过如下命令查看: 12$ adb shellshell@hwH60:/ $ cat /system/build.prop 以手头的Huawei 荣耀6为例, heap size相关的prop如下: 123456dalvik.vm.heapstartsize=8mdalvik.vm.heapgrowthlimit=192mdalvik.vm.heapsize=512mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=2mdalvik.vm.heapmaxfree=8m 其中: dalvik.vm.heapstartsize – App启动后, 系统分配给它的Heap初始大小. 随着App使用可增加. dalvik.vm.heapgrowthlimit – 默认情况下, App可使用的Heap的最大值, 超过这个值就会产生OOM. dalvik.vm.heapsize – 如果App的manifest文件中配置了largeHeap属性, 如下.则App可使用的Heap的最大值为此项设定值. 1234&lt;application android:largeHeap=\"true\"&gt; ...&lt;/application&gt; dalvik.vm.heaptargetutilization – 当前理想的堆内存利用率. GC后, Dalvik的Heap内存会进行相应的调整, 调整到当前存活的对象的大小和 / Heap大小 接近这个选项的值, 即这里的0.75. 注意, 这只是一个参考值. dalvik.vm.heapminfree – 单次Heap内存调整的最小值. dalvik.vm.heapmaxfree – 单次Heap内存调整的最大值. 也可以直接使用getprop查看单项prop: 12$ adb shell getprop dalvik.vm.heapsize512m 2.3 切换App时的内存管理机制Android的进程级别Android 系统会尽可能长时间地保持应用进程, 但为了新建进程或运行更重要的进程, 最终需要清除旧进程来回收内存. 为了确定保留或终止哪些进程, 系统会根据进程中正在运行的组件以及这些组件的状态, 将每个进程设定了一个重要级别. 必要时, 系统会首先消除重要性最低的进程, 然后是重要性略低的进程, 依此类推, 以回收系统资源. 依据重要程度从大到小依次分为5级: 前台进程 用户当前操作所必需的进程. 如果一个进程满足以下任一条件, 即视为前台进程： 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法） 托管某个 Service，后者绑定到用户正在交互的 Activity 托管正在“前台”运行的 Service（服务已调用 startForeground()） 托管正执行一个生命周期回调的 * Service（onCreate()、onStart() 或 onDestroy()） 托管正执行其 onReceive() 方法的 BroadcastReceiver 只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。 可见进程 没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程： 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况 托管绑定到可见（或前台）Activity 的 Service可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。 服务进程 正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 后台进程 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 空进程 不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 切换App的内存管理当用户切换App时, 被切换到后台的App所使用的内存并未因此删除, 该App进程被缓存到一个LRU缓存中, 以便用户切换回来时, 能更快的启动App, 让多任务更流畅. 但是, 当系统内存不够用的时候, 就会根据LRU特性, 以及上面说到的进程级别(同时也会考虑该App进程占用的内存大小)来决定杀死哪些进程, 来回收内存, 以便执行当前任务. 所以, 如果我们为了不要让系统kill掉我们的App, 可以从进程级别, 内存消耗量等几个方面进行优化. 结语本文加上GC那些事儿, 我们讲了两篇的理论知识, 相信大家对Android的内存管理有了个大体的了解, 后面将介绍一些内存分析工具以及使用, 结合实际来说明怎么分析内存问题. 参考 Overview of Android Memory Management Processes and Threads ART and Dalvik","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"GC那些事儿--Android内存优化第一弹","slug":"app-opti/app_opt_mem_gc","date":"2016-10-11T14:18:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/10/11/app-opti/app_opt_mem_gc/","link":"","permalink":"http://blog.lmj.wiki/2016/10/11/app-opti/app_opt_mem_gc/","excerpt":"引言接App优化之内存优化(序), 作为App优化系列中内存优化的一个小部分. 由于内存相关知识比较生涩, 内存优化中使用到的相关工具, 也有很多专有名词. 对Java内存管理, GC, Android内存管理, Dalvik/ART等知识有一个理论的认识, 可以让我们更好的使用这些工具, 分析内存问题. 据此, 我们就先从理论入手, 聊聊GC那些事儿.","text":"引言接App优化之内存优化(序), 作为App优化系列中内存优化的一个小部分. 由于内存相关知识比较生涩, 内存优化中使用到的相关工具, 也有很多专有名词. 对Java内存管理, GC, Android内存管理, Dalvik/ART等知识有一个理论的认识, 可以让我们更好的使用这些工具, 分析内存问题. 据此, 我们就先从理论入手, 聊聊GC那些事儿. 1, 何为GCGC 是 garbage collection 的缩写, 垃圾回收的意思. 也可以是 Garbage Collector, 也就是垃圾回收器. 1.1 垃圾回收器我们先来解释下Garbage Collector(垃圾回收器). 内存管理, 一直是编程中的一个大的问题. 在较老的语言中, 例如C++语言中, 内存管理是显式的, 也就是说使用者自己申请内存使用, 自己释放内存. 这就是为什么C++语言中除了构造函数, 还有析构函数. 我们在创建对象的时候调用构造函数创建, 系统会在对象结束其作用域的时候调用析构函数, 我们需要做的就是在析构函数中释放掉我们申请的相关资源, 以便释放内存地址. 显然, 这种显式的由编程人员自己控制释放内存的方式很容易出问题, 忘了, 漏了, 都可能导致内存问题. 也不符合程序员要懒的特征. 故而, Java语言中引入了自动内存管理的机制, 也就是垃圾回收器. 大部分的现代面向对象语言, 也都是采用自动内存管理机制. 内存自动管理回收机制可以解决大部分, 但不是所有的内存问题, 这也是为什么我们要讨论内存泄露. 垃圾回收器的职责垃圾回收器有三大职责: 分配内存; 确保任何被引用的对象保留在内存中; 回收不能通过引用关系找到的对象的内存. 垃圾回收的一般流程 1.2 相关概念垃圾回收(GC)垃圾回收器中有一个进程来做上面的这些事情, 这个进程查找我们的对象引用的关系并释放其内存, 这个进程就是garbage collection(垃圾回收), 也就是我们常说的GC. Heap和Stack简单说下: Heap内存是指java运行环境用来分配给对象和JRE类的内存. 是应用的内存空间. Stack内存是相对于线程Thread而言的, 它保存线程中方法中短期存在的变量值和对Heap中对象的引用等. Stack内存, 顾名思义, 是类Stack方式, 总是后进先出(LIFO)的. 我们通常说的GC的针对Heap内存的. 因为Stack内存相当于是随用随销的. GC Root直译GC根, 我们姑且不译了吧.所谓GC Root我们可以理解为是一个Heap内存之外的对象, 通常包括但不仅限于如下几种: System Class 系统Class Loader加载的类. 例如java运行环境中rt.jar中类, 比如java.util.* package中的类. Thread 运行中的线程 JNI 中的本地/全局变量, 用户自定义的JNI代码或是JVM内部的. Busy Monitor 任何调用了wait()或notify()方法, 或是同步化的(synchronized)的东西. 可以理解为同步监控器. Java本地实例, 还在运行的Thread的stack中的方法创建的对象. 活对象/垃圾如果这个对象是引用可达的, 则称之为活的(live), 反之, 如果这个对象引用不可达, 则称之为死的(dead), 也可以称之为垃圾(garbage). 这个引用可达与不可达就是相对于GC Root来说的: 2, Java的内存管理机制2.1 关于JVM我们平常在查看我们的java版本时, 你会发现: 1234$ java -versionjava version \"1.8.0_74\"Java(TM) SE Runtime Environment (build 1.8.0_74-b02)Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode) 其中有个HotSpot VM的东西, 那么这个是什么呢? 和JVM有什么关系呢? 在此简单说下, 以便行文: JVM, Java虚拟机, 可以简单理解为一种技术思想, 虚拟技术理念. HotSpot VM是JVM的一种实现, 包含了服务器版和桌面应用程序版, 现时由Oracle维护并发布. 我们当前使用的sun(oracle)的java版本(应该是1.3以上)都是内置的HotSpot VM实现. 所以接下来的分析也都是基于HotSpot VM的, 但是还是简称JVM. 2.2 JVM内存区域JVM使用分代式的内存管理方式, 将Heap分成三代 — 新生代, 老一代, 持久代. Young Generation 新生代. 所有new的对象. 该区域的内存管理使用minor garbage collection(小GC). 更进一步分成Eden space, Survivor 0 和 Survivor 1 三个部分. Old Generation 老年区. 新生代中执行小粒度的GC幸存下来的”老”对象. 该区域的内存管理使用major garbage collection(大GC). Permanent Generation 持久代. 包含应用的类/方法信息, 以及JRE库的类和方法信息. 小GC执行非常频繁, 而且速度特别快.大GC一般会比小GC慢十倍以上.大小GC都会发出”Stop the World”事件, 也就是说中断程序运行, 直至GC完成. 这也是我们在App优化之消除卡顿中为什么说频繁GC会造成用户感知卡顿. 3, GC的流程了解了内存Heap的几个区域, 我们再来看下垃圾收集器是怎么利用这几个区域来管理内存和回收垃圾的. 1. 创建新的对象 每当我们使用new创建一个对象时, 这个对象会被分配到新生代的Eden区域: 2. 当Eden区域满时当Eden区域内存被分配完时, 小GC程序被触发: 引用可达的对象会移到Survivor(幸存者)区域–S0, 然后清空Eden区域, 此时引用不可达的对象会直接删除, 内存回收, 如下: 3. Eden再次满时当Eden区域再次分配完后, 小GC执行, 引用可达的对象会移到Survivor(幸存者)区域, 而引用不可达的对象会跟随Eden的清空而删除回收. 需要注意的是, 这次引用可达的对象移动到的是S1的幸存者区.而且, S0区域也会执行小GC, 将其中还引用可达的对象移动到S1区, 且年龄+1. 然后清空S0, 回收其中引用不可达的对象. 此时, 所有引用可达的对象都在S1区, 且S1区的对象存在不同的年龄. 如下: 当Eden第三次满时, S0和S1的角色互换了: 依此循环. 4. 当Survivor区的对象年龄达到”老年线”时上面1~3循环, Survivor区的对象年龄也会持续增长, 当其中某些对象年龄达到”老年线”, 例如8岁时, 它们会”晋升”到老年区. 如此1~4步重复, 大体流程是这样的 参考 http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html http://www.ibm.com/support/knowledgecenter/SS3KLZ/com.ibm.java.diagnostics.memory.analyzer.doc/gcroots.html http://www.infoq.com/cn/articles/jvm-memory-collection http://www.journaldev.com/4098/java-heap-space-vs-stack-memory","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"App优化之网络优化","slug":"app-opti/app_opt_network","date":"2016-10-06T06:47:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/10/06/app-opti/app_opt_network/","link":"","permalink":"http://blog.lmj.wiki/2016/10/06/app-opti/app_opt_network/","excerpt":"引言互联网时代, App作为于用户交互的端, 可以说实际上是一个界面, 产品的业务, 服务都是由Server提供的. 而App与Server的交互依赖于网络, 故而网络优化, 也是我们的App优化中不可缺少的一个优化项.","text":"引言互联网时代, App作为于用户交互的端, 可以说实际上是一个界面, 产品的业务, 服务都是由Server提供的. 而App与Server的交互依赖于网络, 故而网络优化, 也是我们的App优化中不可缺少的一个优化项. 1, 网络连接对用户的影响App的网络连接对于用户来说, 影响很多, 且多数情况下都很直观, 直接影响用户对这个App的使用体验. 其中较为重要的几点: 流量 App的流量消耗对用户来说是比较敏感的, 毕竟流量是花钱的嘛. 现在大部分人的手机上都有安装流量监控的工具App, 用来监控App的流量使用. 如果我们的App这方面没有控制好, 会给用户不好的使用体验. 电量 电量相对于用户来说, 没有那么明显. 一般用户可能不会太注意. 但是如前文电量优化中说的那样, 网络连接(radio)是对电量影响很大的一个因素. 所以我们也要加以注意. 用户等待 也就是用户体验, 良好的用户体验, 才是我们留住用户的第一步. 如果App请求等待时间长, 会给用户网络卡, 应用反应慢的感觉, 如果有对比, 有替代品, 我们的App很可能就会被用户无情抛弃. 2, 分析网络连接的工具2.1 Network MonitorAndroid Studio内置的Monitor工具中就有一个Network Monitor: 其中: Rx — R(ecive) 表示下行流量, 即下载接收. Tx — T(ransmit) 表示上行流量, 即上传发送. 怎么使用Network Monitor? Network monitor实时跟踪选定应用的数据请求情况. 我们可以连上手机, 选定调试应用进程, 然后在App上操作我们需要分析的页面请求. 例如, 上图就是以CoderPub为例, 针对从repo列表界面进入repo详情界面的监控数据. 可以看到从10s到30s之间, 20s时间内发生了多次数据请求, 且22s到27s之间的请求数据量还很大. 分析代码可以看到, 在请求repo详情的时候是打包了很多请求的: 12345678910111213141516171819202122232425@Overridepublic Observable&lt;RepoDetail&gt; getRepoDetail(String owner, String name) &#123; return Observable.zip(mRepoService.get(owner, name), mRepoService.contributors(owner, name), mRepoService.listForks(owner, name, \"newest\"), mRepoService.readme(owner, name), isStarred(owner, name), new Func5&lt;Repo, ArrayList&lt;User&gt;, ArrayList&lt;Repo&gt;, Content, Boolean, RepoDetail&gt;() &#123; @Override public RepoDetail call(Repo repo, ArrayList&lt;User&gt; users, ArrayList&lt;Repo&gt; forks, Content readme, Boolean isStarred) &#123; RepoDetail detail = new RepoDetail(); repo.setStarred(isStarred); detail.setBaseRepo(repo); detail.setForks(forks); // because the readme content is encode with Base64 by github. readme.content = StringUtil.base64Decode(readme.content); detail.setReadme(readme); detail.setContributors(users); return detail; &#125; &#125;);&#125; 这也验证了14s到20s间的四次数据请求, 另外由于repo详情界面会显示作者以及贡献者的图片, 而图片的数据量相对大, 故而23s到27s间有多次数据量很大的请求发生. 这个实际是有很多优化空间的, 我们稍后再说. 2.2 网络代理工具一般来说, 网络代理工具有两个作用: 截获网络请求响应包, 分析网络请求 设置代理网络, 移动App开发中一般用来做不同网络环境的测试, 例如Wifi/4G/3G/弱网等. 代理工具很多, 诸如Wireshark, Fiddler, Charles等, 在此不一一细说了, 使用方法自行问谷歌度娘. :) 3, 哪些方面取优化网络连接第一节说到了网络请求对App和用户的影响, 那么我们怎么从哪些方面去优化网络进而减少甚至消灭这些影响呢? 简单来说, 两个方面: 减少Radio活跃时间 也就是减少网络数据获取的频次. 这就减少了radio的电量消耗, 控制电量使用. 减少获取数据包的大小 可以减少流量消耗 也可以让每次请求更快, 在网络情况不好的情况下也有良好表现, 提升用户体验. 那么, 具体应该从哪些方面着手呢? 3.1 接口设计API设计App与Server之间的API设计要考虑网络请求的频次, 资源的状态等. 以便App可以以较少的请求来完成业务需求和界面的展示. 例如, 注册登录. 正常会有两个API, 注册和登录, 但是设计API时我们应该给注册接口包含一个隐式的登录. 来避免App在注册后还得请求一次登录接口(有可能失败, 从而导致业务流程失败). 再例如, 上文提到的获取repo详情, 实际上请求了4个接口, 请求了repo的信息, forks列表, contributors列表, readme, 这是因为github提供的接口是尽量单一职责的. 然而在我们的实际开发中, 我们的Server除了提供这些单一职责的小接口外, 最好还能组合一个满足客户端业务需求的repo详情接口出来. Gzip压缩使用Gzip来压缩request和response, 减少传输数据量, 从而减少流量消耗. 考虑使用Protocol Buffer代替JSON从前我们传输数据使用XML, 后来使用JSON代替了XML, 很大程度上也是为了可读性和减少数据量(当然还有映射成POJO的方便程度). Protocol Buffer是Google推出的一种数据交换格式. 如果我们的接口每次传输的数据量很大的话, 可以考虑下protobuf, 会比JSON数据量小很多. 当然相比来说, JSON也有其优势, 可读性更高. 本文以网络流量优化的角度推荐protobuf作为一个选择, 具体还需更具实际情况考虑. 图片的Size上面Network Monitor中看到的22s到27s之间的有多次请求, 且数据量还很大. 就是在获取图片资源. 图片相对于接口请求来说, 数据量要大得多. 故而也是我们需要优化的一个点. 我们可以在获取图片时告知服务器需要的图片的宽高, 以便服务器给出合适的图片, 避免浪费. 我们现在很多公司的图片资源都是使用第三方的云存储服务的(七牛, 阿里云存储之类的). 以七牛为例, 可以在请求图片的url中添加诸如质量, 格式, width, height等path来获取合适的图片资源: 123456imageView2/&lt;mode&gt;/w/&lt;LongEdge&gt; /h/&lt;ShortEdge&gt; /format/&lt;Format&gt; /interlace/&lt;Interlace&gt; /q/&lt;Quality&gt; /ignore-error/&lt;ignoreError&gt; 参考七牛官方文档. 3.2 网络缓存适当的缓存, 既可以让我们的应用看起来更快, 也能避免一些不必要的流量消耗. 关于Android App的网络缓存, 请参考MVP架构实现的Github客户端(4-加入网络缓存)一文. 3.3 打包网络请求当接口设计不能满足我们的业务需求时. 例如可能一个界面需要请求多个接口, 或是网络良好, 处于Wifi状态下时我们想获取更多的数据等. 这时就可以打包一些网络请求, 例如请求列表的同时, 获取Header点击率较高的的item项的详情数据. 可以通过一些统计数据来帮助我们定位用户接下来的操作是高概率的, 提前获取这部分的数据. 3.4 监听相关状态通过监听设备的状态: 休眠状态 充电状态 网络状态 结合JobScheduler来根据实际情况做网络请求. 比方说Splash闪屏广告图片, 我们可以在连接到Wifi时下载缓存到本地; 新闻类的App可以在充电, Wifi状态下做离线缓存. 3.5 弱网测试&amp;优化除了正常的网络优化, 我们还需考虑到弱网情况下, App的表现. 3.5.1 弱网测试有几种方式来模拟弱网进行测试. Android Emulator创建和启动Android模拟器可以设置网络速度和延迟: 创建时: 启动时, 使用emulator命令: 1$emulator -netdelay gprs -netspeed gsm -avd Nexus_5_API_22 具体参数参考这里和这里, 需要翻墙. 使用网络代理工具以Charles为例:保持手机和PC处于同一个局域网, 在手机端wifi设置高级设置中设置代理方式为手动, 代理ip填写PC端ip地址, 端口号默认8888. 其他模拟弱网方式如果你恰好也是iOS的开发者, Apple提供了Network Link Conditioner, 非常好用. 可以模拟的网络情况与上述类似: 如果你使用Linux环境开发, 还可以试下facebook出的ATC. 3.5.2 弱网优化利用上述工具模拟弱网, 在弱网情况下体验我们的App. 一般来说, 网络延迟在60ms内, 是OK的, 超过200ms就比较糟糕了. 我们需要做的是在比较糟糕的网络环境下还能给用户较好的体验. 弱网优化, 本质上是在弱网的情况下能让用户流畅的使用我们的App. 我们要做的就是结合上述的优化项: 压缩/减少数据传输量 利用缓存减少网络传输 针对弱网(移动网络), 不自动加载图片 界面先反馈, 请求延迟提交 例如, 用户点赞操作, 可以直接给出界面的点赞成功的反馈, 使用JobScheduler在网络情况较好的时候打包请求. 网络优化, 是App优化中相当重要的一项优化. 除了客户端, 接口的优化外, 很多一部分优化还依赖于服务器端, 包括服务器端的代码开发, 部署方式等. 跟你的服务器开发/运维工程师一起聊聊这个话题吧:)","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"App优化之电池省着用","slug":"app-opti/app_opt_battery","date":"2016-09-25T14:23:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/09/25/app-opti/app_opt_battery/","link":"","permalink":"http://blog.lmj.wiki/2016/09/25/app-opti/app_opt_battery/","excerpt":"引言电量使用优化, 基本上是我们最不怎么关注的一项优化. 可能很多公司连QA/Tester也不会关注测试App电量的使用. 一般来说开发和测试的测试设备也一直是连着USB处于充电状态的, 感官上也体会不到电量的损耗. 然而, 对于用户来说, 实际上App的电量损耗也是用户体验的一个方面. 特别是当今人们对移动设备的依赖度越来越高, 电量也是用户特别关注的. 今天我们就来聊聊Android App的电量优化.","text":"引言电量使用优化, 基本上是我们最不怎么关注的一项优化. 可能很多公司连QA/Tester也不会关注测试App电量的使用. 一般来说开发和测试的测试设备也一直是连着USB处于充电状态的, 感官上也体会不到电量的损耗. 然而, 对于用户来说, 实际上App的电量损耗也是用户体验的一个方面. 特别是当今人们对移动设备的依赖度越来越高, 电量也是用户特别关注的. 今天我们就来聊聊Android App的电量优化. 1, 分析电量的使用情况老套路, 上来还是先介绍下我们使用什么工具来做电量分析. 1.1 Batterystats &amp; bugreportAndroid 5.0及以上的设备, 允许我们通过adb命令dump出电量使用统计信息. 1, 因为电量统计数据是持续的, 会非常大, 统计我们的待测试App之前先reset下, 连上设备, 命令行执行: 12$ adb shell dumpsys batterystats --resetBattery stats reset. 2, 断开测试设备, 操作我们的待测试App.3, 重新连接设备, 使用adb命令导出相关统计数据: 12// 此命令持续记录输出, 想要停止记录时按Ctrl+C退出.$ adb bugreport &gt; bugreport.txt 导出的统计数据存储到bugreport.txt, 此时我们可以借助如下工具来图形化展示电池的消耗情况. 注意, 官方SDK文档导出文件方式为:adb shell dumpsys batterystats &gt; batterystats.txt使用python historian.py batterystats.txt &gt; batterystats.html查看数据是battery-historian老版本的使用方式. 目前Battery Historian已更新2.0版本, 推荐使用bugreport方式导出数据分析, 可以看到更多信息. 1.2 Battery HistorianGoogle提供了一个开源的电池历史数据分析工具 – Battery Historian. 1.2.1 安装按照Battery Historian在github上的readme, 一步步安装即可. 需要注意的是, Battery Historian是Go语言的, 安装Go的时候需要配置其bin的环境变量.Python环境需要是2.7的(3.x不行), 建议使用pyenv管理本地的python环境.另外, 因为Battery Historian是一个网页版工具, 涉及一些JS引用, 有时需要翻墙. 安装完成后, 执行: 12cd $GOPATH/src/github.com/google/battery-historiango run cmd/battery-historian/battery-historian.go [--port &lt;default:9999&gt;] 程序运行在http://localhost:9999, 如下: 1.2.2 界面导入我们在第一步通过adb bugreport生成的bugreport.txt文件: 2, 主要的耗电因素 从手机的电池详情统计可以简单看出, 手机中最耗电的模块肯定是屏幕了, 接着就是网络相关, 另外可能的耗电大户还有GPS芯片, Camera等. 对于一个App, 对应因素主要有: 2.1 网络请求我们可能会有发现: 测试用的手机充满电放了一个十一假期还有电, 是因为测试手机没有上SIM卡. 飞行模式下的手机灭屏下, 可能可以放一个月都还有电. 这是因为: 手机的通过内置的射频模块和基站几乎, 从而链接上网的, 而这个射频模块(radio)是非常耗电的. 为了控制这个射频模块的耗电, 硬件驱动及Android RIL层做了很多处理. 例如可以单独关闭radio(飞行模式), 间歇性假休眠radio(有数据发生时才上电, 保持一个频率的与基站交互)等等. 现如今App都是移动互联网App, 不可避免的会有大量的网络请求, 会导致radio一直处于活跃状态, 从而耗电量增加. 2.2 WakeLockAndroid系统本身为了优化电量的使用, 会在没有操作时进入休眠状态, 来节省电量. 当然, 为了便于开发(很多应用不可避免的希望在灭屏后还能运行一些事儿, 或是要保持屏幕一直亮着–比如播放视频), Android提供了一个PowerManager.WakeLock的东西. 我们可以用WakeLock来保持CPU运行, 或是防止屏幕变暗/关闭, 让手机可以在用户不操作时依然可以做一些事儿. 然而, 获取WakeLock很容易, 释放不好就会成为难题, 消耗电量. 例如我们获取了一个WakeLock来保持CPU运转, 做一个复杂运算并将数据上传到后台服务器, 然后释放该WakeLock. 然而这个过程可能并不像我们想象的那么快, 可能因为比如服务器挂掉, 计算出了异常等等WakeLock没有释放. 问题就来了, CPU会一直得不到休眠, 而大大增加耗电. 另外, WakeLock还有android:keepScreenOn属性, 还可以让屏幕常量, 这可是耗电大户. 2.3 GPS应用中经常会用到定位服务, Android提供了Network定位和GPS定位. 相对来说, GPS会精确得多, 对于一些诸如跑步, 导航类的应用基本会使用GPS定位. 然而, GPS定位也会消耗大量的电量. 3, 尽可能减少App的电量消耗的建议了解了上述的主要的耗电因素, 还有一些程序的耗电问题, 我们通过Battery Historian也可以分析. 针对这些耗电情况, 给出如下优化建议: 3.1 优化网络请求 这个会在网络优化那篇中细聊, 在此略过. 3.2 谨慎使用WakeLock WakeLock获取释放成对出现. 使用超时WakeLock, 以防出异常导致没有释放. 12// Acquires the wake lock with a timeout.acquire(long timeout) 3.3 监听手机充电状态BatteryManager会发送一个包含充电状态的持续广播, 我们可以通过此广播获取充电状态和电量详情: 12IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);Intent batteryStatus = context.registerReceiver(null, ifilter); 注意: 因为这是一个持续广播, 我们无需写receiver, 可以直接通过intent获取相关数据. 例如, 如果设备正在充电: 123456789// Are we charging / charged?int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1);boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL;// How are we charging?int chargePlug = battery.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);boolean usbCharge = chargePlug == BATTERY_PLUGGED_USB;boolean acCharge = chargePlug == BATTERY_PLUGGED_AC; 另外我们也可以监听充电状态的变化, 只要设备连接或断开电源, BatteryManager就会广播相应的操作, 我们可以注册receiver来监听: 123456&lt;receiver android:name=\".PowerConnectionReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.ACTION_POWER_CONNECTED\"/&gt; &lt;action android:name=\"android.intent.action.ACTION_POWER_DISCONNECTED\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 监听电池状态, 可以让我们将一些操作放在充电或是电量足够的情况下进行, 以提升用户体验. 例如用户数据同步, Log上传等. 3.4 Doze and App StandbyAndroid 6.0提供了两个用来节省电量的技术Doze和App Standby. Doze 瞌睡. 如果设备闲置了一段较长时间, Doze技术将通过延迟后台网络活动, CPU运行等来减少电量损耗. App Standy 应用待机. 不是最近得到过用户”宠幸”的App, App Standy将延缓这个应用的后台网络活动. 因为所有Android 6.0及以上的设备上, Doze and App Standby都会运行. 可能会影响你的App的运行, 具体的适配请参考官方文档. 3.5 关于定位 定位中使用GPS, 请记得及时关闭 12// Remove the listener you previously addedlocationManager.removeUpdates(locationListener); 减少更新频率 根据实际情况选择GPS或网络或两者. 只使用一个会降低电量损耗.","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"App优化之内存优化(序)","slug":"app-opti/app_opt_mem_0","date":"2016-09-21T14:08:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/09/21/app-opti/app_opt_mem_0/","link":"","permalink":"http://blog.lmj.wiki/2016/09/21/app-opti/app_opt_mem_0/","excerpt":"引言系列终于走到了内存这里了.内存问题, 一直是Android App开发中比较困扰的问题. 灾难性, 难以复现, 难以定位. 内存管理的知识也相对生涩, 很多工具的使用需要对一些内存相关的专有名词有一定了解, 例如GC Roots, Heap, Stack, Shallow Size, Retained Size, Depth等等.","text":"引言系列终于走到了内存这里了.内存问题, 一直是Android App开发中比较困扰的问题. 灾难性, 难以复现, 难以定位. 内存管理的知识也相对生涩, 很多工具的使用需要对一些内存相关的专有名词有一定了解, 例如GC Roots, Heap, Stack, Shallow Size, Retained Size, Depth等等. 计划整理了之前的笔记, 也查阅了相关资料, 发现这块内容还是挺多的. 故而内存优化这块, 计划分成几个小部分来写, 先理论后实践的方向, 大体会包括如下: Java内存管理及垃圾回收机制 Android的内存管理 常用的内存分析工具 内存泄露实例分析 内存使用小结 结语内存优化暂放这儿, 后续会先更新App优化系列中提到的电量优化和网络优化.","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"App优化之消除卡顿","slug":"app-opti/app_opt_smooth","date":"2016-09-18T14:17:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/09/18/app-opti/app_opt_smooth/","link":"","permalink":"http://blog.lmj.wiki/2016/09/18/app-opti/app_opt_smooth/","excerpt":"引言前文App优化之ANR详解中说到的ANR基本是属于App中卡,慢的极致了, 属于不可用的状态了. 然而, 现实中有很多的App卡顿是不会产生ANR的, 但是又是用户可以感知的, 给人感觉我们的App运行非常慢, 影响用户体验. 这节我们就来聊聊App中的卡顿现象.","text":"引言前文App优化之ANR详解中说到的ANR基本是属于App中卡,慢的极致了, 属于不可用的状态了. 然而, 现实中有很多的App卡顿是不会产生ANR的, 但是又是用户可以感知的, 给人感觉我们的App运行非常慢, 影响用户体验. 这节我们就来聊聊App中的卡顿现象. 1, 感知卡顿用户对卡顿的感知, 主要来源于界面的刷新. 而界面的性能主要是依赖于设备的UI渲染性能. 如果我们的UI设计过于复杂, 或是实现不够好, 设备又不给力, 界面就会像卡住了一样, 给用户卡顿的感觉. 1.1 16ms原则在剖析卡顿的原因之前, 我们先来了解下Android中著名的”16ms”原则: Android系统每隔16ms会发出VSYNC信号重绘我们的界面(Activity).为什么是16ms, 因为Android设定的刷新率是60FPS(Frame Per Second), 也就是每秒60帧的刷新率, 约合16ms刷新一次. 就像是这样的: 这就意味着, 我们需要在16ms内完成下一次要刷新的界面的相关运算, 以便界面刷新更新. 然而, 如果我们无法在16ms内完成此次运算会怎样呢? 例如, 假设我们更新屏幕的背景图片, 需要24ms来做这次运算. 当系统在第一个16ms时刷新界面, 然而我们的运算还没有结束, 无法绘出图片. 当系统隔16ms再发一次VSYNC信息重绘界面时, 用户才会看到更新后的图片. 也就是说用户是32ms后看到了这次刷新(注意, 并不是24ms). 这就是传说中的丢帧(dropped frame): 丢帧给用户的感觉就是卡顿, 而且如果运算过于复杂, 丢帧会更多, 导致界面常常处于停滞状态, 卡到爆. 那么会有哪些常见的情况会导致运算超过16ms, 进而丢帧, 让用户觉得卡顿呢? 2, 卡顿原因分析及处理一般来说, 会有以下几种情况导致卡顿这种性能问题, 我们逐一看下: 2.1 过于复杂的布局上节有说, 界面性能取决于UI渲染性能. 我们可以理解为UI渲染的整个过程是由CPU和GPU两个部分协同完成的. 其中, CPU负责UI布局元素的Measure, Layout, Draw等相关运算执行. GPU负责栅格化(rasterization), 将UI元素绘制到屏幕上. 如果我们的UI布局层次太深, 或是自定义控件的onDraw中有复杂运算, CPU的相关运算就可能大于16ms, 导致卡顿. 这个时候, 我们需要借助Hierarchy Viewer这个工具来帮我们分析布局了. Hierarchy Viewer不仅可以以图形化树状结构的形式展示出UI层级, 还对每个节点给出了三个小圆点, 以指示该元素Measure, Layout, Draw的耗时及性能. 具体请参考App优化之Layout怎么摆. 2.2 过度绘制(Overdraw)上节说的CPU方面的, 关于GPU的绘制, 如果我们的界面存在Overdraw, 也可能导致卡顿. Overdraw: 用来描述一个像素在屏幕上多少次被重绘在一帧上.通俗的说: 理想情况下, 每屏每帧上, 每个像素点应该只被绘制一次, 如果有多次绘制, 就是Overdraw, 过度绘制了. 2.2.1 调试OverdrawAndroid系统提供了可视化的方案来让我们很方便的查看overdraw的现象:在”系统设置”–&gt;”开发者选项”–&gt;”调试GPU过度绘制”中开启调试: 此时界面可能会有五种颜色标识: 原色: 没有overdraw 蓝色: 1次overdraw 绿色: 2次overdraw 粉色: 3次overdraw 红色: 4次及4次以上的overdraw 一般来说, 蓝色是可接受的, 是性能优的. 2.2.2 Overdraw的分析处理上面有言, 所谓Overdraw, 就是在一个像素点上绘制了多次. 常见的就是: 绘制了多重背景. 绘制了不可见的UI元素. 还是以GithubApp这个App的代码为例调试, 打开应用, 展示是这样的: 可以看到是中间列表这块overdraw比较严重. 查看代码发现: fragment_trending_container.xml中ViewPager设置了背景: 12345&lt;android.support.v4.view.ViewPager android:id=\"@+id/view_pager\" android:background=\"@color/md_white_1000\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 而ViewPager中的fragment又设置了背景: 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/refresh_layout\" android:background=\"@color/md_white_1000\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; ...&lt;/android.support.v4.widget.SwipeRefreshLayout 完整代码请查看Github上源码, 本文分析时commit截止到b01b5793. 删除外层ViewPager的背景再看: 可以发现中间列表区域已经不再是红色了, 但是也没有达到蓝色这个可以接受的层级. 这是因为我们的Activity默认情况下, theme会给window设置一个纯色的背景. 因为我们这里不想使用这个默认的背景,故而给layout加了一层背景, 导致了多重绘制背景. 当然我们也可以自定义主题, 将theme的window background设置成我们想要的, 而不在布局中设置. 可以通过如下方式去掉window的背景. 设置主题: 1&lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt; 或是代码设置, 在onCreate中: 1getWindow().setBackgroundDrawable(null); 此时我们看到的效果: 已基本达到优化水平. 以上旨在提供分析方法和思路.Overdraw主要原因是背景的多重绘制, 或是不可见的View在背后绘制等, 但不仅限于此. 2.3 UI线程的复杂运算如上文ANR相关分析中就说到UI线程的复杂运算会造成UI无响应, 当然更多的是造成UI响应停滞, 卡顿. 产生ANR已经是卡顿的极致了, 具体分析可以参看App优化之ANR详解一文. 关于运算阻塞导致的卡顿的分析, 可以使用Traceview这个工具.具体Traceview的介绍, 以及实战分析, 可以参考App优化之提升你的App启动速度之理论基础和App优化之提升你的App启动速度之实例挑战. 在这里需要提下我们在性能分析工具中提到的StrictMode. 2.3.1 StrictMode的使用StrictMode用来基于线程或VM设置一些策略, 一旦检测到策略违例, 控制台将输出一些警告，包含一个trace信息展示你的应用在何处出现问题. 通常用来检测主线程中的磁盘读写或网络访问等耗时操作. 在Application或是Activity的onCreate中开启StrictMode: 1234567891011121314151617181920public void onCreate() &#123; if (BuildConfig.DEBUG) &#123; // 针对线程的相关策略 StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectDiskReads() .detectDiskWrites() .detectNetwork() // or .detectAll() for all detectable problems .penaltyLog() .build()); // 针对VM的相关策略 StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectLeakedSqlLiteObjects() .detectLeakedClosableObjects() .penaltyLog() .penaltyDeath() .build()); &#125; super.onCreate();&#125; 如果你的线程出了问题, 控制台会有警告输出, 可以定位到代码.相对简单, 在此就不多废话了.解决UI线程的耗时操作方案, 可以参考ANR详解里面说到的那些线程模式. 2.4 频繁的GC上面说的都是处理上的, CPU, GPU相关的. 实际上内存原因也可能会造成应用不流畅, 卡顿的. 说到这, 想起当年配台式机的三大件(CPU, 内存, 显示器)了. 貌似分析App性能也是这几大件啊 :) 为什么说频繁的GC会导致卡顿呢?简而言之, 就是执行GC操作的时候，任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行, 故而如果程序频繁GC, 自然会导致界面卡顿. 以下内容参考自Android Performance Patterns:Memory Churn and Performance. 需翻墙 导致频繁GC有两个原因: 内存抖动(Memory Churn), 即大量的对象被创建又在短时间内马上被释放. 瞬间产生大量的对象会严重占用Young Generation的内存区域, 当达到阀值, 剩余空间不够的时候, 也会触发GC. 即使每次分配的对象需要占用很少的内存，但是他们叠加在一起会增加Heap的压力, 从而触发更多的GC. 这些GC操作可能会造成上面说到的丢帧, 如下: 就会让用户感知到卡顿了. 一般来说瞬间大量产生对象一般是因为我们在代码的循环中new对象, 或是在onDraw中创建对象等. 所以说这些地方是我们尤其需要注意的… 关于内存的分析, 我们在后续的内存优化中细聊吧.","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"中秋节大礼, Github重大更新","slug":"pm/github_update_2016-09-15","date":"2016-09-15T15:30:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/09/15/pm/github_update_2016-09-15/","link":"","permalink":"http://blog.lmj.wiki/2016/09/15/pm/github_update_2016-09-15/","excerpt":"引言最近正准备写玩转Github的系列, 大体围绕一个创业小团队使用Github做代码管理甚至项目管理来聊点个人的Github使用心得, 大纲如下:","text":"引言最近正准备写玩转Github的系列, 大体围绕一个创业小团队使用Github做代码管理甚至项目管理来聊点个人的Github使用心得, 大纲如下: 正在写Android App优化系列, 还没有来得及~~恰逢中秋节之际, Github发布了一次重大更新, 引入了新的工具, 恰巧就有Project, CodeReview相关的更新. 大体看了下, CodeReview的体验提升了不少, 直追Gerrit(Gerrit虽然UI丑, 但是真是的好用), 项目管理的引入, 更是完善了仅用milestone和issues跟踪的状态难题, 还可以自定义栏目, 与Teambition类似, 个人认为敏捷小团队非常适用. 在此先无耻的将Github的这次更新搬过来, 作为一个起点吧, 友们轻喷:) 新入Projects今天, 细心的同学可能已经发现了Github工程的tab上多了一项”Projects”, 点击可以创建项目, 如下: 在项目界面可以自定义栏目, 例如我这边: 强大的是, 这些Task Card可以转成Issue, 与Issues模块关联. 还可以直接在页面栏目间拖动来直接改变其状态. CodeReview更新1, 针对代码特定行Review类似于Gerrit, 现在可以在特定的代码位置加上Review意见了: 2, 新增CodeReview的意见标识个人认为类似于Gerrit的+1, -1, +2的模式, 来标识每个提交的code review意见, 是否通过等. Github新增了这个模式, 加入了: Comment 单纯加些检视意见, 并不通过. (类似Gerrit的+1) Approve 提交检视意见并通过. (类似Gerrit的+2) Request changes 提交检视意见, 并要求修改. (类似Gerrit的-1,-2) 3, 新增Protect Branch设置仓库管理员可以设置受保护的分支, 避免没有通过Code Review的代码合入. 在工程的”Settings”界面: 选择相应的分支后: 勾选相应的项, 其中图中标红的即是要求, 该pull request需有至少一个Approved, 且没有Request Changes, 才可以merge到master分支. 如果你的提交有一个Approved和一个Request Changes, 则无法merge: 其他更新除了以上的, Github还更新了很多细节, 包括: Github服务集成更无缝 GraphQL API引入(早期测试版本) Engineering Blog 企业服务更友好 Organization管理员可以为其所有成员请求Two-factor Authentication认证, 以方便管理安全策略. 更多更好的权限控制. 个人界面更社交 个人界面展现更多东西, 例如历史记录. 更具社交属性, 让别人更了解这个程序员:) 以上部分图来自Github官网, Github原文更新说明请点这里或这里","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/tags/Tools/"},{"name":"项目管理","slug":"项目管理","permalink":"http://blog.lmj.wiki/tags/项目管理/"},{"name":"产品","slug":"产品","permalink":"http://blog.lmj.wiki/tags/产品/"},{"name":"Github","slug":"Github","permalink":"http://blog.lmj.wiki/tags/Github/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}]},{"title":"App优化之ANR详解","slug":"app-opti/app_opt_anr","date":"2016-09-06T14:35:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/09/06/app-opti/app_opt_anr/","link":"","permalink":"http://blog.lmj.wiki/2016/09/06/app-opti/app_opt_anr/","excerpt":"引言App优化系列已近中期, 前面分享了一些工具, 理论, 也结合了案例谈了下启动优化, 布局分析等. 原计划将本文作为这个系列的一个承上启下点, 对前面几篇作一个小总结, 聊聊App流畅度和快速响应的话题. 粗一缕, 发现内容还是很多, 暂且拆成几篇来慢慢写吧, 勿怪~ 今天先来聊聊ANR.","text":"引言App优化系列已近中期, 前面分享了一些工具, 理论, 也结合了案例谈了下启动优化, 布局分析等. 原计划将本文作为这个系列的一个承上启下点, 对前面几篇作一个小总结, 聊聊App流畅度和快速响应的话题. 粗一缕, 发现内容还是很多, 暂且拆成几篇来慢慢写吧, 勿怪~ 今天先来聊聊ANR. 1, 你碰到ANR了吗在App使用过程中, 你可能遇到过这样的情况: 恭喜你, 这就是传说中的ANR. 1.1 何为ANRANR全名Application Not Responding, 也就是”应用无响应”. 当操作在一段时间内系统无法处理时, 系统层面会弹出上图那样的ANR对话框. 1.2 为什么会产生ANR在Android里, App的响应能力是由Activity Manager和Window Manager系统服务来监控的. 通常在如下两种情况下会弹出ANR对话框: 5s内无法响应用户输入事件(例如键盘输入, 触摸屏幕等). BroadcastReceiver在10s内无法结束. 造成以上两种情况的首要原因就是在主线程(UI线程)里面做了太多的阻塞耗时操作, 例如文件读写, 数据库读写, 网络查询等等. 1.3 如何避免ANR知道了ANR产生的原因, 那么想要避免ANR, 也就很简单了, 就一条规则: 不要在主线程(UI线程)里面做繁重的操作. 这里面实际上涉及到两个问题: 哪些地方是运行在主线程的? 不在主线程做, 在哪儿做? 稍后解答. 2, ANR分析2.1 获取ANR产生的trace文件ANR产生时, 系统会生成一个traces.txt的文件放在/data/anr/下. 可以通过adb命令将其导出到本地: 1$adb pull data/anr/traces.txt . 2.2 分析traces.txt2.2.1 普通阻塞导致的ANR获取到的tracs.txt文件一般如下: 如下以GithubApp代码为例, 强行sleep thread产生的一个ANR. 1234567891011121314151617181920212223242526272829303132333435----- pid 2976 at 2016-09-08 23:02:47 -----Cmd line: com.anly.githubapp // 最新的ANR发生的进程(包名)...DALVIK THREADS (41):\"main\" prio=5 tid=1 Sleeping | group=\"main\" sCount=1 dsCount=0 obj=0x73467fa8 self=0x7fbf66c95000 | sysTid=2976 nice=0 cgrp=default sched=0/0 handle=0x7fbf6a8953e0 | state=S schedstat=( 0 0 0 ) utm=60 stm=37 core=1 HZ=100 | stack=0x7ffff4ffd000-0x7ffff4fff000 stackSize=8MB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x35fc9e33&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x35fc9e33&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) // 主线程中sleep过长时间, 阻塞导致无响应. at com.tencent.bugly.crashreport.crash.c.l(BUGLY:258) - locked &lt;@addr=0x12dadc70&gt; (a com.tencent.bugly.crashreport.crash.c) at com.tencent.bugly.crashreport.CrashReport.testANRCrash(BUGLY:166) // 产生ANR的那个函数调用 - locked &lt;@addr=0x12d1e840&gt; (a java.lang.Class&lt;com.tencent.bugly.crashreport.CrashReport&gt;) at com.anly.githubapp.common.wrapper.CrashHelper.testAnr(CrashHelper.java:23) at com.anly.githubapp.ui.module.main.MineFragment.onClick(MineFragment.java:80) // ANR的起点 at com.anly.githubapp.ui.module.main.MineFragment_ViewBinding$2.doClick(MineFragment_ViewBinding.java:47) at butterknife.internal.DebouncingOnClickListener.onClick(DebouncingOnClickListener.java:22) at android.view.View.performClick(View.java:4780) at android.view.View$PerformClick.run(View.java:19866) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:135) at android.app.ActivityThread.main(ActivityThread.java:5254) at java.lang.reflect.Method.invoke!(Native method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698) 拿到trace信息, 一切好说.如上trace信息中的添加的中文注释已基本说明了trace文件该怎么分析: 文件最上的即为最新产生的ANR的trace信息. 前面两行表明ANR发生的进程pid, 时间, 以及进程名字(包名). 寻找我们的代码点, 然后往前推, 看方法调用栈, 追溯到问题产生的根源. 以上的ANR trace是属于相对简单, 还有可能你并没有在主线程中做过于耗时的操作, 然而还是ANR了. 这就有可能是如下两种情况了: 2.2.2 CPU满负荷这个时候你看到的trace信息可能会包含这样的信息: 123456789Process:com.anly.githubapp...CPU usage from 3330ms to 814ms ago:6% 178/system_server: 3.5% user + 1.4% kernel / faults: 86 minor 20 major4.6% 2976/com.anly.githubapp: 0.7% user + 3.7% kernel /faults: 52 minor 19 major0.9% 252/com.android.systemui: 0.9% user + 0% kernel...100%TOTAL: 5.9% user + 4.1% kernel + 89% iowait 最后一句表明了: 当是CPU占用100%, 满负荷了. 其中绝大数是被iowait即I/O操作占用了. 此时分析方法调用栈, 一般来说会发现是方法中有频繁的文件读写或是数据库读写操作放在主线程来做了. 2.2.3 内存原因其实内存原因有可能会导致ANR, 例如如果由于内存泄露, App可使用内存所剩无几, 我们点击按钮启动一个大图片作为背景的activity, 就可能会产生ANR, 这时trace信息可能是这样的: 1234567891011121314151617181920// 以下trace信息来自网络, 用来做个示例Cmdline: android.process.acoreDALVIK THREADS:&quot;main&quot;prio=5 tid=3 VMWAIT|group=&quot;main&quot; sCount=1 dsCount=0 s=N obj=0x40026240self=0xbda8| sysTid=1815 nice=0 sched=0/0 cgrp=unknownhandle=-1344001376atdalvik.system.VMRuntime.trackExternalAllocation(NativeMethod)atandroid.graphics.Bitmap.nativeCreate(Native Method)atandroid.graphics.Bitmap.createBitmap(Bitmap.java:468)atandroid.view.View.buildDrawingCache(View.java:6324)atandroid.view.View.getDrawingCache(View.java:6178)...MEMINFO in pid 1360 [android.process.acore] **native dalvik other totalsize: 17036 23111 N/A 40147allocated: 16484 20675 N/A 37159free: 296 2436 N/A 2732 可以看到free的内存已所剩无几. 当然这种情况可能更多的是会产生OOM的异常… 2.2 ANR的处理针对三种不同的情况, 一般的处理情况如下 主线程阻塞的 开辟单独的子线程来处理耗时阻塞事务. CPU满负荷, I/O阻塞的 I/O阻塞一般来说就是文件读写或数据库操作执行在主线程了, 也可以通过开辟子线程的方式异步执行. 内存不够用的 增大VM内存, 使用largeHeap属性, 排查内存泄露(这个在内存优化那篇细说吧)等. 3, 深入一点没有人愿意在出问题之后去解决问题.高手和新手的区别是, 高手知道怎么在一开始就避免问题的发生. 那么针对ANR这个问题, 我们需要做哪些层次的工作来避免其发生呢? 3.1 哪些地方是执行在主线程的 Activity的所有生命周期回调都是执行在主线程的. Service默认是执行在主线程的. BroadcastReceiver的onReceive回调是执行在主线程的. 没有使用子线程的looper的Handler的handleMessage, post(Runnable)是执行在主线程的. AsyncTask的回调中除了doInBackground, 其他都是执行在主线程的. View的post(Runnable)是执行在主线程的. 3.2 使用子线程的方式有哪些上面我们几乎一直在说, 避免ANR的方法就是在子线程中执行耗时阻塞操作. 那么在Android中有哪些方式可以让我们实现这一点呢. 3.2.1 启Thread方式这个其实也是Java实现多线程的方式. 有两种实现方法, 继承Thread 或 实现Runnable接口: 继承Thread 1234567891011121314class PrimeThread extends Thread &#123; long minPrime; PrimeThread(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125;&#125;PrimeThread p = new PrimeThread(143);p.start(); 实现Runnable接口 1234567891011121314class PrimeRun implements Runnable &#123; long minPrime; PrimeRun(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125;&#125;PrimeRun p = new PrimeRun(143);new Thread(p).start(); 3.2.2 使用AsyncTask这个是Android特有的方式, AsyncTask顾名思义, 就是异步任务的意思. 123456789101112131415161718192021222324252627282930private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; &#123; // Do the long-running work in here // 执行在子线程 protected Long doInBackground(URL... urls) &#123; int count = urls.length; long totalSize = 0; for (int i = 0; i &lt; count; i++) &#123; totalSize += Downloader.downloadFile(urls[i]); publishProgress((int) ((i / (float) count) * 100)); // Escape early if cancel() is called if (isCancelled()) break; &#125; return totalSize; &#125; // This is called each time you call publishProgress() // 执行在主线程 protected void onProgressUpdate(Integer... progress) &#123; setProgressPercent(progress[0]); &#125; // This is called when doInBackground() is finished // 执行在主线程 protected void onPostExecute(Long result) &#123; showNotification(\"Downloaded \" + result + \" bytes\"); &#125;&#125;// 启动方式new DownloadFilesTask().execute(url1, url2, url3); 3.2.3 HandlerThreadAndroid中结合Handler和Thread的一种方式. 前面有云, 默认情况下Handler的handleMessage是执行在主线程的, 但是如果我给这个Handler传入了子线程的looper, handleMessage就会执行在这个子线程中的. HandlerThread正是这样的一个结合体: 12345678910111213141516171819// 启动一个名为new_thread的子线程HandlerThread thread = new HandlerThread(\"new_thread\");thread.start();// 取new_thread赋值给ServiceHandlerprivate ServiceHandler mServiceHandler;mServiceLooper = thread.getLooper();mServiceHandler = new ServiceHandler(mServiceLooper);private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // 此时handleMessage是运行在new_thread这个子线程中了. &#125;&#125; 3.2.4 IntentServiceService是运行在主线程的, 然而IntentService是运行在子线程的.实际上IntentService就是实现了一个HandlerThread + ServiceHandler的模式. 以上HandlerThread的使用代码示例也就来自于IntentService源码. 3.2.5 LoaderAndroid 3.0引入的数据加载器, 可以在Activity/Fragment中使用. 支持异步加载数据, 并可监控数据源在数据发生变化时传递新结果. 常用的有CursorLoader, 用来加载数据库数据. 1234567891011121314151617181920212223242526272829303132333435363738// Prepare the loader. Either re-connect with an existing one,// or start a new one.// 使用LoaderManager来初始化LoadergetLoaderManager().initLoader(0, null, this);//如果 ID 指定的加载器已存在，则将重复使用上次创建的加载器。//如果 ID 指定的加载器不存在，则 initLoader() 将触发 LoaderManager.LoaderCallbacks 方法 //onCreateLoader()。在此方法中，您可以实现代码以实例化并返回新加载器// 创建一个Loaderpublic Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) &#123; // This is called when a new Loader needs to be created. This // sample only has one Loader, so we don't care about the ID. // First, pick the base URI to use depending on whether we are // currently filtering. Uri baseUri; if (mCurFilter != null) &#123; baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI, Uri.encode(mCurFilter)); &#125; else &#123; baseUri = Contacts.CONTENT_URI; &#125; // Now create and return a CursorLoader that will take care of // creating a Cursor for the data being displayed. String select = \"((\" + Contacts.DISPLAY_NAME + \" NOTNULL) AND (\" + Contacts.HAS_PHONE_NUMBER + \"=1) AND (\" + Contacts.DISPLAY_NAME + \" != '' ))\"; return new CursorLoader(getActivity(), baseUri, CONTACTS_SUMMARY_PROJECTION, select, null, Contacts.DISPLAY_NAME + \" COLLATE LOCALIZED ASC\");&#125;// 加载完成public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) &#123; // Swap the new cursor in. (The framework will take care of closing the // old cursor once we return.) mAdapter.swapCursor(data);&#125; 具体请参看官网Loader介绍. 3.2.6 特别注意使用Thread和HandlerThread时, 为了使效果更好, 建议设置Thread的优先级偏低一点: 1Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND); 因为如果没有做任何优先级设置的话, 你创建的Thread默认和UI Thread是具有同样的优先级的, 你懂的. 同样的优先级的Thread, CPU调度上还是可能会阻塞掉你的UI Thread, 导致ANR的. 结语对于ANR问题, 个人认为还是预防为主, 认清代码中的阻塞点, 善用线程. 同时形成良好的编程习惯, 要有MainThread和Worker Thread的概念的…(实际上人的工作状态也是这样的~~哈哈) 强行插入一波:之前发的打造一款开源的Android平台的Github客户端的这个客户端有了自己的名字了, 叫做CoderPub.另外, 我也启用了weibo账户anly-jun, 欢迎互粉.","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"App优化之Layout怎么摆","slug":"app-opti/app_opt_layout","date":"2016-09-01T14:05:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/09/01/app-opti/app_opt_layout/","link":"","permalink":"http://blog.lmj.wiki/2016/09/01/app-opti/app_opt_layout/","excerpt":"优化完App的启动速度, 接下来我们要关注的就是UI布局怎么更高效了. 欲善其事, 先利其器. 分析布局, 就不得不用到Hierarchy Viewer了.","text":"优化完App的启动速度, 接下来我们要关注的就是UI布局怎么更高效了. 欲善其事, 先利其器. 分析布局, 就不得不用到Hierarchy Viewer了. 本文工具使用皆以GithubApp的详情界面RepoDetailActivity为例说明.为了不影响阅读体验, 对应的布局文件activity_repo_detail.xml的代码放在文末 1, Hierarchy Viewer怎么用 Hierarchy发音 [美: ‘haɪərɑrki] [英: ‘haɪərɑːkɪ] 层次结构的意思.之前一直念不顺这个单词Hierarchy, 就简称为H Viewer了. 下文就这么简称吧. 如官网描述, H Viewer是用来分析调试和优化我们的UI的一个图形化工具. 它会展示当前界面的View层级. 1.1 启用H Viewer比较早接触Android开发的同学可能知道, H Viewer只能在root过的机器才能使用. 主要是在没有root过的机器中view server这个服务是没有开启的. H Viewer就无法连接到机器获取view层级信息. 正所谓高手在民间, 大家都尝试在未root的机器中启用view server来使用H Viewer. 最具代表性的就是romainguy的ViewServer, 只需集成少量代码到你的Activity, 相当于在手机端开启了view server服务, 建立socket通道与PC端的H Viewer通信. 此工程被Android官网吸收, 作为开启H View的方案之一. 完整开启H Viewer的套路如下: 手机开启开发者模式, USB调试. 根据手机的Android系统版本: 4.0及以下, 没有root. 使用上述的开源工程ViewServer提供的方式. 4.0及以下, 已经root. 无需其他额外设置. 4.1及以上. 需要在PC端设置ANDROID_HVPROTO环境变量. 设置系统环境变量: ANDROID_HVPROTO, 值为ddm具体设置系统环境变量根据PC系统不同而异. 做完上述配置后, 你就可以打开H Viewer了, 打开DDMS, 如下操作进入H Viewer界面: 1.2 H Viewer界面详解以GithubApp的详情界面RepoDetailActivity为例说明: 界面分为四个部分: Window 显示当前连接的设备和供分析的界面. 可手动选择. Tree View 树状图的形式展示该Activity中的View层级结构. 可以放大缩小, 每个节点代表一个View, 点击可以弹出其属性, 当前值, 并且在LayoutView中会显示其在界面中相应位置. Tree View是我们主要要分析的视图. Tree Overview Tree View的概览图. 有一个选择框, 可以拖动选择查看. 选中的部分会在Tree View中显示. Layout View 匹配手机屏幕的视图, 按照View的实际显示位置展示出来的框图. 1.3 H Viewer参数解读 通过Tree View可以很直观的看到View的层级. 点击Tree View的RepoItemView这个节点: 关于三个小圆点的性能指示, 在App优化之性能分析工具一文中有提到, 再强调一遍: 三个小圆点, 依次表示Measure, Layout, Draw, 可以理解为对应View的onMeasure, onLayout, onDraw三个方法. 绿色, 表示该View的此项性能比该View Tree中超过50%的View都要快. 黄色, 表示该View的此项性能比该View Tree中超过50%的View都要慢. 红色, 表示该View的此项性能是View Tree中最慢的. 如果你的界面的Tree View中红点较多, 那就需要注意了. 一般来说: 1, Measure红点, 可能是布局中嵌套RelativeLayout, 或是嵌套LinearLayout都使用了weight属性.2, Layout红点, 可能是布局层级太深.3, Draw红点, 可能是自定义View的绘制有问题, 复杂计算等. 由上图, 可以看到我们的RepoItemView的三项指标都不合格, 证明其还有很多优化空间. 层级, 绘制都可以优化. 除了用H Viewer来做代码后分析, Android还提供了Lint, 在我们编写xml布局文件时就即时的给出一些相关提示. 2, Lint tool打开RepoDetailActivity的布局文件activity_repo_detail.xml, 在Android Studio菜单栏中开启Lint检查: 选择当前文件: 会在下方弹出分析结果: 分析结果包括用法检测(例如版本特有属性), 国际化(字符串是否提取到strings.xml, Rlt支持等), 以及我们今天的主题—性能分析结果. 点开”Android -&gt; Lint -&gt; Performance”项, 可以看到关于布局性能的建议项. 此例中是说ScrollView的父级LinearLayout是不必要的. 3, 怎么优化你的布局通过以上工具的使用和分析, 也基本能找到布局的一些常见的好与不好的了. 正所谓授之以鱼不如授之以渔. 在此也就不太详细去讲怎么优化了, 几点建议, 大家自行实践吧:) 尽量减少布局层级和复杂度 尽量不要嵌套使用RelativeLayout. 尽量不要在嵌套的LinearLayout中都使用weight属性. Layout的选择, 以尽量减少View树的层级为主. 去除不必要的父布局. 善用TextView的Drawable减少布局层级. 如果H Viewer查看层级超过5层, 你就需要考虑优化下布局了~ 善用Tag 使用include来重用布局. 使用来解决include或自定义组合ViewGroup导致的冗余层级问题. 例如本例中的RepoItemView的布局文件实际可以用一个标签来减少一级. ListView优化 contentView复用 引入holder来避免重复的findViewById. 分页加载 4, 附示例代码因github上的源码会持续更新, 特留对应代码在此. activity_repo_detail.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout android:id=\"@+id/root_layout\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/md_white_1000\" android:orientation=\"vertical\" android:padding=\"@dimen/dimen_10\"&gt; &lt;ScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fillViewport=\"true\" android:scrollbars=\"none\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;com.anly.githubapp.ui.widget.RepoItemView android:id=\"@+id/repo_item_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/md_grey_300\" android:elevation=\"@dimen/dimen_2\"/&gt; &lt;LinearLayout android:id=\"@+id/contributor_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"@dimen/dimen_10\" android:orientation=\"vertical\" &gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_40\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\" android:background=\"@drawable/button_bg\" android:paddingLeft=\"@dimen/dimen_10\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:gravity=\"center_vertical\" android:text=\"&#123;oct-organization&#125; Contributors\"/&gt; &lt;TextView android:id=\"@+id/contributors_count\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_40\" android:gravity=\"center_vertical\"/&gt; &lt;/LinearLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/contributor_list\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_60\" android:layout_marginTop=\"@dimen/dimen_2\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/fork_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"@dimen/dimen_10\" android:orientation=\"vertical\" &gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_40\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\" android:background=\"@drawable/button_bg\" android:paddingLeft=\"@dimen/dimen_10\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:gravity=\"center_vertical\" android:text=\"&#123;oct-gist_fork&#125; Forks\"/&gt; &lt;TextView android:id=\"@+id/forks_count\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_40\" android:gravity=\"center_vertical\"/&gt; &lt;/LinearLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/fork_list\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_60\" android:layout_marginTop=\"@dimen/dimen_2\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/code_layout\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_40\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\" android:layout_marginTop=\"@dimen/dimen_10\" android:background=\"@drawable/button_bg\" android:paddingLeft=\"@dimen/dimen_10\"&gt; &lt;TextView android:id=\"@+id/code_label\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_40\" android:gravity=\"center_vertical\" android:text=\"&#123;oct-file_code&#125; Code\"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/readme_layout\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_40\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\" android:layout_marginTop=\"@dimen/dimen_10\" android:background=\"@drawable/button_bg\" android:paddingLeft=\"@dimen/dimen_10\"&gt; &lt;TextView android:id=\"@+id/readme_label\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_40\" android:gravity=\"center_vertical\" android:text=\"&#123;oct-info&#125; README\"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; com.anly.githubapp.ui.widget.RepoItemView对应的布局: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" &gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:padding=\"@dimen/dimen_10\"&gt; &lt;TextView android:id=\"@+id/name\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"left|center_vertical\" android:maxLines=\"1\" android:text=\"@string/app_name\" android:textColor=\"@android:color/black\" android:textSize=\"@dimen/text_size_18\"/&gt; &lt;TextView android:id=\"@+id/desc\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"left|center_vertical\" android:maxLines=\"2\" android:text=\"@string/app_name\" android:textColor=\"@android:color/darker_gray\" android:textSize=\"@dimen/text_size_12\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"@dimen/dimen_5\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"@dimen/dimen_32\" android:layout_height=\"@dimen/dimen_32\" android:scaleType=\"centerInside\" android:src=\"@mipmap/ic_launcher\" android:visibility=\"visible\"/&gt; &lt;TextView android:id=\"@+id/owner\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"@dimen/dimen_10\" android:gravity=\"left|center_vertical\" android:text=\"@string/app_name\" android:textColor=\"@android:color/black\" android:textSize=\"@dimen/text_size_14\"/&gt; &lt;/LinearLayout&gt; &lt;View android:layout_marginTop=\"@dimen/dimen_5\" android:layout_width=\"match_parent\" android:layout_height=\"1px\" android:background=\"@color/grey\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dimen_32\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\" android:paddingTop=\"@dimen/dimen_10\"&gt; &lt;TextView android:id=\"@+id/update_time\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:gravity=\"left|center_vertical\" android:text=\"@string/app_name\" android:textColor=\"@android:color/black\" android:textSize=\"@dimen/text_size_12\" /&gt; &lt;View android:layout_width=\"1px\" android:layout_height=\"match_parent\" android:background=\"@color/grey\"/&gt; &lt;LinearLayout android:id=\"@+id/star_view\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:gravity=\"center\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/star_icon\" android:layout_width=\"@dimen/dimen_16\" android:layout_height=\"@dimen/dimen_16\" android:scaleType=\"centerInside\" android:src=\"@drawable/ic_star\"/&gt; &lt;TextView android:id=\"@+id/star\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"@dimen/dimen_5\" android:gravity=\"center\" android:text=\"@string/app_name\" android:textColor=\"@android:color/black\" android:textSize=\"@dimen/text_size_12\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;com.flyco.labelview.LabelView android:id=\"@+id/label_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"right\" app:lv_background_color=\"@color/md_yellow_500\" app:lv_gravity=\"TOP_RIGHT\" app:lv_text=\"TEST\" app:lv_text_size=\"@dimen/text_size_12\"/&gt;&lt;/FrameLayout&gt; 优化不同于做功能, 可能分析的多, 出的成果少~ 比较枯燥, 然而优化也是App发展的必经之路, 欢迎大家分享经验.","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"App优化之提升你的App启动速度之实例挑战","slug":"app-opti/app_opt_app_startup2","date":"2016-08-29T14:48:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/08/29/app-opti/app_opt_app_startup2/","link":"","permalink":"http://blog.lmj.wiki/2016/08/29/app-opti/app_opt_app_startup2/","excerpt":"1, 代码分析以之前写的Github App为例. 因为这个App集成了Bugly, Push, Feedback等服务, 所以Application的onCreate有很多第三方平台的初始化工作…","text":"1, 代码分析以之前写的Github App为例. 因为这个App集成了Bugly, Push, Feedback等服务, 所以Application的onCreate有很多第三方平台的初始化工作… 123456789101112131415161718192021222324252627282930public class GithubApplication extends MultiDexApplication &#123; @Override public void onCreate() &#123; super.onCreate(); // init logger. AppLog.init(); // init crash helper CrashHelper.init(this); // init Push PushPlatform.init(this); // init Feedback FeedbackPlatform.init(this); // init Share SharePlatform.init(this); // init Drawer image loader DrawerImageLoader.init(new AbstractDrawerImageLoader() &#123; @Override public void set(ImageView imageView, Uri uri, Drawable placeholder) &#123; ImageLoader.loadWithCircle(GithubApplication.this, uri, imageView); &#125; &#125;); &#125;&#125; 当前冷启动效果: 可以看到启动时白屏了很长时间. 2, Traceview上场接下来我们结合我们上文的理论知识, 和介绍的Traceview工具, 来分析下Application的onCreate耗时. 在onCreate开始和结尾打上trace.123Debug.startMethodTracing(\"GithubApp\");...Debug.stopMethodTracing(); 运行程序, 会在sdcard上生成一个”GithubApp.trace”的文件. 注意: 需要给程序加上写存储的权限: 1&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; 通过adb pull将其导出到本地1adb pull /sdcard/GithubApp.trace ~/temp 广告: adb的众多用法, 可以参考我的另一篇文 打开DDMS分析trace文件 分析trace文件 在下方的方法区点击”Real Time/Call”, 按照方法每次调用耗时降序排. 耗时超过500ms都是值得注意的. 看左边的方法名, 可以看到耗时大户就是我们用的几大平台的初始化方法, 特别是Bugly, 还加载native的lib, 用ZipFile操作等. 点击每个方法, 可以看到其父方法(调用它的)和它的所有子方法(它调用的). 点击方法时, 上方的该方法执行时间轴会闪动, 可以看该方法的执行线程及相对时长. 3, 调整Application onCreate再试既然已经知道了哪些地方耗时长, 我们不妨调整下Application的onCreate实现, 一般来说我们可以将这些初始化放在一个单独的线程中处理, 为了方便今后管理, 这里我用了一个InitializeService的IntentService来做初始化工作. 明确一点, IntentService不同于Service, 它是工作在后台线程的. InitializeService.java代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.anly.githubapp.compz.service;import android.app.IntentService;import android.content.Context;import android.content.Intent;import android.graphics.drawable.Drawable;import android.net.Uri;import android.widget.ImageView;import com.anly.githubapp.common.wrapper.AppLog;import com.anly.githubapp.common.wrapper.CrashHelper;import com.anly.githubapp.common.wrapper.FeedbackPlatform;import com.anly.githubapp.common.wrapper.ImageLoader;import com.anly.githubapp.common.wrapper.PushPlatform;import com.anly.githubapp.common.wrapper.SharePlatform;import com.mikepenz.materialdrawer.util.AbstractDrawerImageLoader;import com.mikepenz.materialdrawer.util.DrawerImageLoader;/** * Created by mingjun on 16/8/25. */public class InitializeService extends IntentService &#123; private static final String ACTION_INIT_WHEN_APP_CREATE = \"com.anly.githubapp.service.action.INIT\"; public InitializeService() &#123; super(\"InitializeService\"); &#125; public static void start(Context context) &#123; Intent intent = new Intent(context, InitializeService.class); intent.setAction(ACTION_INIT_WHEN_APP_CREATE); context.startService(intent); &#125; @Override protected void onHandleIntent(Intent intent) &#123; if (intent != null) &#123; final String action = intent.getAction(); if (ACTION_INIT_WHEN_APP_CREATE.equals(action)) &#123; performInit(); &#125; &#125; &#125; private void performInit() &#123; AppLog.d(\"performInit begin:\" + System.currentTimeMillis()); // init Drawer image loader DrawerImageLoader.init(new AbstractDrawerImageLoader() &#123; @Override public void set(ImageView imageView, Uri uri, Drawable placeholder) &#123; ImageLoader.loadWithCircle(getApplicationContext(), uri, imageView); &#125; &#125;); // init crash helper CrashHelper.init(this.getApplicationContext()); // init Push PushPlatform.init(this.getApplicationContext()); // init Feedback FeedbackPlatform.init(this.getApplication()); // init Share SharePlatform.init(this.getApplicationContext()); AppLog.d(\"performInit end:\" + System.currentTimeMillis()); &#125;&#125; GithubApplication的onCreate改成: 123456789101112public class GithubApplication extends MultiDexApplication &#123; @Override public void onCreate() &#123; super.onCreate(); // init logger. AppLog.init(); InitializeService.start(this); &#125;&#125; 看看现在的效果: 可以看到提升了很多, 然后还有一点瑕疵, 就是起来的时候会有一个白屏, 如果手机较慢的话, 这个白屏就会持续一段时间, 不太友好. 那么还有没有什么办法优化呢? 4, 给我们的应用窗口弄一个PlaceHolderAndroid最新的Material Design有这么个建议的. 建议我们使用一个placeholder UI来展示给用户直至App加载完毕. 怎么做呢? 给Window加上背景如第3节所言, 当App没有完全起来时, 屏幕会一直显示一块空白的窗口(一般来说是黑屏或者白屏, 根据App主题). 前文理论基础有说到, 这个空白的窗口展示跟主题相关, 那么我们是不是可以从首屏的主题入手呢? 恰好有一个windowBackground的主题属性, 我们来给Splash界面加上一个主题, 带上我们想要展示的背景. 做一个logo_splash的背景: 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 底层白色 --&gt; &lt;item android:drawable=\"@color/white\" /&gt; &lt;!-- 顶层Logo居中 --&gt; &lt;item&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@drawable/ic_github\" /&gt; &lt;/item&gt;&lt;/layer-list&gt; 弄一个主题: 123&lt;style name=\"SplashTheme\" parent=\"AppTheme\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/logo_splash&lt;/item&gt;&lt;/style&gt; 将一个什么不渲染布局的Activity作为启动屏写一个什么都不做的LogoSplashActivity. 123456789101112131415161718public class LogoSplashActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 注意, 这里并没有setContentView, 单纯只是用来跳转到相应的Activity. // 目的是减少首屏渲染 if (AppPref.isFirstRunning(this)) &#123; IntroduceActivity.launch(this); &#125; else &#123; MainActivity.launch(this); &#125; finish(); &#125;&#125; 在AndroidManifest.xml中设置其为启动屏, 并加上主题: 123456789&lt;activity android:name=\".ui.module.main.LogoSplashActivity\" android:screenOrientation=\"portrait\" android:theme=\"@style/SplashTheme\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 5, 最终的效果让我们来看下最终的效果: 相比之前, 呈现给用户的不再是一个白屏了, 带上了logo, 当然这个背景要显示什么, 我们可以根据实际情况来自定义. 这种优化, 对于有些Application内的初始化工作不能移到子线程做的情况, 是非常友好的. 可以避免我们的App长时间的呈现给用户一个空白的窗口. 6, 结语照例, 总结下.这次关于App启动时间的优化, 写了两篇. 写这么多, 还是想传达下个人做技术的思想, 也算是个人的经验回顾, 抛砖引玉. 实际场景可能远比这个复杂，在此更多的提供一种分析思路～欢迎扩展 矫情了, 还是总结下本文相关的吧: Application的onCreate中不要做太多事情. 首屏Activity尽量简化. 善用工具分析. 多阅读官方文档, 很多地方貌似无关, 实际有关联, 例如这次就用了Material Design文档中的解决方案. 本文完整源码, 请移步Github","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"App优化之提升你的App启动速度之理论基础","slug":"app-opti/app_opt_app_startup1","date":"2016-08-26T14:48:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/08/26/app-opti/app_opt_app_startup1/","link":"","permalink":"http://blog.lmj.wiki/2016/08/26/app-opti/app_opt_app_startup1/","excerpt":"1, 欲善其事, 先利其器论语有云: 工欲善其事，必先利其器. 要想提升App的启动速度, 我们需要先找到拖后腿的点, 要想找到这些点, 我们就需要借助我们的工具了. 前文提到了很多工具, 今天我们使用Traceview来分析我们的启动过程.","text":"1, 欲善其事, 先利其器论语有云: 工欲善其事，必先利其器. 要想提升App的启动速度, 我们需要先找到拖后腿的点, 要想找到这些点, 我们就需要借助我们的工具了. 前文提到了很多工具, 今天我们使用Traceview来分析我们的启动过程. 1.1 Traceview介绍Traceview是一个性能分析工具, 主要是分析当前线程情况, 各个方法执行时间等. 如下: 指标说明: Incl(Inclusive) Cpu Time 方法本身和其调用的所有子方法占用CPU时间. Excl(Exclusive) Cpu Time 方法本身占用CPU时间. Incl Real Time 方法(包含子方法)开始到结束用时. Excl Real Time 方法本身开始到结束用时. Call + Recursion Calls/Total 方法被调用次数 + 方法被递归调用次数. Cpu Time/Call 方法调用一次占用CPU时间. Real Time/Call 方法调用一次实际执行时间. 一般来说, 我们使用Real Time/Call排序来找出耗时多的方法 有必要解释下CPU Time和Real Time:CPU Time 方法实际执行时间(不包括io等待时间)Real Time 方法开始结束时间差(包括等待时间)参考:http://stackoverflow.com/questions/15760447/what-is-the-meaning-of-incl-cpu-time-excl-cpu-time-incl-real-cpu-time-excl-re/17902682#17902682 1.2 Traceview使用有两种方式来使用Traceview:1, 通过DDMS: 点击开始时会弹出一个选择trace模式的框, 默认选中”Sample based profiling”即可: Sample based profiling(基于样本分析)根据采样时间间隔来规律的打断VM来记录方法调用栈(Call Stack), 开销和采样频率成比例. Trace based profiling(基于完整trace数据分析)记录每个方法的出入口, 每个方法执行时都开启记录, 无论多小的方法, 因此开销很大. 2, 使用代码: 12345// 在自己想要开始调试的地方startDebug.startMethodTracing(\"GithubApp\");// 在合适的地方stopDebug.stopMethodTracing(); 注: 以上方法开启trace的方式相当于”Trace based profiling”, 会记录每个方法的执行. Android 4.4及以上可以调用startMethodTracingSampling()来用代码开启”Sample based profiling”的trace方式. 2, App启动流程分析要想优化App启动流程, 必先了解其启动过程.具体过程请参看这篇译文: Android Application启动流程分析. 3, App启动方式通常来说, 一个App启动也会分如下三中不同的状态: 冷启动App没有启动过或App进程被killed, 系统中不存在该App进程, 此时启动App即为冷启动.冷启动的流程即为第2节所描述的App启动流程的全过程, 需要创建App进程, 加载相关资源, 启动Main Thread, 初始化首屏Activity等. 在这个过程中, 屏幕会显示一个空白的窗口(颜色基于主题), 直至首屏Activity完全启动. 下图展示了冷启动的时间线: 热启动 热启动意味着你的App进程只是处于后台, 系统只是将其从后台带到前台, 展示给用户. 类同与冷启动, 在这个过程中, 屏幕会显示一个空白的窗口(颜色基于主题), 直至activity渲染完毕. 温启动 介于冷启动和热启动之间, 一般来说在以下两种情况下发生: 用户back退出了App, 然后又启动. App进程可能还在运行, 但是activity需要重建. 用户退出App后, 系统可能由于内存原因将App杀死, 进程和activity都需要重启, 但是可以在onCreate中将被动杀死锁保存的状态(saved instance state)恢复. 通过三种启动状态的相关描述, 可以看出我们要做的启动优化其实就是针对冷启动. 热启动和温启动都相对较快. 4, 哪些地方是App快速启动的敌人根据冷启动的时间图, 可以看出, 对于App来说, 我们可以控制的启动时间线的点无外乎: Application的onCreate 首屏Activity的渲染 而我们现在的App动不动集成了很多第三方服务, 启动时需要检查广告, 注册状态等等一系列接口都是在Application的onCreate或是首屏的onCreate中做的. 很多第三方平台的SDK文档也都是这么建议的. 5, 结语明白了App的启动原理, 也知道了App启动过程中哪些地方容易阻塞, 还知道了用什么工具来分析每个方法的执行时间, 那么接下来就很容易做了. 下一篇将完全以实例的方式来说明App启动优化该怎么分析, 怎么做.请关注系列文~","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"Android adb你真的会用吗?","slug":"android/adb","date":"2016-08-24T15:25:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/08/24/android/adb/","link":"","permalink":"http://blog.lmj.wiki/2016/08/24/android/adb/","excerpt":"引言本文基于Android官方文档, 以及个人工作的使用经验, 总结下adb的常用用法, 备忘.","text":"引言本文基于Android官方文档, 以及个人工作的使用经验, 总结下adb的常用用法, 备忘. 1, adb简介adb全名Andorid Debug Bridge. 顾名思义, 这是一个Debug工具.然而, 为何称之为Bridge呢? 因为adb是一个标准的CS结构的工具, 是要连接开发电脑和你的调试手机的.包含如下几个部分: Client端, 运行在开发机器中, 即你的开发PC机. 用来发送adb命令. Deamon守护进程, 运行在调试设备中, 即的调试手机或模拟器. Server端, 作为一个后台进程运行在开发机器中, 即你的开发PC机. 用来管理PC中的Client端和手机的Deamon之间的通信. 2, 常用用法2.1 adb devices列举当前连接的调试设备 123$ adb devicesList of devices attachedDU2SSE1467010378 device 2.2 adb logcat打印log信息 指令 说明 备注 adb logcat 打印log / adb logcat -c 清除手机的log buffer 有些手机权限控制, 不支持. adb logcat -b 打印指定buffer的log信息 buffer有: main(主log区,默认), events(事件相关的log), radio(射频, telephony相关的log) adb logcat -v 格式化输出log 常用的用adb logcat -v time显示时间 adb logcat -f 输出log到指定文件 2.3 adb install/uninstall安装卸载apk 123456789// 安装apk时指定apk file路径$ adb install ~/Downloads/mobileqq_android.apk[100%] /data/local/tmp/mobileqq_android.apk pkg: /data/local/tmp/mobileqq_android.apkSuccess// 卸载apk时指定包名$ adb uninstall com.tencent.mobileqqSuccess 2.4 adb pull/push调试设备和开发PC之间拷贝文件. 1234567// 拷贝本地文件到调试设备中$ adb push ~/temp/GithubApp.trace /sdcard/[100%] /sdcard/GithubApp.trace// 从调试设备中拷贝文件到本地$ adb pull /sdcard/GithubApp.trace ~/[100%] /sdcard/GithubApp.trace 2.5 adb start/kill-server启动/杀死adb简介中提到的Server端进程. 由于adb并不稳定, 有时候莫名的问题掉线时, 可以先kill-server, 然后start-server来确保Server进程启动. 往往可以解决问题. 2.5 adb shell进入调试设备的shell界面, 此时可以使用调试设备中的很多指令. 下文高阶用法中很多就是. 12$ adb shellshell@hwH60:/ $ 3, 高阶用法3.1 adb connect/disconnect通过wifi进行远程连接手机进行调试的.https://developer.android.com/studio/command-line/adb.html#wireless 需先连上usb模式, 开启远程调试模式:$ adb tcpip 5555 3.2 adb shell amam即activity manager.该命令用来执行一些系统动作, 例如启动指定activity, 结束进程, 发送广播, 更改屏幕属性等. 调试利器. 指令 说明 备注 start 根据intent指向启动Activity Intent可以是显示的指向activity, 也可以是ACTION方式, 并且可以添加flag, data等参数信息. startservice 启动Service 可以添加flag, data等参数信息. broadcast 发送广播 可以添加flag, data等参数信息. monitor 启动一个Crash和ANR的监听器 如有Crash或ANR会在控制台输出相关信息. force-stop 强制停止该包相关的一切 传入package name. kill 杀死该包相关的所有进程 传入package name. kill-all 杀死所有后台进程 display-size WxH 改变显示的分辨率 例如adb shell am display-size 1280x720, 手机可能不支持. display-density 改变显示的density 例如adb shell am display-density 320, 手机可能不支持. 3.3 adb shell pmpm即package manager.用来执行package相关的操作, 例如安装卸载, 查询系统的安装包等. 指令 说明 备注 list packages 列出满足filter条件的所有包 list permissions 列出该Group的所有权限 list features 查看系统支持哪些feature 例如蓝牙, wifi, 摄像头等. install /uninstall 安装卸载 clear 清除应用数据 3.4 adb shell screencap截屏, 比截屏快捷键更加方便快捷. 1234$ adb shell screencap /sdcard/screen.png$ adb pull /sdcard/screen.png ~/temp[100%] /sdcard/screen.png 3.5 adb shell screenrecord录屏, 做demo的话, 可以很方便的用这个命名录制视频, 然后借助工具将其转换成gif图, 超赞. 如下: Android4.4及以上系统可用. 2.5 adb shell dumpsys强大的dump工具, 可以输出很多系统信息. 例如window, activity, task/back stack信息, wifi信息等. 探索Activity之launchMode和探索Activity之启动Intent flag和Affinity就是用adb shell dumpsys activity来输出task信息的. 常用dumpsys: 指令 说明 备注 细分参数 activity 输出app组件相关信息 还可以用细分参数获得单项内容, 下同. 例如adb shell dumpsys activity activities来获取activity task/back stack信息. activites, service, providers, intents, broadcasts, processes alarm 输出当前系统的alarm信息 / / cpuinfo 输出当前的CPU使用情况 / / diskstats 输出当前的磁盘使用状态 / / batterystats 电池使用信息 / / package package相关信息, 相当于pm功能的集合 输出诸如libs, features, packages等信息 / meminfo 输出每个App的内存使用和系统内存状态 可以指定包名, 例如adb shell dumpsys meminfo com.anly.githubapp / window 输出当前窗口相关信息 / policy, animator, tokens, windows","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/tags/Tools/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"[译]Android Application启动流程分析","slug":"android/app_startup","date":"2016-08-23T14:21:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/08/23/android/app_startup/","link":"","permalink":"http://blog.lmj.wiki/2016/08/23/android/app_startup/","excerpt":"[译]Android Application启动流程分析 译者注:原文分成两个部分, 链接如下:http://multi-core-dump.blogspot.com/2010/04/android-application-launch.htmlhttp://multi-core-dump.blogspot.com/2010/04/android-application-launch-part-2.html章节标题由译者加注. 作者曾经在高通的Android性能组工作, 主要工作是优化Android Application的启动时间.","text":"[译]Android Application启动流程分析 译者注:原文分成两个部分, 链接如下:http://multi-core-dump.blogspot.com/2010/04/android-application-launch.htmlhttp://multi-core-dump.blogspot.com/2010/04/android-application-launch-part-2.html章节标题由译者加注. 作者曾经在高通的Android性能组工作, 主要工作是优化Android Application的启动时间. 1, App基础理论要想优化App启动时间, 第一步就是了解App启动进程的工作原理. 有几个基础理论: Android Application与其他移动平台有两个重大不同点: 每个Android App都在一个独立空间里, 意味着其运行在一个单独的进程中, 拥有自己的VM, 被系统分配一个唯一的user ID. Android App由很多不同组件组成, 这些组件还可以启动其他App的组件. 因此, Android App并没有一个类似程序入口的main()方法. Android Application组件包括: Activities: 前台界面, 直接面向User, 提供UI和操作. Services: 后台任务. Broadcast Receivers: 广播接收者. Contexnt Providers: 数据提供者. Android进程与Linux进程一样. 默认情况下, 每个apk运行在自己的Linux进程中. 另外, 默认一个进程里面只有一个线程—主线程. 这个主线程中有一个Looper实例, 通过调用Looper.loop()从Message队列里面取出Message来做相应的处理. 那么, 这个进程何时启动的呢?简单的说, 进程在其需要的时候被启动. 任意时候, 当用户或者其他组件调取你的apk中的任意组件时, 如果你的apk没有运行, 系统会为其创建一个新的进程并启动. 通常, 这个进程会持续运行直到被系统杀死. 关键是: 进程是在被需要的时候才创建的. 举个例子, 如果你点击email中的超链接, 会在浏览器里面打开一个网页. Email App和浏览器App是两个不同的App, 运行在不同的进程中. 这次点击事件促使Android系统去创建了一个新的进程来实例化浏览器的组件. 首先, 让我们快速看下Android启动流程. 与众多基于Linux内核的系统类似, 启动系统时, bootloader启动内核和init进程. init进程分裂出更多名为”daemons(守护进程)”的底层的Linux进程, 诸如android debug deamon, USB deamon等. 这些守护进程处理底层硬件相关的接口. 随后, init进程会启动一个非常有意思的进程—“Zygote”. 顾名思义, 这是一个Android平台的非常基础的进程. 这个进程初始化了第一个VM, 并且预加载了framework和众多App所需要的通用资源. 然后它开启一个Socket接口来监听请求, 根据请求孵化出新的VM来管理新的App进程. 一旦收到新的请求, Zygote会基于自身预先加载的VM来孵化出一个新的VM创建一个新的进程. 启动Zygote之后, init进程会启动runtime进程. Zygote会孵化出一个超级管理进程—System Server. SystemServer会启动所有系统核心服务, 例如Activity Manager Service, 硬件相关的Service等. 到此, 系统准备好启动它的第一个App进程—Home进程了. 2, 启动App流程用户点击Home上的一个App图标, 启动一个应用时: Click事件会调用startActivity(Intent), 会通过Binder IPC机制, 最终调用到ActivityManagerService. 该Service会执行如下操作: 第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息. 指向信息被存储在一个intent对象中. 下面重要的一步是通过grantUriPermissionLocked()方法来验证用户是否有足够的权限去调用该intent对象指向的Activity. 如果有权限, ActivityManagerService会检查并在新的task中启动目标activity. 现在, 是时候检查这个进程的ProcessRecord是否存在了. 如果ProcessRecord是null, ActivityManagerService会创建新的进程来实例化目标activity. 2.1 创建进程ActivityManagerService调用startProcessLocked()方法来创建新的进程, 该方法会通过前面讲到的socket通道传递参数给Zygote进程. Zygote孵化自身, 并调用ZygoteInit.main()方法来实例化ActivityThread对象并最终返回新进程的pid. ActivityThread随后依次调用Looper.prepareLoop()和Looper.loop()来开启消息循环. 流程图如下: 2.2 绑定Application接下来要做的就是将进程和指定的Application绑定起来. 这个是通过上节的ActivityThread对象中调用bindApplication()方法完成的. 该方法发送一个BIND_APPLICATION的消息到消息队列中, 最终通过handleBindApplication()方法处理该消息. 然后调用makeApplication()方法来加载App的classes到内存中. 流程如下: 2.3 启动Activity经过前两个步骤之后, 系统已经拥有了该application的进程. 后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了. 实际调用方法是realStartActivity(), 它会调用application线程对象中的sheduleLaunchActivity()发送一个LAUNCH_ACTIVITY消息到消息队列中, 通过 handleLaunchActivity()来处理该消息. 假设点击的是一个视频浏览的App, 其流程如下:","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"翻译","slug":"翻译","permalink":"http://blog.lmj.wiki/tags/翻译/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"App优化之性能分析工具","slug":"app-opti/app_opt_tools","date":"2016-08-19T15:00:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/08/19/app-opti/app_opt_tools/","link":"","permalink":"http://blog.lmj.wiki/2016/08/19/app-opti/app_opt_tools/","excerpt":"背景:Android App优化, 要怎么做?","text":"背景:Android App优化, 要怎么做? 今天聊下个人比较惯用的一些App性能测试和分析工具, 先上个图: 本文暂不对工具的使用做过多的深入.在后续的具体实例中会具体说明怎么用这些工具来达成分析目的和解决问题的. 1, 官方工具一般来说, 学习一门新的技术, 最应该做的就是阅读其官方文档, 那是最权威的.Android本身给我们提供了很多App性能测试和分析工具, 而且大部分都集成到Android Studio或DDMS中, 非常方便使用. 1.1 StrictMode 说明 顾名思义, “严格模式”, 主要用来限制应用做一些不符合性能规范的事情. 一般用来检测主线程中的耗 时操作和阻塞. 开启StrictMode后, 如果线程中做一些诸如读写文件, 网络访问等操作, 将会在Log console输出一些警告, 警告信息包含Stack Trace来显示哪个地方出了问题. 文档 https://developer.android.com/reference/android/os/StrictMode.html 作用 主要用来做主线程优化分析 1.2 Systrace 说明 Systrace是一个收集和检测时间信息的工具, 它能显示CPU和时间被消耗在哪儿了, 每个进程和线程都在其CPU时间片内做了什么事儿. 而且会指示哪个地方出了问题, 以及给出Fix建议. 其以trace文件(html)的方式记录. 可以直接用Chrome浏览器打开查看. 界面如下: 文档 https://developer.android.com/studio/profile/systrace.html https://developer.android.com/studio/profile/systrace-walkthru.html https://developer.android.com/studio/profile/systrace-commandline.html?hl=fy 作用 作用很多, 个人主要用来分析UI的绘制时间, 结合Hierarchy Viewer来提升UI性能. 也可以用来发现耗时操作. 1.3 Hierarchy Viewer 说明 Hierarchy Viewer提供了一个可视化的界面来观测布局的层级, 让我们可以优化布局层级, 删除多余的不必要的View层级, 提升布局速度. 有必要说明下的是: 上图红框标出的三个点是关键分析数据. 左起依次代表View的Measure, Layout和Draw的性能. 另外颜色表示该View的该项时间指数, 分为: 绿色, 表示该View的此项性能比该View Tree中超过50%的View都要快. 黄色, 表示该View的此项性能比该View Tree中超过50%的View都要慢. 红色, 表示该View的此项性能是View Tree中最慢的. 文档 https://developer.android.com/studio/profile/hierarchy-viewer.html https://developer.android.com/studio/profile/hierarchy-viewer-walkthru.html https://developer.android.com/studio/profile/hierarchy-viewer-setup.html https://developer.android.com/studio/profile/optimize-ui.html#HierarchyViewer 作用 用来做View层级分析, 可以分析出View Tree中的性能阻塞点, 以便对症下药, 提升布局性能. Hierarchy Viewer需要Root的机器(产品机没有开启ViewServer)才可以执行.可以使用第三方的开源的ViewServer来协助我们在未Root的机器上使用Hierarchy Viewer分析. 1.4 TraceView 说明 一个图形化的工具, 用来展示和分析方法的执行时间. 文档 https://developer.android.com/studio/profile/traceview.html https://developer.android.com/studio/profile/traceview-walkthru.html 作用 分析方法调用栈以及其执行时间, 优化方法执行. 1.5 Memory Monitor 说明 内存使用检测器, 可以实时检测当前Application的内存使用和释放等信息, 并以图形化界面展示. 文档 https://developer.android.com/studio/profile/am-memory.html https://developer.android.com/studio/profile/heap-viewer-walkthru.html https://developer.android.com/studio/profile/allocation-tracker-walkthru.html 作用 用来做内存分析, 内存泄露排查的不二之选. 可以结合heap viewer, allocation tracker来分析. 可以导出hprof文件结合第三方的MAT工具分析泄露点. 1.6 Other Monitor 说明 Android Studio的Monitor还提供了其他三个Motinor — CPU, GPU, Network. 文档 https://developer.android.com/studio/profile/am-cpu.html https://developer.android.com/studio/profile/am-gpu.html https://developer.android.com/studio/profile/am-network.html 作用 分别用来跟踪监测CPU,GPU和Network的使用极其变化, 可以作为网络优化, 流量优化和渲染优化等的一个指导. (个人并不常用到~) 1.7 其他Android的开发者模式中也提供了较多的用来监测性能的选项, 可以用下: 2, 第三方工具 以下工具全部开源, 开源万岁… 2.1 Google的Battery Historian 说明 Google出品, 通过Android系统的bugreport文件来做电量使用分析的工具. 文档 https://github.com/google/battery-historian 作用 用来做电量使用分析. 2.2 网易的 说明 针对Android App的CPU, 内存, 网络, 电量等多项综合的测试分析. 文档 https://github.com/NetEase/Emmagee 作用 比官方工具更适合国人使用来做App的整体性能分析. 2.3 Square 说明 Square出品, 必属精品. 类似与App探针的内存泄露监测工具. 文档 https://github.com/square/leakcanary 作用 集成到App中, 用来做内存问题预防最好不过了. 2.4 AndroidDevMetrics 说明 一个library, 用来检测Activity生命周期执行性能, Dagger2注入性能以及帧率性能的工具. 文档 https://github.com/frogermcs/AndroidDevMetrics 作用 如果你的应用使用的Dagger2, 这个就比较必要了. 3, 结语 MAT没有侧重的提, 是因为这个工具在ADT时代比较常用, AS2.0之后, 本身的Memory Monitor越来越强大, 结合日益完善的第三方工具基本上可以完成内存方面的优化了. 欢迎大家分享自己常用的App性能分析工具, 共同学习~","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"Android App优化, 要怎么做?","slug":"app-opti/app_opt","date":"2016-08-18T15:00:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/08/18/app-opti/app_opt/","link":"","permalink":"http://blog.lmj.wiki/2016/08/18/app-opti/app_opt/","excerpt":"开篇最近在做一款上线一年左右的App的优化, 借此机会也好好总结下近几年的关于App优化的东西, 跟大家分享下, 也是作为一个笔记记录下.","text":"开篇最近在做一款上线一年左右的App的优化, 借此机会也好好总结下近几年的关于App优化的东西, 跟大家分享下, 也是作为一个笔记记录下. 今天没有干货 原谅我标题党了, 今天没有干货~~做Android App开发的同学可能都知道, (私以为)适配问题和内存溢出问题可能是伴随整个开发过程的问题了, 而且是随着迭代的进行, 越到后期App的这两个问题可能会越来越突出, 也可能越来越难以处理. 适配问题在此不表(相对还简单些, 只是耗时耗力). 内存溢出问题实际上就是一个内存使用优化的问题. 当然, 我们今天要聊的App优化, 内存优化只是其中一个方面. 那么, 我们常见的App优化会涉及到哪些呢? 一般来说, 有以下几个方面: App启动优化 布局优化 响应优化 内存优化 电池使用优化 网络优化 计划针对上述, 计划整理一个App优化的系列笔记, 敬请期待. 包括: 背景:Android App优化, 要怎么做? Android App优化之性能分析工具 Android App优化之提升你的App启动速度之理论基础 Android App优化之提升你的App启动速度之实例挑战 Android App优化之Layout怎么摆 Android App优化之ANR详解 Android App优化之消除卡顿 Android App优化之内存优化 Android App优化之持久电量 Android App优化之如何高效网络请求 由于当前做的是公司项目, 示例时代码不便使用, 可能会使用之前写了MVP系列中的GtihubApp作为示例. 笔记目前还是零星, 有待整理, 稍安:)","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"App优化","slug":"App优化","permalink":"http://blog.lmj.wiki/tags/App优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"MVP架构实现的Github客户端(4-加入网络缓存)","slug":"mvp/mvp4","date":"2016-08-14T16:29:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/08/15/mvp/mvp4/","link":"","permalink":"http://blog.lmj.wiki/2016/08/15/mvp/mvp4/","excerpt":"系列文章:1-准备工作2-搭建项目框架3-功能实现4-加入网络缓存 经过前面的几项工作, 项目框架和功能开发规范已经差不过出来了. 接下来要做的就说迭代功能, 和完善细节了. 今天我们要做的是给我们的网络请求加入缓存机制. 类似于一般的阅读类App, 缓存机制一般如下: 有网时根据设置的Cache Control时间来判断是使用缓存还是重新做网络请求. 无网络环境下直接使用缓存, 保证阅读体验.","text":"系列文章:1-准备工作2-搭建项目框架3-功能实现4-加入网络缓存 经过前面的几项工作, 项目框架和功能开发规范已经差不过出来了. 接下来要做的就说迭代功能, 和完善细节了. 今天我们要做的是给我们的网络请求加入缓存机制. 类似于一般的阅读类App, 缓存机制一般如下: 有网时根据设置的Cache Control时间来判断是使用缓存还是重新做网络请求. 无网络环境下直接使用缓存, 保证阅读体验. 1, 为什么要加缓存缓存之所以必要, 最重要的是能给用户以良好的体验.另外网络数据缓存也是App网络流量优化, 电量优化的一个必要手段. 2, 好了, 废话还是少说, 直接开始要做到缓存仅需要三步: 请求客户端配置缓存目录. Request中须带有Cache-Control的header, 以便请求时决定是否使用缓存. Response中须带有Cache-Control的header, 以告知Client端该响应是否可以缓存, 以及缓存时效. 2.1 配置OkHttp的缓存目录 设置Cache Dir 12345678910111213private static final long CACHE_SIZE = 1024 * 1024 * 50;@Overridepublic OkHttpClient.Builder customize(OkHttpClient.Builder builder) &#123; // set cache dir File cacheFile = new File(mContext.getCacheDir(), \"github_repo\"); Cache cache = new Cache(cacheFile, CACHE_SIZE); builder.cache(cache); ... return builder;&#125; 2.2 配置Retrofit Request接口的”Cache-Control” Header顾名思义, “Cache-Control”请求头就是用来控制缓存的. 它有一些属性值来指定缓存的属性, 诸如公共属性, 是否可缓存以及缓存的有效期等. 关于”Cache-Control”的详细解释和使用请自行google…在此略过.个人也有计划写一些关于HTTP协议相关的基础知识, 会聊到Cache-Control, 敬请期待. 以获取Github Trending这个接口为例: 123@Headers(\"Cache-Control: public, max-age=180\")@GET(\"trending?languages[]=java&amp;languages[]=swift&amp;languages[]=objective-c&amp;languages[]=bash&amp;languages[]=python&amp;languages[]=html\")Observable&lt;TrendingResultResp&gt; getTrendingRepos(); public 指示响应可被任何缓存区缓存 max-age=180 指示该请求的缓存的有效期为3分钟(以秒为单位). 2.3 配置Response中的”Cache-Control” Header众所周知, Response是由服务器控制的, 我们如何加入”Cache-Control”头呢? 方法有二: 说服服务器的开发人员按照你的需求在response中加入Cache-Control. 使用我们接下来要说的OkHttp的拦截器interceptor. 大多数情况下, 服务器可能并不受我们控制. 服务器开发人员开发多个系统, 对端的缓存需求不熟悉, 又或是服务器接口并不是我们自己开发的, 例如本系列做的这个GithubApp. 所幸, OkHttp提供了interceptor来让我们对request, response进行拦截处理, 加入我们想要的请求头等. 如下是本例使用的Cache Interceptor: 1234567891011121314151617181920212223242526private final Interceptor mCacheControlInterceptor = new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); if (!NetworkUtil.isNetworkAvailable(mContext)) &#123; request = request.newBuilder() .cacheControl(CacheControl.FORCE_CACHE) .build(); &#125; Response originalResponse = chain.proceed(request); if (NetworkUtil.isNetworkAvailable(mContext)) &#123; String cacheControl = request.cacheControl().toString(); return originalResponse.newBuilder() .header(\"Cache-Control\", cacheControl) .build(); &#125; else &#123; return originalResponse.newBuilder() .header(\"Cache-Control\", CacheControl.FORCE_CACHE.toString()) .build(); &#125; &#125;&#125;; 如下拦截器, 做了: 对于request, 当没有网络时, 使用CacheControl.FORCE_CACHE, 即使用缓存. (正常情况使用2.2配置的Cache-Control) 对于response, 有网时, 加入和request一样的Cache-Control; 对于response, 无网, 使用CacheControl.FORCE_CACHE(这种情况较为少见). 做好了拦截器, 不要忘记加到OkHttpClient中: 1builder.addNetworkInterceptor(mCacheControlInterceptor); 3, 严重提醒 严重注意, 在加入interceptor时:使用的是addNetworkInterceptor, 而非addInterceptor. 二者区别参见OkHttp wiki的Interceptor介绍, 在此就借个图来用下:正所谓一图千字, 可以很清楚的看到CACHE的层次了…具体的分析大家还是Read the fucking source code吧:) 这里就说明下为什么要使用addNetworkInterceptor吧. 某些情况下, 服务器返回的response是会带有Cache-Control的, 如果这个Cache-Control的时效配置和你想要的不一致, 或是更甚者服务器传回类似这样的:那么我们就悲剧了, no-cache, 意味着响应不会被缓存. 当然, 如果服务器没有定制response的Cache-Control属性的话, 我们使用addInterceptor来添加拦截器, 还是可以给reponse加入Cache-Control并使其缓存的. 关于Interceptor和NetworkInterceptor的区别, 建议大家还是读源码…在此略过. 稳妥起见, 完全由客户端可控的话, 还是使用addNetworkInterceptor吧. 4, 结语回顾下, 加入网络缓存的几步: 配置缓存目录 配置request Cache-Control 配置response Cache-Control 虽说简单, 但是个中的确包含了很多知识点. Cache-Control属性的使用, 意义; OkHttp的拦截器; Retrofit的header配置等等. 还是那句话, 更多的是希望大家能够在学到东西的同时, 了解更多其相关的原理, 或是学习方法. 知其然, 知其所以然. 本文例子, 完整代码 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"},{"name":"MVP","slug":"MVP","permalink":"http://blog.lmj.wiki/tags/MVP/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"浅谈移动互联网产品App的研发流程","slug":"pm/product-dev-flow","date":"2016-08-03T14:19:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/08/03/pm/product-dev-flow/","link":"","permalink":"http://blog.lmj.wiki/2016/08/03/pm/product-dev-flow/","excerpt":"这几天有跟朋友谈到创业, 聊起一些关于移动互联网产品App的研发演进过程的话题. 觉得这个其实是一个程序员职业发展道路上需要深思的问题, 顺道在这跟大家一起聊聊, 欢迎大家拍砖.","text":"这几天有跟朋友谈到创业, 聊起一些关于移动互联网产品App的研发演进过程的话题. 觉得这个其实是一个程序员职业发展道路上需要深思的问题, 顺道在这跟大家一起聊聊, 欢迎大家拍砖. 关于研发人员的产品心一般来说, 国内的程序员出路无外乎技术路线走架构师, 管理路线转项目管理, 技术经理, CTO, 或者自己创业. 无论哪条路, 实际上都要求我们研发要有一颗产品的心, 其他职位都好理解, 管理一个产品的研发, 当然需要深刻了解产品的需求和实现. 然而架构师其实也是必须和产品职能挂钩的, 所谓架构, 模式最终都是服务于业务. 架构师只有很好了理解了整个产品, 才能搭建出符合产品发展的架构. 产品研发流程上段属于废话, 大家可以忽略:) 下图是我根据这几年的产品开发管理经验以及与多个产品经理们沟通的一个比较符合产品, 运营, 测试, 开发, 运维等工作方式的, 基于敏捷的产品研发周期图: 个人比较推崇的是一种敏捷思维, 以上整个是一个迭代周期的流程, 实际场景中, 每个阶段每个职能在做自己的任务的过程中也都是基于敏捷迭代式的. 而且在整个过程中, 各个阶段又都是并行的. 例如产品发布1.1的版本产品需求后, 开发开始这个版本的开发, 其开发过程也是迭代式, 先做任务分解, 然后小步多次迭代完成整个版本的需求. 与此同时, 产品就已经在做1.2版本的产品需求采集和分析了. 迭代开发工作流当然, 作为一个开发人员, 我最关注的还是研发阶段的工作, 下图也是根据项目经验的画的一个迭代开发工作流, 与大家分享: 以上欢迎拍砖, 也欢迎各位留言说说你们当前的产品研发流程是怎样的, 大家各取所长, 共同进步. 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"PM","slug":"PM","permalink":"http://blog.lmj.wiki/categories/PM/"}],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://blog.lmj.wiki/tags/项目管理/"},{"name":"产品","slug":"产品","permalink":"http://blog.lmj.wiki/tags/产品/"}],"keywords":[{"name":"PM","slug":"PM","permalink":"http://blog.lmj.wiki/categories/PM/"}]},{"title":"[译]探索Context之Context是什么","slug":"android/context","date":"2016-08-02T15:22:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/08/02/android/context/","link":"","permalink":"http://blog.lmj.wiki/2016/08/02/android/context/","excerpt":"译者:本准备写一篇Context相关的文, 看到此文, 觉得很好, 先搞个”拿来主义”译过来, 作为探索Context系列的第一篇吧. 原文: Context, What Context? 译文: Context可能是我们开发App中用的最多是元素了, 也可能是最容易被误用的… Context对象如此常见, 经常各种传递, 用来很方便的创建一些情景, 诸如加载资源文件, 启动一个新的Activity, 获取一个系统服务, 获取内部存储文件路径, 创建Views等等等等(太多了…). 我写此文的目的是想提供给你一些观察Context如何工作的视角, 以便你可以在你的App开发中更有效准确的使用Context.","text":"译者:本准备写一篇Context相关的文, 看到此文, 觉得很好, 先搞个”拿来主义”译过来, 作为探索Context系列的第一篇吧. 原文: Context, What Context? 译文: Context可能是我们开发App中用的最多是元素了, 也可能是最容易被误用的… Context对象如此常见, 经常各种传递, 用来很方便的创建一些情景, 诸如加载资源文件, 启动一个新的Activity, 获取一个系统服务, 获取内部存储文件路径, 创建Views等等等等(太多了…). 我写此文的目的是想提供给你一些观察Context如何工作的视角, 以便你可以在你的App开发中更有效准确的使用Context. 1, Context类型并不是所有的Context都是等同的. 根据你所在的App的组件(译者注: 组件包括Application, Activity, Service, Receiver, Provider)不同, Context略有不同: Application ContextApplication Context在你的应用进程里是一个单例的存在. 可以在Activity或Service中通过getApplication()来访问, 也可以在任意继承Context的对象中通过getApplicationContext()来访问. 不管以何种形式访问, 在同一应用进程中你获得的Application Context实例都是同一个. Activity/Service ContextActivity/Service继承自ContextWrapper, ContextWrapper作为Context(一个Base Context)的代理, 实现了和Context一样的接口. 没当framework创建一个Activity/Service实例时, 也会创建一个ContextImpl的实例来真正处理(Context接口所描述的)繁重的工作. 每个Activity/Service实例, 都有一个对应的Base Context的实例. Broadcast Receiver中的Context实际上Broadcast Receiver并不是一个Context, 但是framework会每次广播事件到来时传递一个Context给onReceive()方法. 这个Context是一个ReceiverRestrictedContext实例, 它禁用了Context的registerReceiver()和bindService() (译者注: 这也是为什么我们说不能在onReceive方法里面绑定一个Service的起源). 每次有广播事件收到时, 传过来的Context都是一个新的Context实例. ContentProvider中的Context本身也不是一个Context, 但是可以通过getContext()方法来获取一个Context对象. 如果ContentProvider和调用者是同一个应用进程, getContext()会返回一个Application级别的单例的Context实例; 然而, 如果二者处于不同的进程, getContext()会返回一个新的代表Provider所运行的包的Context实例. (译者注: 下面是作者的关于Context的使用经验) 2, 保存引用第一个我们需要解决的问题是: 在一个对象或类中保存一个Context, 但是这个对象或类的生命周期超过了你保存的Context实例的生命周期. 例如, 创建一个自定义的单例, 它需要一个context来加载资源或者访问ContentProvider, 于是保存一个指向当前Activiy/Service的引用到该单例中. 糟糕的单例1234567891011121314151617public class CustomManager &#123; private static CustomManager sInstance; public static CustomManager getInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new CustomManager(context); &#125; return sInstance; &#125; private Context mContext; private CustomManager(Context context) &#123; mContext = context; &#125;&#125; 问题是我们不知道这个context会来自哪儿, 并且保存一个最终指向Activity或Service的引用是不安全的. 因为单例在类的内部维持一个单一的静态引用, 意味着这个单例, 以及该单例所引用的其他所有对象都永远不会被GC回收. 如果这个context是一个Activity, 我们将会持有这个Activity以及它的所有Views和其他可能的关联的大对象, 从而造成内存泄露. 为了避免这种问题, 我们使用Application类型的Context来创建单例: 改善后的单例123456789101112131415161718public class CustomManager &#123; private static CustomManager sInstance; public static CustomManager getInstance(Context context) &#123; if (sInstance == null) &#123; //Always pass in the Application Context sInstance = new CustomManager(context.getApplicationContext()); &#125; return sInstance; &#125; private Context mContext; private CustomManager(Context context) &#123; mContext = context; &#125;&#125; 现在, 我们将无需关注context的来源, 因为我们保存的context引用是安全的. Application Context本身就是单例, 所以我们在创建另一个静态引用时不会泄露任何东西. 另一个很好的例子是, 在后台线程或是等待中的Hanlder中也可以使用Application类型的Context. 但是为什么我们不能总是使用Application Context呢? 正如前面例子中说的, 引用Application Context永远不用担心内存泄漏的问题. 问题的答案是, 就像我一开始介绍的那样, 是因为不同组件中的Context并不是完全一样的. 3, Context的能力Context能做什么决定于它来自哪儿. 下表描述了常见的Context的来源以及其应用范围: 注解:1, Application的Context可以启动一个Activity, 但是会在新Task中创建(译者注, 待验证). 这可能可以满足一些特定需求, 但是这也会创建不标准的返回栈(Back Stack), 所以不推荐, 也不认为是好的实践.2, 这个也是合法的, 但是Inflate出来的View是根据你当前系统的默认主题(Theme)的, 而非你的Application所使用的主题.3, Android 4.2及以上, 如果Receiver是null(用来获取一个Sticky Broadcast的当前值的), 则是允许的. 4, 用户界面从前面的表格可以看到, 很多(UI相关的)情况下 Application Context并不适合来处理. 实际上, 只用Activity Context能够处理所有与UI相关的任务. 其他的任务所有类型的Context都差不多. 幸运的是, 有三种事是Activity之外不能处理的, 这可能是Android framework故意这么设计的. 如果你尝试使用Application Context去show一个对话框; 或是启动一个Activity, 系统会抛出异常, 导致崩溃—来提示你出问题了… 另外一个并不明显的是Inflate布局. 如果你读过我另一篇关于Layout Inflation的文(译者注, 这篇文也推荐一读, 有空了翻译下). 你就已经知道它可能是一个非常神秘的过程, 隐藏着一些不可知的行为。使用正确的Context关系到其中的行为表现. 当你使用Application Context来inflate一个布局的时候并不会报错, 会返回一个系统默认的主题的view给你, 而没有考虑你的Applicaiton本身的Theme和Style. 这是因为Acitivity是唯一的绑定了在manifast文件中定义主题Theme的Context. 其他的Context实例将会使用系统默认的主题来inflate你的view. 这可能会导致显示的View并不是你所希望的那样的. 5, 规则的交叉点显然, 可能有些读者已经看出两个规则互相矛盾之处. 在一些Application的设计中, 我们可能既需要长期的保存一个引用，而且为了完成与UI相关的工作又必须保存一个Activity的Context. 如果出现这种情况, 我强烈建议你重新考虑你的设计, 它将是一个很好的”反框架”案例. 6, 使用经验绝大多数情况下, 使用在你的所在的组件内部能够直接获取的Context. 只要这个Context引用没有超过这个组件的生命周期, 你就可以安全的保存这个引用. 一旦你要保存一个Context的引用到你的对象中, 该对象超过了你的Activity或者Service的生命周期范围, 即使是暂时的, 你就需要转换你的引用为Application Context.","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"翻译","slug":"翻译","permalink":"http://blog.lmj.wiki/tags/翻译/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"Android App开发技能图谱","slug":"android/android-app-skill-map","date":"2016-07-26T15:25:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/07/26/android/android-app-skill-map/","link":"","permalink":"http://blog.lmj.wiki/2016/07/26/android/android-app-skill-map/","excerpt":"引言:今天偶然看到StuQ的技术图谱, 找了找竟然没有Android开发的. 想起之前自己弄了一个, 翻出来看看并不过时, 整理下发出, 大家共同进步.","text":"引言:今天偶然看到StuQ的技术图谱, 找了找竟然没有Android开发的. 想起之前自己弄了一个, 翻出来看看并不过时, 整理下发出, 大家共同进步. 图片比较大, 加载较慢, 请等待~~ 1. 操作系统Windows/MacOSX/Linux2. 编程语言 Java HTML/JS (Hybrid/Web App) C/C++ (NDK) SQL (DB) Kotlin 3. 开发工具3.1 IDE Android Studio Eclipse 3.2 调试工具3.2.1 网络调试 Charles Wireshark Fiddler tcpdump Paw/Postman 3.2.2 内存分析 monitor MAT 3.2.3 Android tools adb draw9patch hierarchyviewer uiautomatorviewer 3.3 版本管理3.3.1 Git Git命令 Github/GitLab 3.3.2 SVN3.4 CodeReview Gerrit Github pull request 3.5 Bug/任务管理 Redmine JIRA Bugzilla Teambition Tower 3.6 编译工具 Gradle 3.7 持续集成 Jenkins Travis CI 3.8 应用分发 蒲公英 fir.im 1. App基础1.1 基本组件 Activity Service Content Provider Broadcast Receiver Intent/Intent Filter App Manifest File 1.2 UI Layouts Widgets Resources Animations 设备适配 1.3 Connectivity WiFi Mobile网络 网络状态监听 1.4 MultiMedia Audio/Video Camera/Gallery 1.5 GPS&amp;Location&amp;Map1.5.1 系统定位 GPS定位 Network定位 3rd Map定位 百度Map 高德Map 2. App进阶2.1 Process&amp;Thread2.1.1 Process Linux进程 App进程原理 2.1.2 AIDL 实现方式 原理 2.1.3 Handler/Looper/MQ/Thread2.1.4 Loader2.1.5 AsyncTask2.2 性能优化2.2.1 ANR2.2.2 布局层级性能优化2.3 内存优化2.3.1 内存检测工具2.3.2 内存分析工具2.3.3 Bitmap优化2.3.4 内存泄露查找及分析2.5 网络优化2.5.1 API优化2.5.2 低网速下优化2.5.3 流量使用优化 判断当前网络类型 使用缓存 2.6 单元测试3. App高级3.1 相关原理熟悉3.1.1 Activity 启动流程 生命周期回调原理 与View/Window的关系 与Fragment的关系 3.1.2 View/Window View/Window关系 View渲染 View事件分发处理流程 3.1.3 编译打包 编译打包原理 逆向工程分析 热修复 3.2 Hybrid App3.2.1 与Native App的异同3.2.2 主流框架 PhoneGap ionic React Native 3.3 架构能力3.3.1 架构 MVC MVP MVVM Flux Clean Architecture 3.3.2 App框架 分包 分层 3.3.3 设计模式 OOD原则 常用设计模式运用 3.4 ART&amp;Dalvik AOT compilation GC Bytecode&amp;.Dex 3.5 自动化测试 monkey/monkey runner UIAutomator Espresso Robotium 4. 扩展学习4.1 响应式编程4.1.1 Rx RxJava RxAndroid RxBinding 4.1.2 Agera4.2 主流开源库4.2.1 快速开发 Android Annotation ButterKnife 4.2.2 Views 太多 4.2.3 HTTP模型 Retrofit OkHttp Volley 4.2.4 图片处理 Glide Fresco Picasso UIL 4.2.5 依赖注入 Dagger2 4.2.6 数据库 ORMLite GreenDAO Realm Sugar 4.2.7 辅助 Logger LeakCanary DbInspector 本文已上传至Github AndroidDevResources 项目, 欢迎Fork, 提出意见. 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"技能图谱","slug":"技能图谱","permalink":"http://blog.lmj.wiki/tags/技能图谱/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"MVP架构实现的Github客户端(3-功能实现)","slug":"mvp/mvp3","date":"2016-07-22T14:14:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/07/22/mvp/mvp3/","link":"","permalink":"http://blog.lmj.wiki/2016/07/22/mvp/mvp3/","excerpt":"MVP架构实现的Github客户端(3-功能实现)请先阅读1-准备工作和2-搭建项目架构. 前文搭建了项目的大体架构, 本文以实现github中最常用的搜索repository功能为例, 讲述下功能开发的整个过程以及关于MVP, Dagger2注入, Rx以及Retrofit, OkHttp等在准备工作中提到的一系列开源库的使用.","text":"MVP架构实现的Github客户端(3-功能实现)请先阅读1-准备工作和2-搭建项目架构. 前文搭建了项目的大体架构, 本文以实现github中最常用的搜索repository功能为例, 讲述下功能开发的整个过程以及关于MVP, Dagger2注入, Rx以及Retrofit, OkHttp等在准备工作中提到的一系列开源库的使用. 1, 功能梳理基本功能类似于Github中的Search功能一致, 包含Repository/User/Issue/Code的搜索, 并可选排序方式(Best match, Most stars等等). 本文以搜索Repository为例, 默认按照Most Stars来排序列举搜索结果. 监听用户输入关键字, 当超过600ms没有输入时自动开始搜索, 按照stars数显示搜索结果. 目前只是以此功能来演示前文的MVP框架, 并不完善~源码将持续更新, 完善功能. 欢迎star. 效果如下: 2, 从数据开始(M)Github相关API Github Search Repository API Docs 示例: 1https://api.github.com/search/repositories?q=tetris+language:assembly&amp;sort=stars&amp;order=desc 根据API, 我们可以写Retrofit的接口以及相关Model类: 1234567public interface RepoService &#123; @GET(\"search/repositories\") Observable&lt;SearchResultResp&gt; searchRepo(@Query(\"q\") String key, @Query(\"sort\") String sort, @Query(\"order\") String order, @Query(\"page\") int page, @Query(\"per_page\") int pageSize);&#125; 其中Repo这个Model类就不贴了, 太长.建议大家可以使用Android Studio的插件GsonFormat来生成: Retrofit/OkHttpClient设计大家都知道Retrofit一般会是单例, 会设置一个baseUrl.考虑到Github客户端这个应用, 我会加入Trending这个功能, 但是官方并没有提供相关接口. 这个baseUrl就可以不同接口不一样.另外使用的OkHttpClient也可能针对不同接口使用不同的interceptor.在此做了一个小框架, 以便扩展(时刻牢记开闭原则). ApiEndpoint 接口提供baseUrl. BaseOkHttpClient 提供OkHttpClient实例. BaseRetrofit 依赖ApiEndpoint和BaseOkHttpClient, 提供Retrofit实例. GithubRepoRetrofit 是基于github的url的Retrofit实现. 数据层整体结构综上, 数据层的整体结构如下: RepoApi 定义业务接口. RepoDataSource 实现RepoApi接口, 通过RepoService这个Retrofit格式的Restful接口取数据并可以在此做相应处理. 3, 绘制界面(V)这部分就不细说了, 参看代码. 抽象了几个Base类: 4, 数据关联显示(P)Presenter作为M和V的桥梁, 如2-搭建项目框架所说, 其拥有V和M的实例: 通过BaseMvpPresenter中的attachView来获取View实例, 在其构造函数中关联RepoApi这个M层接口. 在此抽象了一个RxMvpPresenter的基类, 主要用来解决Observable的unsubsribe问题. 5, 将MVP注入起来(Dagger2)上面介绍完M, V, P这三个角色, 但是他们是怎么关联起来的呢? 或者说怎么实例化的呢? 有请Dagger2出场. 具体的Dagger2的使用请自行Google~, 基本作用如下几点. 我后续也会抽时间整理Dagger2的使用经验, 敬请期待. 下面简单说下我们这个功能中的注入情况:s 使用@Module和@Providers来对外提供依赖搭建项目框架我们提到di的基本框架中, 就写了一个ApplicationModule用来对外提供Application级别的依赖, 在此我们可以将Retrofit Service放在这里: 12345678910111213141516171819202122232425@Modulepublic class ApplicationModule &#123; protected final Application mApplication; public ApplicationModule(Application application) &#123; mApplication = application; &#125; @Provides Application provideApplication() &#123; return mApplication; &#125; @Provides @ApplicationContext Context provideContext() &#123; return mApplication; &#125; @Provides @Singleton RepoService provideRepoService(GithubRepoRetrofit retrofit) &#123; return retrofit.get().create(RepoService.class); &#125;&#125; 可以看到我们使用的是GithubRepoRetrofit这个Retrofit示例来创建Service的.那么这个GithubRepoRetrofit是怎么实例化的呢? 往下看… 构造函数上的@Inject当用@Inject来注解一个构造函数时, Dagger2会根据其构造参数来生成一个该实例. 这样做是为了避免定义太多的@Provides.例如: 12345678910111213@Injectpublic GithubRepoRetrofit(NormalHttpClient mHttpClient) &#123; this.mHttpClient = mHttpClient;&#125;@Injectpublic NormalHttpClient() &#123;&#125;@Injectpublic SearchPresenter(RepoApi api) &#123; this.mRepoApi = api;&#125; 变量上的@Inject上面两个原则用来提供实例, 这个就是用来请求实例的.例如在SearchFragment里面我们需要一个SearchPresenter的实例: 12@InjectSearchPresenter mPresenter; 如上即可, 我们无需关注这个Presenter怎么实例化的. 这个给了我们很多想象空间, 我们可以随意替换这个Presenter的实现, 都不需要改动View的代码. @Component的作用以上讲了实例的产生和消费, 那么他们是怎么关联的呢? 这就需要@Component了, Component用来做实例关联和inject.所有的@Component类都会在编译时生成一个Dagger开头的类, 里面根据Component定义来提供实例, 和注入关系. 例如我们的Component: 123456789101112@PerActivity@Component( dependencies = ApplicationComponent.class, modules = &#123;ActivityModule.class, RepoModule.class, TrendingRepoModule.class&#125;)public interface MainComponent extends ActivityComponent &#123; void inject(MostStarFragment mostStarFragment); void inject(TrendingFragment trendingFragment); void inject(SearchFragment searchFragment);&#125; 可以看到MainComponent依赖ApplicationComponent, 并从ActivityModule, RepoModule, TrendingRepoModule这三个Module中获取依赖实例. 另外提供inject关系到MostStarFragment, TrendingFragment, SearchFragment这三个使用者身上, 要使用这个inject关系, 还需在onCreate中inject一下: 1234567@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getComponent(MainComponent.class).inject(this); mPresenter.attachView(this);&#125; 具体大家可以查看源码以及编译后生成的DaggerMainComponent. 6, RxBinding/RxJava的使用在这个功能中, 使用RxBinding对EditText的Text Change事件做了事件流处理, 以便可以很方便的做延时, 过滤, 与查询接口合并等. 具体RxBinding的功能不在此细说了. 功能使用如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void bindSearchView(EditText searchTextView) &#123; mCompositeSubscription.add(RxTextView.textChanges(searchTextView) .subscribeOn(AndroidSchedulers.mainThread()) .filter(new Func1&lt;CharSequence, Boolean&gt;() &#123; @Override public Boolean call(CharSequence charSequence) &#123; return charSequence.length() &gt; 0; &#125; &#125;) .debounce(600, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .switchMap(new Func1&lt;CharSequence, Observable&lt;ArrayList&lt;Repo&gt;&gt;&gt;() &#123; @Override public Observable&lt;ArrayList&lt;Repo&gt;&gt; call(CharSequence charSequence) &#123; String key = charSequence.toString(); return mRepoApi.searchMostStarredRepo(key, mLanguage) .onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends ArrayList&lt;Repo&gt;&gt;&gt;() &#123; @Override public Observable&lt;? extends ArrayList&lt;Repo&gt;&gt; call(Throwable throwable) &#123; getMvpView().showError(throwable); AppLog.d(\"searchMostStarredRepo onErrorResumeNext:\" + throwable); return Observable.empty(); &#125; &#125;) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; getMvpView().showLoading(); &#125; &#125;); &#125; &#125;) .doOnTerminate(new Action0() &#123; @Override public void call() &#123; mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; getMvpView().dismissLoading(); &#125; &#125;); &#125; &#125;); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends ArrayList&lt;Repo&gt;&gt;&gt;() &#123; @Override public Observable&lt;? extends ArrayList&lt;Repo&gt;&gt; call(Throwable throwable) &#123; AppLog.d(\"onErrorResumeNext:\" + throwable); getMvpView().showError(throwable); return Observable.empty(); &#125; &#125;) .subscribe(new ResponseObserver&lt;ArrayList&lt;Repo&gt;&gt;() &#123; @Override public void onSuccess(ArrayList&lt;Repo&gt; repos) &#123; getMvpView().showContent(repos); &#125; @Override public void onError(Throwable e) &#123; AppLog.d(\"onError:\" + e); getMvpView().showError(e); &#125; &#125;));&#125; 看起来好长, 实际就几步:1, 字符串长度过滤.2, debounce操作, 即仅在过了一段指定的时间还没发射数据时才发射一个数据3, 与查询接口做switchMap操作. 7, 结语至此, 一个基于Dagger2, RxJava, Retrofit, OkHttp等library的MVP架构的实现已经完成. 这几篇文章只是提供给大家一个架构的方向, 欢迎大家fork. 另外GithubApp这个工程还会持续更新, 包括功能上和架构, 以及一些新的主流库的使用也会在这个工程上体现, 欢迎关注star. 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"},{"name":"MVP","slug":"MVP","permalink":"http://blog.lmj.wiki/tags/MVP/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"MVP架构实现的Github客户端(2-搭建项目框架)","slug":"mvp/mvp2","date":"2016-07-22T14:10:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/07/22/mvp/mvp2/","link":"","permalink":"http://blog.lmj.wiki/2016/07/22/mvp/mvp2/","excerpt":"MVP架构实现的Github客户端(2-搭建项目框架)请先阅读MVP架构实现的Github客户端(1-准备工作). 本文承接上文, 主要介绍项目框架搭建. 废话少说, 放码过来","text":"MVP架构实现的Github客户端(2-搭建项目框架)请先阅读MVP架构实现的Github客户端(1-准备工作). 本文承接上文, 主要介绍项目框架搭建. 废话少说, 放码过来 1, 提取一个mvp模块提取MVP中View/Presenter相关接口到一个独立的mvp模块(可复用): 包结构 类图 简单说明一个MvpView接口来约束View组件: 12public interface MvpView &#123;&#125; MvpPresenter接口中关联MvpView: 12345678910111213141516171819public interface MvpPresenter&lt;V extends MvpView&gt; &#123; /** * Set or attach the view to this presenter */ @UiThread void attachView(V view); /** * Will be called if the view has been destroyed. Typically this method will be invoked from * &lt;code&gt;Activity.detachView()&lt;/code&gt; or &lt;code&gt;Fragment.onDestroyView()&lt;/code&gt; */ @UiThread void detachView();&#125; 另外, 由于现在App的内容展示大部分是基于网络数据, 在此扩展了一个通用的LceView, Lce取Loading, Content, Error之意: 123456789101112131415161718public interface LceView&lt;M&gt; extends MvpView &#123; @UiThread public void showLoading(); @UiThread public void dismissLoading(); @UiThread public void showContent(M data); @UiThread public void showError(Throwable e);&#125; 2, 搭建app框架包结构app框架方面, 个人主张是先基于MVP架构分包 然后根据业务功能划分模块的, 如下: 其中: common 包含util, config, constant等通用包和类. data 包含model, api, db, pref, 网络接口实现等. 其中对外公开一个DataRepository提供业务接口相关数据. di 依赖注入相关的类. 根据dagger2的风格, 一般有module和component模块. presenter 里面根据业务模块划分. ui 包含UI层的所有东东. activity, fragment, widget, dialog, adapter等, 根据需求不同分包方式有出入. 层次结构层次结构相对与业务需求而言, 例如账户相关的登录注册, repo模块相关的repo列表, 详情等…大体上每个业务模块都会由以下几个部分构成, 整体的项目层次也是如此: 3, 完善基础工程根据上述两步, 一个项目的基本架构已经完成, 但是并不完整, 我们还需要添加一些通用类, 基础类来完善下. 其实这些基类也相当于是一个编码规范, 特别是多人合作项目中, 提前根据项目需求写一些通用类, 工具类, 基类等, 能够避免后续大家编码上各自一套. 所以个人认为这些类的编写也属于搭建框架的一部分. 添加相关Base类为了便于统一处理, 惯例, 我们需要为Activity, Fragment创建一个BaseActivity, BaseFragment. 可以在ui包里创建一个base子包放置. 这个基类好处多多, 例如我们对界面的统一处理, 生命周期的日志打印, 添加统计工具等, 都能很方便的再基类里面处理. 封装相关工具类如上文所说, 个人习惯对第三方开源库再做一层封装, 以便后续灵活替换.使用过程中, 也只需调用封装后的接口即可, 无需关注具体的依赖包. 也利于大家协作统一.例如: Logger封装创建一个AppLog类来包装Logger: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AppLog &#123; private static final String TAG = \"GithubApp\"; /** * initialize the logger. */ public static void init() &#123; Logger.init(TAG); &#125; /** * log.i * @param msg */ public static void i(String msg) &#123; if (BuildConfig.DEBUG) &#123; Logger.i(msg); &#125; &#125; /** * log.d * @param msg */ public static void d(String msg) &#123; if (BuildConfig.DEBUG) &#123; Logger.d(msg); &#125; &#125; /** * log.w * @param msg */ public static void w(String msg) &#123; if (BuildConfig.DEBUG) &#123; Logger.w(msg); &#125; &#125; /** * log.e * @param msg */ public static void e(String msg) &#123; Logger.e(msg); &#125;&#125; 图片加载库封装封装一个ImageLoader工具类来对外提供接口加载图片: 123456789101112131415public class ImageLoader &#123; /** * Load image from source and set it into the imageView. Use Glide now. * @param context context. * @param source could be Uri/String/File/ResourceId. * @param view the imageView. */ public static void load(Context context, Object source, ImageView view) &#123; Glide.with(context) .load(source) .centerCrop() .into(view); &#125;&#125; Dagger相关基础类因为我们使用的Dagger2来做依赖注入, 因为Activity和Application的Context是比较常用的, 我们会构建Activity, Application相关的component/module来提供对应的Context.具体代码参看github工程源码. 4, 整体结构假设我们的产品需要是迭代式的, 至此, 我们的基础框架已经差不多了(不建议做过多过早设计).回顾下, 大体结构现在基本如下: app mvp 具体代码请参看https://github.com/mingjunli/GithubApp 目前代码只是一个基础的框架, 心急的同学可以参看这个工程, 架构类似. 一个简单的新闻客户端, 用来做MVP demo的. 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"},{"name":"MVP","slug":"MVP","permalink":"http://blog.lmj.wiki/tags/MVP/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"MVP架构实现的Github客户端(1-准备工作)","slug":"mvp/mvp1","date":"2016-07-22T14:04:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/07/22/mvp/mvp1/","link":"","permalink":"http://blog.lmj.wiki/2016/07/22/mvp/mvp1/","excerpt":"MVP架构实现的Github客户端(1-准备工作)承上关于App重构的几个方面主要也是说的架构重构, 本系列尝试以开发一个Github客户端为例, 记录个人在开发一个App项目过程中的一个基本流程, 以及所采用的架构, 技术的运用, 在此过程也会说明下如何规避上文提到的一些代码,架构等问题.","text":"MVP架构实现的Github客户端(1-准备工作)承上关于App重构的几个方面主要也是说的架构重构, 本系列尝试以开发一个Github客户端为例, 记录个人在开发一个App项目过程中的一个基本流程, 以及所采用的架构, 技术的运用, 在此过程也会说明下如何规避上文提到的一些代码,架构等问题. 1, 架构选择毋庸置疑, MVP架构是目前开发Android App最火的架构, 可能MVVM更加吸引人, 但是MVP更加成熟且易于上手. 相比与Activity/Fragment包揽一切的传统开发架构又更加灵活, 便于产品的更新迭代(特别是UI上的变化, 你懂的, 这也是产品们最喜欢变动的部分).故此次开发的Github客户端将采用MVP架构: Model 对外提供业务数据API. 内部实现本地数据, 网络数据的存取等. 只有Presenter可以访问, 与View隔离 Presenter 持有View对象, 对View进行操作 持有Model层提供的数据接口对象, 可通过依赖注入解耦此部分. 从数据接口对象中获取数据并处理, 更新View. View UI层, 包含所有UI相关组件. 持有对应的Presenter的对象, 可通过依赖注入解耦此部分. 由Presenter来负责更新UI. 2, 服务器API熟悉当前大部分的App是需要与服务器交互的, 在开发之前, 我们也需要简单了解下Github提供的API.因为Github提供了详尽的开发指南, 在此就不详述了. 值得一提的是, Github API的标准的Restful架构的API, 这个是大赞的~ 3, 开源库选择快速开发一个项目, 且抱着不重复造轮子的思想, 选择一些开源库辅助开发是很必要的. 当然, 同类的开源库可能很多, 选择上可能更多是个人喜好和使用习惯的问题, 在此不做比较(可以哪天单立个开源库选择的话题讨论下).以下根据个人经验和当前项目的情况初步选择的一些库: 网络请求 Retrofit 一个类型安全(Type-Safety）的基于RESTful架构的Android（Java）客户端实现。基于注解，动态代理等技术。 源码地址 官方教程 项目中使用此框架来做服务器接口交互。 Retrofit只是一个RESTful的架构，可以通过它定义和服务器的接口形态，然而真正的HTTP请求还是需要借助HttpConnection或其他方式去完成的，这就用到了同由Square组织开发的OkHttp。 OkHttp 一个HTTP &amp; SPDY的Android(Java)客户端实现。目前Android4.4的源码中HttpURLConnection已经替换成OkHttp实现，所以当前OkHttp是我们项目中Http请求的一个最常用的库。 源码地址 官方教程 源码解析 图片加载图片加载的库也有很多, 老牌的UIL(Universal-Image-Loader), google推的Glide, Square组织的Picasso, 以及facebook新晋的Fresco.各有千秋, 关于这几个的比较可以参考StackOverFlow上的这个问题.在此个人选择Glide. Glide Glide本意是滑行，专注于快速Scroll中的图片加载问题，当然也完全可以作为Remote Image的加载库。Google在开发者论坛推荐的，并应用在Google的很多开源项目上。 是一个快速且有效的开源媒体管理以及图片加载的Android 框架，包含媒体解码，内存、磁盘缓存以及资源池等。 支持获取、解码、显示视频、图片、GIF动态图。 源码地址 官方教程 另外, 个人习惯, 为了拥抱变化, 我会在Glide的基础上再封装一层, 以便可以很方便的替换成其他的库. 如下:123456789public class ImageLoader &#123; public static void load(Context context, Uri uri, ImageView view) &#123; Glide.with(context) .load(uri) .centerCrop() .into(view); &#125;&#125; 如需替换成Picasso, 仅仅修改ImageLoader这个文件即可, 由于Picasso的调用方式和Glide几乎一样, 我们要做的可能只是将Glide换成Picasso而已, 如下:1234// 将Glide换成Picasso// Glide.with(context)Picasso.with(context)... Rx支持 RxJava 一个使用Observable序列实现包含异步和基于事件的编程方式框架。 扩展自观察者模式，实现数据、事件序列，并提供了很多Operators可以随意转换Observable，而无需顾虑线程安全，并发同步等。 源码地址 官方教程 给 Android 开发者的 RxJava 详解 ReactiveX文档中文翻译 Awesome-RxJava RxAndroid RxJava的Android扩展 源码地址 官方教程 RxLifecycle 基于RxJava的Activity、Fragment生命周期控制组件。结合RxJava请求使用可以根据Activity、Fragment生命周期自动完成事件序列。避免需要手动调用unsubscribe。 源码地址 官方教程 RxBinding Jake大神的大作, 用来将View的事件转换成Rx模式 (大家可以跟随项目见证它的妙处). 源码地址 依赖注入这个一般会选择大名鼎鼎的Dagger了, 现在使用的基本都是google fork修改之后的Dagger2. Dagger2 依赖注入框架 源码地址 官方教程 数据库相关这个也有很多选择, 个人一般使用GreenDAO, 主要是其编译生成类文件, 比较清晰, 便于看清原理. GreenDAO GreenRobot组织开发的一个轻量快速的Android ORM数据库实现。 源码地址 官方教程 另外, 最近Realm, 极其火爆, 说是基于移动设备打造的数据库, 抛弃SQLite的存在, 可以在练手项目中尝试下. 辅助 Logger 漂亮的Log输出库。 源码地址 官方教程 LeakCanary 内存溢出检测库。 源码地址 官方教程 DBinspector 数据库查看库。 源码地址 官方教程 还有项目过程中还会根据实际情况增减一些库, 到时再说.另外可能会引入一些注入自定义View, 动画等相关的库, 也是根据产品的实际情况而定. 至此, 一个App项目的前期工作基本就绪了(当然, 这个是作为一个简单的自研项目而言, 如果是公司产品, 还需更多的产品方面的准备, 在此单论技术方面).接下来, 就会开始搭建项目框架了, 敬请期待. 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"架构","slug":"架构","permalink":"http://blog.lmj.wiki/tags/架构/"},{"name":"MVP","slug":"MVP","permalink":"http://blog.lmj.wiki/tags/MVP/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"关于App重构的几个方面","slug":"android/app-refactor","date":"2016-07-13T07:17:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/07/13/android/app-refactor/","link":"","permalink":"http://blog.lmj.wiki/2016/07/13/android/app-refactor/","excerpt":"关于App重构的几个方面最近跟一个朋友聊到关于App架构的问题, 其中就聊到一个App, 开发了很长时间, 一开始没有去想框架的事儿, 迭代过程中, 由于时间紧, 任务重, 人员更替等原因, 也没能保证代码质量, 很多设计原则被抛之脑后, 代码质量逐步下降, 以致难于阅读, 难于维护. 进而导致迭代困难, 而形成恶性循环. 从而引申出如何重构App代码的话题, 谈点个人理解:","text":"关于App重构的几个方面最近跟一个朋友聊到关于App架构的问题, 其中就聊到一个App, 开发了很长时间, 一开始没有去想框架的事儿, 迭代过程中, 由于时间紧, 任务重, 人员更替等原因, 也没能保证代码质量, 很多设计原则被抛之脑后, 代码质量逐步下降, 以致难于阅读, 难于维护. 进而导致迭代困难, 而形成恶性循环. 从而引申出如何重构App代码的话题, 谈点个人理解: 什么情况下需要重构1, 结构错乱 代码无法分出层次, 无法分清业务线. 各个业务模块间/层次间的代码互相夹杂. 由于多人协作导致的多种架构(MVP/MVVM/MVC等)并存. 规范性问题, 导致各个模块内的代码形式互相不一致, 风格迥异. 2, 可读性差 超长函数, 超大类 代码的格式不规范或不一致. 冗余代码, 无用代码, 重复代码. 过于高明, 使用一些不常用的小技巧而且没有相关注释. 滥用继承, 接口实现等, 导致难以跟踪. 3, 不能很好的适应产品的发展 维护困难, 前一发动全身. 不具备扩展灵活性, 无法很快引入系统版本更新时新特性. 不具备可变更性, 产品添加新功能或修改需求时需要修改大量的代码. 重构的目标重构的目的就是要提高代码质量, 而高质量的代码指标个人认为有如下几点, 当然其实也是老生常谈的几点. 排名分先后: 1, 可读性 规范一致性. 结构, 层次明了. 命名有含义, 注释要清晰. 逻辑简短, 没有长篇大幅的代码块. 方法提取, 类继承关系合理. 不滥用设计模式. 聪明是可读性的敌人. 2, 可维护性 杜绝魔鬼数字/字符串/尺寸值/颜色值等 代码复用, 以便维护. 不写死, 预测可能的变化(但不要提前设计). 3, 可扩展性 良好的分层结构, MVx模式运用. 通过一些设计模式的使用来提高可扩展性. 开闭原则: 修改关闭, 扩展开放. 如何重构首先让我们重温下”重构”的含义: &lt;&lt;重构 — 改善既有代码的设计&gt;&gt; 这本大神作品强烈建议大家翻阅下~ 里面对重构的定义, 以及如何从一个个小的Bad Smell开始重构等都有详细的描述. 那么作为一个进行已久的Android工程, 我们应该如何重构呢?其实这是一个对症下药的问题, 针对为什么要重构提出的几个代码问题, 重构也可以分成以下几步: 1, 架构选择, 结构调整 根据App的业务场景(展示型, 交互型, 后台工具型…)选择合适的架构. 并不是说一定要选用一个架构, 比如说后台工具型的App, 可能界面不多, 也服务器的交互也少, 基本是由Service组成, 可能直接用Android原生的结构就可以. 界面较多, 且与服务器交互较多的建议选用MVP架构. 可以通过P来做数据处理, 将数据源M与展示层V解耦, 便于替换数据源或是改变UI. 根据选用的架构以及业务模块分包 2, 技术/开源库选定 ListView/RecyclerView的选择, Fragment/Activity的选择等. 根据业务特点和选择的架构, 选用相关技术/开源库支持或对当前使用的进行整理. 例如HTTP请求库, 缓存库, 图片加载库等等. 3, 确定规范 制定编码规范, 可以根据Google推荐的Java编码规范, 适当定制.例如我的项目中的基本规范. 制定代码提交规范, git flow管理流程规范等. 4, 自底而上, 由小至大 从底部开始, 也就是常说的Model层,数据层开始, 因为这部分相对独立, 可以通过提供接口与UI层隔离. 不要一下就大面积重构, 需要逐个小的case进行重构验证, 保证当前运行. 5, 持续重构, 伴随测试 持续进行小的重构, 每次重构需要伴随测试, 保证重构结果. 提取方法, 去除重复代码. 结构调整. 融入面向对象/接口编程思想, 注意SOLID原则. 多用组合, 少用继承 …… 最好有单元测试支持. 6, 重构而非重写 不到万不得已不要想重写. 重写会产生各种意想不到的问题, 诸如设计过度, 对于当前代码把握不够(例如现在看起来很不友好的代码可能就是为了解决一个架构无法解决的问题等). 附–关于架构重构的规则写完此文, 偶然机会在InfoQ上看到Uber的技术主管Raffi Krikorian在 O’Reilly Software Architecture conference上谈及的关于架构重构的12条规则, 共勉之:","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"重构","slug":"重构","permalink":"http://blog.lmj.wiki/tags/重构/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"冒泡排序","slug":"algorithm/bubble_sort","date":"2016-06-02T15:25:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/06/02/algorithm/bubble_sort/","link":"","permalink":"http://blog.lmj.wiki/2016/06/02/algorithm/bubble_sort/","excerpt":"概念一种类似于水底气泡(轻的物体)上浮的排序方式. 从后向前依次向前比较相邻元素, 如果顺序错误则交换位置, 重复进行此操作直至没有再需要交换为止.","text":"概念一种类似于水底气泡(轻的物体)上浮的排序方式. 从后向前依次向前比较相邻元素, 如果顺序错误则交换位置, 重复进行此操作直至没有再需要交换为止. 步骤 从后向前, 先取最末尾的元素与其前一元素比较, 如果小则交换, 否则跳过. 依次取倒数第N位的元素与其前一元素比较, 如果小则交换, 否则跳过. 做N次循环1,2步操作, 也就是有N个泡上冒, 完成排序. 实现Java实现1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.mingjun.algorithm.sort;/** * Created by mingjun on 16/6/1. */public class BubbleSort &#123; private int[] sort(int[] a) &#123; int size = a.length; int temp; // 外层循环执行N遍, 持续将末尾元素往上冒. for (int i = 0; i &lt; size; i++) &#123; // 内部循环中依次比较相邻元素. // 此处j &gt; i的条件判断是一种优化, 可以用j &gt; 0代替. // 因为i指向的之前的元素已经是最小元素(序列), 无需再与a[j]比较. for (int j = size - 1; j &gt; i; j--) &#123; // 比较并交换位置. if (a[j] &lt; a[j-1]) &#123; temp = a[j]; a[j] = a[j-1]; a[j-1] = temp; &#125; &#125; &#125; return a; &#125; public static void main(String[] args) &#123; BubbleSort bubbleSort = new BubbleSort(); int[] nums = &#123;3, 8, 22, 0, 24, 32, 12, 5, 7, 23, 9, 3&#125;; nums = bubbleSort.sort(nums); for (int num : nums) &#123; System.out.print(num + \",\"); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.lmj.wiki/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.lmj.wiki/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://blog.lmj.wiki/categories/算法/"}]},{"title":"归并排序","slug":"algorithm/merge_sort","date":"2016-05-31T15:25:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/05/31/algorithm/merge_sort/","link":"","permalink":"http://blog.lmj.wiki/2016/05/31/algorithm/merge_sort/","excerpt":"概念该算法是分治法的典型应用, 先使每个子序列有序, 然后依次将有序列表合并, merge成一个有序列表.","text":"概念该算法是分治法的典型应用, 先使每个子序列有序, 然后依次将有序列表合并, merge成一个有序列表. 步骤 将待排序序列大致平分成两个子序列. 递归对两个子序列分别进行归并排序. 合并排好序的子序列: 1, 申请一个temp序列, 存放排好序的元素, 大小为两个子序列的大小之和. 2, 依次从两个有序列表中取元素比较, 将小的放入temp序列中. 3, 将两个子序列中剩余元素添加到temp序列后面. 4, 将temp序列根据对应位置copy到待排序序列中. 实现Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.mingjun.algorithm.sort;/** * Created by mingjun on 16/5/31. */public class MergeSort &#123; /** * 1, 分子序列 * 2, 递归至最小子序列, 排序 * 3, 依次合并两个有序子序列 */ /** * 合并序列a的两个有序子序列, 并写入到a的相应位置中. * @param a 待排序序列 * @param first 左子序列的起始位置 * @param mid 左子序列的结束位置 * @param last 右子序列的结束位置 */ private void merge(int[] a, int first, int mid, int last) &#123; // 1, 创建一个大小为两个子序列大小之和的temp序列 int[] temp = new int[last - first + 1]; // i 为左子序列的index, 起始位置为first. int i = first; // j 为右子序列的index, 起始位置为mid + 1. int j = mid + 1; // k 为temp序列的index, 起始位置为0. int k = 0; // 2, 依次从两个子序列中拿出元素来比较, 小的写入到temp序列中, 并从原子序列中拿出. while (i &lt;= mid &amp;&amp; j &lt;= last) &#123; if (a[i] &lt;= a[j]) &#123; temp[k++] = a[i++]; &#125; else &#123; temp[k++] = a[j++]; &#125; &#125; // 3, 如果左子序列中还有元素, append到temp序列后. while (i &lt;= mid) &#123; temp[k++] = a[i++]; &#125; // 4, 如果左子序列中还有元素, append到temp序列后. while (j &lt;= last) &#123; temp[k++] = a[j++]; &#125; // 5, 将temp序列copy到a序列中相应位置. System.arraycopy(temp, 0, a, first, temp.length); &#125; private int[] sort(int[] a, int first, int last) &#123; if (first &lt; last) &#123; int mid = (last + first) / 2; // 1, 对左子序列排序 sort(a, first, mid); // 2, 对右子序列排序 sort(a, mid + 1, last); // 3, 合并两个子序列 merge(a, first, mid, last); &#125; return a; &#125; public static void main(String[] args) &#123; MergeSort mergeSort = new MergeSort(); int[] nums = &#123;3, 8, 22, 0, 24, 32, 12, 5, 7, 23, 9, 3&#125;; mergeSort.sort(nums, 0, nums.length - 1); for (int num : nums) &#123; System.out.print(num + \",\"); &#125; &#125;&#125; Python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# encoding: utf-8\"\"\"@author: anly_jun@file: merge.py@time: 16/8/14 下午5:39\"\"\"def merge(left, right): i = 0 j = 0 temp = [] # 依次从两个子序列中拿出元素来比较, 小的写入到temp序列中, 并将其游标+1. while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: temp.append(left[i]) i += 1 else: temp.append(right[j]) j += 1 # 如果左子序列中还有元素, 添加到temp序列后. temp += left[i:] # 如果左子序列中还有元素, 添加到temp序列后. temp += right[j:] return tempdef sort(nums): if len(nums) &lt;= 1: return nums mid = int(len(nums) / 2) # 递归排序左序列 left = sort(nums[:mid]) # 递归排序右序列 right = sort(nums[mid:]) # merge return merge(left, right)if __name__ == '__main__': a = [3, 8, 22, 0, 24, 32, 12, 5, 7, 23, 9, 3] result = sort(a) print(result)","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.lmj.wiki/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.lmj.wiki/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://blog.lmj.wiki/categories/算法/"}]},{"title":"我的Mac常用应用与配置","slug":"tools/mac_dev_env","date":"2016-01-05T02:09:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2016/01/05/tools/mac_dev_env/","link":"","permalink":"http://blog.lmj.wiki/2016/01/05/tools/mac_dev_env/","excerpt":"前言转眼使用Mac平台开发已经一年有余，自进入程序猿这个职业以来，从职业之初的J2EE，到Android App，再到Android ROM开发，到如今的专注于移动端，开发系统也一路从Windows到Ubuntu，再到Mac OSX，这其中不仅仅是操作系统平台的变迁，也见证了一个程序猿的职业生涯发展历程。在此也不敢妄谈这些操作系统的好坏，只是根据不同阶段不同开发的选择而已。","text":"前言转眼使用Mac平台开发已经一年有余，自进入程序猿这个职业以来，从职业之初的J2EE，到Android App，再到Android ROM开发，到如今的专注于移动端，开发系统也一路从Windows到Ubuntu，再到Mac OSX，这其中不仅仅是操作系统平台的变迁，也见证了一个程序猿的职业生涯发展历程。在此也不敢妄谈这些操作系统的好坏，只是根据不同阶段不同开发的选择而已。 Mac OS X功能键默认情况下，Mac上的功能键F1~F12优先是用来控制快捷功能的，例如键盘亮度，屏幕亮度，音量等。需要使用正常的F1~F12的功能时，需要同时按住Fn，这个对于一个编程人员来说是极不方便的。例如我们常用的F3跳转到方法、变量声明处。。。等等。可在”设置”—“键盘”中将其设置成标准功能键功能： 快捷键常用Mac OS X快捷键 截屏开发以及日常工作中，我们经常需要对屏幕进行截图。常用的有对整个屏幕截图和选取区域截图： 全屏截图（Shift+Command+3） 选取截图（Shift+Command+4） 如何在Mac OS X上截取屏幕截图 输入法个人推荐百度输入法，之前也用过一段时间的搜狗，感觉还是百度输入法功能相对更强大点。 开发环境目前个人主要使用Mac还是用来做Android App的开发，偶尔写点iOS和python的小程序，做些项目管理的事情。故而Mac的配置多与此相关. IDEAndroid Studio自从Google宣布Eclipse不再支持后，Android Studio已经成为Android官方的唯一IDE了。而且从这一年多的使用过程来看，Android Studio已经到2.0版本，越来越强大，而且越来越好用了，个人也是极力推荐的。 搭建Android开发环境，包含JAVA环境搭建。 Android Studio常用配置 Xcode使用Mac开发，Xcode也是必然要安装的，一个是偶尔会写写iOS的程序，另外一个有些软件特别是某些破解程序也需要Xcode的运行环境,主要是Command Line Tools. PyCharm作为一个业余的Python程序员，更多的还是依赖IDE来做python编程。PyCharm有两个版本，Professional和Community，其中Community是免费的。个人在使用过程中觉得已然够用。下载地址 常用工具HomebrewHomebrew是Mac上大名鼎鼎的包管理工具，从Ubuntu系统迁移过来的人对此简直毫无抵抗力。安装方式也很简单，可参看官网。有了homebrew，我们就可以像“apt-get”一样安装包工具了： 1brew install mysql 安装 brew 的时候会自动下载和安装 Apple 的 Command Line Tools。 Homebrew CaskHomebrew Cask可以让你使用命令行来安装OS X应用。几乎所有常用的应用都可以通过”brew-cask”来安装，而且是从应用的官网上下载。如果你不知道应用在“brew-cask”中的 ID，可以先用“brew cask search”命令搜索。Homebrew Cask可以理解为是Homebrew的增强版，二者的区别是Homebrew是下载源码然后make install的方式安装，主要针对开源的工具类的应用，而Homebrew Cask实际上我们普通的下载dmg/pkg包安装的命令行版本，它下载的是编译好的应用包，所以它几乎可以用来安装所有的应用，例如安装Chrome： 1brew cask install google-chrome Homebrew Cask的安装方式请参看官网。 iTerm2iTerm2是OS X中Terminal的替代品，个人认为简直就是程序员必备。有了Homebrew Cask，我们安装iTerm2也更简单了： 1brew cask install iterm2 iTerm2提供了很多Terminal不具备的特性，具体的使用可以读一读官方提供的使用文档。 Oh My Zsh有了iTerm2，我们的命令行工具还不能称之为强大，需要配合上Oh My Zsh这把尖刀，它可以让你从黑白时代立马跨入多彩的世界，而且有很多很好用的插件，来帮助我们简化命令，让我们爱上命令行操作。安装方式如下： 1$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; PythonPython环境也是必须要有的，写点小脚本啦，还有作为Android程序员，下载Android Source Code也是需要Python环境的。我们可以在官网下载Mac OSX相对应的版本安装，当然有了Homebrew，最快捷的安装方式当然是： 1brew install python 另外，python开发环境中pip工具也是必不可少的，安装方式如下： 1sudo easy_install pip pip是Python的包管理工具。 Git随着技术发展，版本管理工具中Git已经是越来越流行，它强大的功能，敏捷的命令行操作方式以及与SVN等集中式版本管理库的根本区别，也让它在我们当今随处办公、敏捷开发的趋势中脱颖而出了。所以个人认为Git已经是程序员技能库里面必不可少的了。安装方式也可以使用brew方式： 1brew install git Git常用别名 Git教程 Mou作为一个程序员，写文档必然推荐Markdown。Mou是一个OS X下针对程序员使用的免费的Markdown编辑器。具有实时预览，自动补全，自动保存等功能，界面也非常友好。 CheatSheet刚刚迁移到Mac系统时可能对各种快捷键都不熟悉，不习惯。CheatSheet能够显示当前程序的快捷键列表，默认长按Command ⌘键即可显示： 免费应用，可以直接在官网下载安装,或者： 1brew cask install cheatsheet Sublime Text在Windows系统用Notepad或是EditPlus作为文本编辑器习惯了，Sublime Text我认为是OS X平台上与上述编辑器最接近我的需求的，且Sublime Text的功能可能还更强大，因为其有众多的插件支持。安装方式，我们可以在官网下载安装，也可以直接使用brew cask安装： 1brew cask install sublime-text 日常工作Microsoft Office 2016Office套件，包含word，excel，ppt和outlook，装机必备。破解版密码：wgf4 OmniGraffle下载地址密码：8nb9 Evernote笔记应用，也可以使用有道云笔记。 Chrome默认浏览器Safari的替代者。 XMind思维导图应用。有更好的，但是这个有免费版，且够用。 项目管理OmniPlan非常好的项目管理软件，爱不释手。下载地址密码：kgmb 其他工具科学上网GoAgentX百度上搜不到相关信息，请参考Github上的相关Project 虚拟机Parallels Desktop破解版下载地址密码：32n6 抓包工具Charles破解方式 数据库工具SQLite ProfessionalNTFS磁盘工具Windows下的磁盘格式大部分都是NTFS的，而Mac平台默认不支持，故而可能导致我们的U盘，移动硬盘等在Mac上无法识别，或是可读不可写。在此推荐如下工具： tuxerantfs下载地址密码：nc8a 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/tags/Tools/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}]},{"title":"Retrofit的Log输出","slug":"android/retrofit2-log","date":"2015-12-31T07:34:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2015/12/31/android/retrofit2-log/","link":"","permalink":"http://blog.lmj.wiki/2015/12/31/android/retrofit2-log/","excerpt":"背景最近公司项目App改版，大家把之前一期时用到的一些优秀的开源库重新捋了一下。 Retrofit作为Java以及Android的Rest Client实现，帮助我们封装了大量的繁琐实现，让我们可以像调用接口一样做HTTP请求，使代码更加简洁而具有可读性。然而，高度的抽象封装也让我们不太容易更深入的了解我们的HTTP请求过程，对于刚接触的同学来说，学习成本较高，且不太利于在调试过程中定位问题。","text":"背景最近公司项目App改版，大家把之前一期时用到的一些优秀的开源库重新捋了一下。 Retrofit作为Java以及Android的Rest Client实现，帮助我们封装了大量的繁琐实现，让我们可以像调用接口一样做HTTP请求，使代码更加简洁而具有可读性。然而，高度的抽象封装也让我们不太容易更深入的了解我们的HTTP请求过程，对于刚接触的同学来说，学习成本较高，且不太利于在调试过程中定位问题。 在Retrofit 1.x的版本中，我们可以通过如下setLogLevel接口来让： 12new RestAdapter.Builder() .setLogLevel(RestAdapter.LogLevel.FULL) 问题本次改版中，我们将Retrofit替换成了2.0版本，却发现已经没有了这样类似的接口，让同学们很困惑，感觉调试很不便。然而这是为什么呢，为什么Retrofit会剔除Log这个调试利器呢？ 分析这需要从这次升级说起，具体升级说明请参看Jake大神的演讲。 我觉得Retrofit的此次大版本升级更专注了其作为Rest Client的职能，关注与Rest架构中Client端的事情。Http的相关工作都完全交由Square自家开发的OkHttp完成，且不再可定制HttpClient。可以简单的理解其目标的层次结构如下： 不难理解，Retrofit升级后作为一个完全而单一Rest Client实现，是一个上层架构实现，简单来说只是一个帮助我们以Rest架构做Http请求的实现，本就不应该由其输出Http的相关Log了。那么我们怎么输出Http的相关Log呢？根据上图，我们只能寄希望于OkHttp了。 OkHttp的Interceptors回答这个问题之前，我们先来看下OkHttp中的Interceptors。Interceptor，顾名思义，拦截器，可以帮助我们拦截所有的request，response，已对其进行监视、重写、重试等。例如我们可以通过Interceptor来给我们所有的request加上相同的header，对所有的response做重写处理，例如加上Cache-Control等。关于Interceptor的原理以及其实现方式，在此我们就不展开了，官网扯的一张图，大家先看着，有时间我们单独扒一扒这块的实现，对我们的编程理念也是很有帮助的： 说到着，同学们可能就明白了，既然我们可以拦截到request和response，当然我们也可以很轻易的Log出它们了。这不就达到了我们打印Http请求和响应的目的了吗。 HttpLoggingInterceptor牛逼如Square肯定也不会忽视我们这个常用的需求，已经帮我们实现好了一个Log Interceptor，感谢开源，感谢Square。 12// 具体实现可以查看源码HttpLoggingInterceptor implements Interceptor 类似于Retrofit 1.x的Log Level, HttpLoggingInterceptor也提供了几种Level： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public enum Level &#123; /** No logs. */ NONE, /** * Logs request and response lines. * &lt;p&gt; * Example: * &lt;pre&gt;&#123;@code * --&gt; POST /greeting HTTP/1.1 (3-byte body) * * &lt;-- HTTP/1.1 200 OK (22ms, 6-byte body) * &#125;&lt;/pre&gt; */ BASIC, /** * Logs request and response lines and their respective headers. * &lt;p&gt; * Example: * &lt;pre&gt;&#123;@code * --&gt; POST /greeting HTTP/1.1 * Host: example.com * Content-Type: plain/text * Content-Length: 3 * --&gt; END POST * * &lt;-- HTTP/1.1 200 OK (22ms) * Content-Type: plain/text * Content-Length: 6 * &lt;-- END HTTP * &#125;&lt;/pre&gt; */ HEADERS, /** * Logs request and response lines and their respective headers and bodies (if present). * &lt;p&gt; * Example: * &lt;pre&gt;&#123;@code * --&gt; POST /greeting HTTP/1.1 * Host: example.com * Content-Type: plain/text * Content-Length: 3 * * Hi? * --&gt; END GET * * &lt;-- HTTP/1.1 200 OK (22ms) * Content-Type: plain/text * Content-Length: 6 * * Hello! * &lt;-- END HTTP * &#125;&lt;/pre&gt; */ BODY &#125; 对于我们的调试需求来说，一般使用BODY级别就可以了。 解决综上，我们的解决方案也就出来了，正常来说直接使用OkHttp提供的HttpLoggingInterceptor就可以了，当然如果你有一些自定义的log输出方式，也可以继承HttpLoggingInterceptor，或实现Interceptor自定义了。 附上代码： 1234567891011121314if (BuildConfig.DEBUG) &#123; HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor(); loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); // client means OkHttpClient client.interceptors().add(loggingInterceptor);&#125;``` 当然为了使用HttpLoggingInterceptor，因为其包含在OkHttp的一个单独库okhttp-logging-interceptor中，惯例，我们需要在Application的build.gradle中import此库：```java// OkHttp logging interceptor// https://github.com/square/okhttp/wiki/Interceptorscompile 'com.squareup.okhttp:logging-interceptor:2.7.0' 注意：OkHttp的Interceptor必须是OkHttp 2.2及以上可用，且与Retrofit &lt;= 1.8, Picasso &lt;= 2.4不可兼容使用。 结语这本是一个很小的需求，但是能引导我们更深入去了解开源库的具体实现，以及其发展完善的方向。了解其实现才可能更好的使用，也让我们可以在自己的编码上考虑得更多，更完美。 正所谓知其然知其所以然，共勉之。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://blog.lmj.wiki/tags/Retrofit/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"Android App开发规范","slug":"android/android-code-rules","date":"2015-12-15T08:43:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2015/12/15/android/android-code-rules/","link":"","permalink":"http://blog.lmj.wiki/2015/12/15/android/android-code-rules/","excerpt":"一些约定 类中public方法在前，private在后，所有不对外的方法，变量全部使用private修饰符。类中public static final的常量在最上方，其次private static final，然后public，private等。 类中定义的接口放在变量声明之后，所有方法之前。 方法相关性，方法之间有调用关系的，按照先后顺序排列在一起。 善用空行，方法体之间必须空行，代码逻辑块之间使用空行分隔，变量声明根据变量类型适当空行。 方法体不要过长，尽量提取小方法代替逻辑块，保证代码可读性。 善用TODO，对于未完成或已完成但是方案不完美需后续跟踪的，使用TODO标签标示，并写好注释。 不建议注释太多，要通过方法名，变量名提高代码可读性，而非注释。但是一些非常规方法，复杂逻辑，需要详细注释说明。 协作中，不要做整个代码的格式化，仅格式化自己编写的那部分。 注意命名以及注释英文单词，不要写错~ 杜绝“Magic Number”, 所有数值根据情况提取为常量，dimen或constant。","text":"一些约定 类中public方法在前，private在后，所有不对外的方法，变量全部使用private修饰符。类中public static final的常量在最上方，其次private static final，然后public，private等。 类中定义的接口放在变量声明之后，所有方法之前。 方法相关性，方法之间有调用关系的，按照先后顺序排列在一起。 善用空行，方法体之间必须空行，代码逻辑块之间使用空行分隔，变量声明根据变量类型适当空行。 方法体不要过长，尽量提取小方法代替逻辑块，保证代码可读性。 善用TODO，对于未完成或已完成但是方案不完美需后续跟踪的，使用TODO标签标示，并写好注释。 不建议注释太多，要通过方法名，变量名提高代码可读性，而非注释。但是一些非常规方法，复杂逻辑，需要详细注释说明。 协作中，不要做整个代码的格式化，仅格式化自己编写的那部分。 注意命名以及注释英文单词，不要写错~ 杜绝“Magic Number”, 所有数值根据情况提取为常量，dimen或constant。 代码规范 使用Android Studio提供的格式化规范。 命名规范1. Java命名 分类 命名方式 举例 说明 包名 全小写 com.cicaero.kite 公司域名倒序，“.”分隔，单个包名建议不超过12个字母 类名 首字母大写的驼峰 UserInfo 名词形式 接口名 首字母大写的驼峰 ServerInterface 名字形式 方法名 驼峰 getUserInfo 动词结构，含义为一个动作 常量 全大写，单词下划线分隔 MSG_UPDATE_PROGRESS 建议数值类常量从1开始，且根据功能预留数段 成员变量 m/s/is/has开头的驼峰 mImageUrl 正常成员m开头，静态s开头，布尔型is/has开头. Bean类命令例外, 建议使用局部变量的命名方式. 局部变量 首字母小写的驼峰 currentPosition 名词形式，除非是循环，否则不建议使用i，j，k等简单变量名 2. 资源命名 分类 命名方式 举例 说明 布局 全小写，单词下划线分隔 activity_main.xml Activity以activity开头，Fragment以fragment开头，list、grid项以item开头，Dialog布局以dialog开头，自定义View以layout开头，其他被include的或公用组件，诸如title_bar,bottom_bar,根据实际含义命名 Drawable 全小写，单词下划线分隔 btn_bg.png 根据图片使用方式命名， 图标以ic_开头，背景以_bg结尾，状态drawable xml以_selector结尾。 Color 全小写，单词下划线分隔 green 尽量根据颜色值命名 String 全小写，单词下划线分隔 app_name 模块多且大的话，根据模块建立不同的String xml 文件 style 首字母大写的驼峰 NoTitleTheme 类似类名，style本身也是有类似类的集成关系 dimension 全小写，单词下划线分隔 left_padding id 全小写，单词下划线分隔 user_name_tv 详细id命名规范参考以下章节 3. 布局文件中的View id命名 View 结尾命名规则 TextView tv Button btn EditText et ImageView iv ImageButton img_btn RadioButton rb RadioGroup rg SeekBar seek ProgressBar progress Spinner spinner VideoView vv CheckBox cb ListView lv GridView grid Layout lt 其他建议 Gradle引入第三方库时comment加上库地址. 编译相关的常量写入编译脚本.","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"项目管理","slug":"项目管理","permalink":"http://blog.lmj.wiki/tags/项目管理/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"Git别名","slug":"tools/Git-alais","date":"2015-11-22T10:41:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2015/11/22/tools/Git-alais/","link":"","permalink":"http://blog.lmj.wiki/2015/11/22/tools/Git-alais/","excerpt":"个人常用git命令别名：","text":"个人常用git命令别名： 123456789[alias] amend = commit --amend -a br = branch co = checkout ds = diff --staged di = diff lg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit log-me = !UN=$(git config user.name)&amp;&amp; git log --author=&quot;\\&quot;$UN\\&quot;&quot; --pretty=format:&apos;%h %cd %s&apos; --date=short st = status 当然如果你安装了Oh My Zsh, 它提供了一系列的系统别名，其中就有git相关的，且git插件是默认开启的。这个在敏捷团队开发中是极推荐的，因为大家经常会有结对编程的时候，保持相同的快捷键以及别名对工作效率是有很大提升的。Oh My Zsh的git别名： Alias Command gapa| git add --patchgc! | git commit -v --amendgcl | git clone --recursivegclean| git reset --hard &amp;&amp; git clean -dfxgcm | git checkout mastergcmsg | git commit -mgco | git checkoutgd | git diffgdca | git diff --cachedglola | git log --graph --pretty = format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --allgp | git pushgrbc | git rebase --continuegst | git statusgup | git pull --rebasegwip | git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit -m &quot;--wip--&quot; 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/tags/Tools/"},{"name":"Git","slug":"Git","permalink":"http://blog.lmj.wiki/tags/Git/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}]},{"title":"关于git-review的使用","slug":"tools/git-review","date":"2015-11-22T07:34:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2015/11/22/tools/git-review/","link":"","permalink":"http://blog.lmj.wiki/2015/11/22/tools/git-review/","excerpt":"引子项目中引入Gerrit作为Code Review是工具后，提交代码到远程库的命令与之前略有不同，具体请参考Gerrit日常使用。命令变得更长，且如果不是特别理解Gerrit的用法的话很难记，在此推荐几种简化方式。","text":"引子项目中引入Gerrit作为Code Review是工具后，提交代码到远程库的命令与之前略有不同，具体请参考Gerrit日常使用。命令变得更长，且如果不是特别理解Gerrit的用法的话很难记，在此推荐几种简化方式。 别名最基础的方式，我们可以跟之前命名git命令别名一样，定义一个别名来简化我们的命令，例如： 1$ git config alias.push-for-review &quot;push origin HEAD:refs/for/master” 这样我们在提交code review的时候就可以直接敲： 1$ git push-for-review 即可将我们的commit提交到Gerrit。 git-review工具在此推荐一个git review工具，此工具不仅仅帮我们处理提交，实际上，它满足我们code review的所有需求—提交代码，下载patch review，多feature的并行开发提交等。 安装 Mac OS X直接在终端执行如下命令即可： 1$ brew install git-review 没有安装brew的请自行google. Windows首先得安装Python环境（确保安装且配置环境变量到path中），然后打开Git Bash，使用pip安装： 1$ install git-review 配置 配置远程库为了告诉git-remote我们的远程库信息，需要在我们的工程根目录下创建一个名为.gitreview的文件，内容如下： 12345[gerrit]host=review.cicaero.comport=29418project=cic-androiddefaultbranch=luckyair host，project是强制的，port默认为29418，defaultbranch默认为master 配置使用git-review设置工程的提交使用git-review，需要执行：12$ cd MyNewProj$ git review -s 可能会提示输入git username，输入即可。此命令实际上执行了以下操作： 检查是否可以访问到远程库 如果不能，提示输入username后重试 创建一个名为”gerrit“的节点指向Gerrit 安装commit-msg这个钩子 注意：此处的”gerrit“节点，请结合”origin“理解。简单来说可以理解为是一个远程地址的缩写： 12345// originremote.origin.url=ssh://xxxxxx@review.cicaero.com:29418/cic-android// gerritremote.gerrit.url=ssh://xxxxxx@review.cicaero.com:29418/cic-android 实际上由于目前我们的代码就是从gerrit上clone得到的，我们通过git config -l看到的origin和gerrit是一样的。 提交一个Change配置好git review之后，我们提交一个Change将变得很简单： 12345$ git checkout -b feature1change files$ git add$ git commit$ git review 执行git review时实际上做了如下事情： 根据.gitreview的配置寻找要提交到哪个branch，如果没有配置，默认提交到master。 rebase你的change到你将提交到的远程branch的HEAD上。（可使用-R忽略此操作） 如果你一次提交了多个change，或是提交的change是基于另外一个还没有merge入库的change的，会提示你是否确定要提交。（可使用-y忽略） 提交到gerrit。 下载一个Change在Gerrit日常使用中也有提到如何下载一个Change到本地，git review工具也帮我们集成了这个功能。例如，http://review.cicaero.com:9090/#/c/568/这个Change，使用git review下载的方式如下： 1$ git review -d 568 此命令会下载这个Change，并将其放在一个”review/AUTHOR/TAG“的分支，如果没有tag，将会使用changeId。并切换到该分支。 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.lmj.wiki/tags/Git/"},{"name":"CodeReview","slug":"CodeReview","permalink":"http://blog.lmj.wiki/tags/CodeReview/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}]},{"title":"Gerrit日常使用","slug":"tools/gerrit","date":"2015-11-19T14:59:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2015/11/19/tools/gerrit/","link":"","permalink":"http://blog.lmj.wiki/2015/11/19/tools/gerrit/","excerpt":"1, Gerrit是什么？Gerrit实际上一个Git服务器，它为在其服务器上托管的Git仓库提供一系列权限控制，以及一个用来做Code Review是Web前台页面。当然，其主要功能就是用来做Code Review。","text":"1, Gerrit是什么？Gerrit实际上一个Git服务器，它为在其服务器上托管的Git仓库提供一系列权限控制，以及一个用来做Code Review是Web前台页面。当然，其主要功能就是用来做Code Review。 2, Gerrit用户配置 Email激活 Gerrit账户的设置界面，点击“Contact Information”进入Email Register页面，输入自己的邮箱账户（此邮箱需要与自己的Git配置一致）。可以配置多个Email账号。 SSH key配置通过以下命令生成并读取本机ssh key:12ssh-keygen -t rsacat ~/.ssh/id_rsa.pub Copy key的内容，在Gerrit账户的设置页面“SSH Public Key”中加入即可。 3, Gerrit日常使用3.1 获取代码库登录Gerrit后在Projects–&gt;List, 选择相应工程your_project，进入该工程的General界面。选中“clone with commit-msg hook”和“SSH”: 1git clone ssh://your_account@review.xxxxx.com:29418/your_project &amp;&amp; scp -p -P 29418 your_account@review.xxxxx.com:hooks/commit-msg cic-android/.git/hooks/ 拷贝以上命令在自己本地Git命令行窗口执行即可拉取库代码。 3.2 Gerrit工作流程3.2.1 上传一个commitGerrit相对Git提供了一个特有的命名空间“refs/for/”用来定义我们的提交上传到哪个branch，且可以用来区分我们的commit是提交到Gerrit进行审核还是直接提交到Git仓库，格式如下： 1refs/for/&lt;target-branch&gt; Push一个Commit到Gerrit: 12$ git commit$ git push origin HEAD:refs/for/master 直接Push一个commit到Git仓库:(我们默认配置成不允许)12$ git commit$ git push origin HEAD:master 当我们的commit Push到Gerrit等待review时，Gerrit会将此commit保存在一个名为“refs/changes/xx/yy/zz”的一个暂存branch中。其中zz为这个commit的patch set号，yy是change号，xx是change号的后两位。 例如我们工程中的这个大明同学的提交：1http://review.xxxxx.com:9090/#/c/545/ 一共提交了9次patch，那么第9个patch就保存在一个名为“refs/changes/45/545/9”的branch中。 可以通过Gerrit页面中该commit右上角的Download按钮验证,比如说我们选择“Cherry Pick”, 命令如下： 1git fetch ssh://your_account@review.xxxxx.com:29418/your_project refs/changes/45/545/9 &amp;&amp; git cherry-pick FETCH_HEAD 在此，有必要说下几个概念，以便理解： Change一个Change包含一个Change-Id，这个Id就是通过我们拉取代码库的时候所拷贝的hooks（hooks/commit-msg）自动生成的。包含一个或多个Patch Set，以及诸如Owner，Project，Target branch,Comments等信息。 Change-IdChange-Id是一串SHA-1字符串。有hooks自动生成在我们的commit message下面： 12345Feature:Music play.BugId:/Description:Music play.Change-Id: I3d087f04d9d94bfaa93b8609b988b300af537497 在一个project的每个branch中Change Id是唯一的。 Patch Set一个Patch Set就是一次commit，Gerrit会将其生成一个Branch暂存。Change中的每提交一个Patch Set表示这个Change的一个新的版本，自动覆盖前一个Patch Set， 默认情况下，仅最后一个Patch Set是有意义的。Code Review通过时，也仅仅是最后一个Patch Set会合并到指定的branch中。 个人Git工作原则一 永远是基于远程库的最新代码工作，尽量每一步操作（特别是add/commit/push）都通过git pull –rebase获取一下当前最新版本。 根据以上原则，建议在将本地commit push到Gerrit之后，立马reset掉，或者重新切换一个新的分支工作。 3.2.2 上传一个新的patch set当我们的commit被reviewer打回来时，我们可能需要修改并重新提交。如果我们的代码在本地分支已经reset掉，可以通过Gerrit页面提供的Download方式获取： 123// fetch and checkout the change// (checkout command copied from change screen)$ git fetch ssh://your_account@review.xxxxx.com:29418/your_project refs/changes/45/545/9 &amp;&amp; git checkout FETCH_HEAD 如果之前是通过切换分支方式工作的，可以重新切换回包含此commit的分支而无需执行上述命令，然后可以在此代码基础上进行修改，重新add，amend commit: 123456789// rework the change$ git add &lt;path-of-reworked-file&gt;...// amend commit$ git commit --amend// push patch set$ git push origin HEAD:refs/for/master 3.2.3 添加Reviewers在Change界面添加相关reviewers.可以考虑使用自动添加reviewers的插件 3.2.4 提交ChangeChange一般配置成只有在Code-Review +2 以及Verified +1 的情况下才可以Submit。 Submit时可能会有冲突，界面会提示“Cannot Merge”字样，此时可以先尝试Gerrit页面提供的Rebase功能做一次Rebase操作，如果提示冲突，则需在本地解决冲突后重新提交一个Patch Set到该Change上。 本地Rebase的一种流程: 12345678910111213141516171819// update the remote tracking branches$ git fetch// fetch and checkout the change// (checkout command copied from change screen)$ git fetch ssh://your_account@review.xxxxx.com:29418/your_project refs/changes/74/67374/2 &amp;&amp; git checkout FETCH_HEAD// do the rebase$ git rebase origin/master// resolve conflicts if needed and stage the conflict resolution ...$ git add &lt;path-of-file-with-conflicts-resolved&gt;// continue the rebase$ git rebase --continue// push the commit with the conflict resolution as new patch set$ git push origin HEAD:refs/for/master 3.3 多Feature并行开发Code Review需要时间，开发人员可以在此期间开发其他feature，这就产生了多feature并行开发的状态。 为了保证减少冲突和依赖，每一个feature都应该是在该feature自己的本地分支开发，且此分支是基于远程分支（target branch）的当前HEAD的。 也就是基于远程库的最新代码开发，而不应该依赖于code review中的某个、某些Change。 当然，如果必要，你也可以基于一个正在code review的Change开发新的feature，这样会产生依赖，可以在Gerrit中该Change的页面看到“Related Changes”。这就要求reviewer也需要关注这个依赖关系，调整review时序。 根据以往的使用经验，强烈建议不要产生这种依赖，尽量使每一个Change提交都是无依赖的，避免Change的连环失败导致各种解冲突的工作。 个人Git工作原则二 尽可能保证每一个Change的完整性以及独立性，且越小越好。 4, 进阶功能4.1 Web页面代码修改Gerrit提供了直接在Web页面修改我们的patch代码的功能，这对于我们做一些小的问题修改（比如格式化问题，命名不对，多余的空格等)非常方便。 点击Edit后，该工具栏显示如下： 可以在此对patch的文件进行修改，删除等。如果想对文件中的某处进行编辑，点击进入该文件的review界面： 点击编辑按钮，进入编辑模式，编辑完save： 会在Change页面看到，点击Publish Edit按钮，Gerrit会自动帮你生成一个包含刚刚修改的patch。 4.2 草稿箱功能Gerrit可以作为一个自己的Change草稿箱，我们可以将一些还未完成，或者还不想提交review的Change上传至此处。一来可以作为一个备份，另外在多人互相协助完成同一个功能，或是自己在多台电脑（家里、办公室）上处理未完成的工作。不同于提交一个正式Change的“refs/for/”协议，提交一个Change到草稿箱的协议方式为“refs/drafts/”,如下： 12$ git commit$ git push origin HEAD:refs/drafts/luckyair 在Gerrit页面的Drafts栏： 草稿箱中的Change也可以很方便的转换为正式的Change，而无需重新用“refs/for/”来提交，点击Publish按钮转换为正式Change，也可以在此删除此草稿。 转载请注明出处, 欢迎大家分享到朋友圈, 微博~","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/tags/Tools/"},{"name":"Git","slug":"Git","permalink":"http://blog.lmj.wiki/tags/Git/"},{"name":"Gerrit","slug":"Gerrit","permalink":"http://blog.lmj.wiki/tags/Gerrit/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"http://blog.lmj.wiki/categories/Tools/"}]},{"title":"搭建Android开发环境","slug":"android/android-env","date":"2015-11-14T07:35:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2015/11/14/android/android-env/","link":"","permalink":"http://blog.lmj.wiki/2015/11/14/android/android-env/","excerpt":"Java开发环境JDK获取http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html Java环境变量For Mac OSX / Linux 在/etc/profile中添加","text":"Java开发环境JDK获取http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html Java环境变量For Mac OSX / Linux 在/etc/profile中添加 123456JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_75.jdk/Contents/HomeCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATH:export JAVA_HOMEexport CLASSPATHexport PATH 如果要使用Java8,安装jdk8后在上述文件再加上： 1JAVA8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home For Windows 在系统环境变量中添加JAVAHOME: 1C:\\Dev\\Java\\jdk1.7.0_75.jdk; CLASSPATH: 1.;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar; 并在系统环境变量Path后添加： 1%JAVA_HOME%\\bin; Android开发环境Android Studio安装http://developer.android.com/sdk/index.html Android环境变量For Mac OSX / Linux 在/etc/profile中添加： 1234ANDROID_HOME=/Users/mingjun/Development/Android/android-sdk-macosxPATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH:export ANDROID_HOMEexport PATH For Windows 系统环境变量中加入ANDROID_HOME: 1C:\\Dev\\Android\\android-sdk 并在环境变量Path后加入： 1%ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools NDK开发环境 在如下地址下载NDK:http://developer.android.com/ndk/downloads/index.html 执行 12ndk$ chmod a+x android-ndk-r10c-darwin-x86_64.binndk$ ./android-ndk-r10c-darwin-x86_64.bin 配置NDK环境变量 For Mac OSX / Linux 在/etc/profile中添加: 123NDK_HOME=/Users/mingjun/Development/Android/android-ndk-r10cPATH=$NDK_HOME:$PATHexport PATH For Windows 系统变量中加入NDK_HOME: 1C:\\Dev\\Android\\android-ndk-r10c 并在Path后加入: 1$NDK_HOME","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"[译]Processes and Threads","slug":"docs/Processes and Threads","date":"2013-06-25T14:44:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2013/06/25/docs/Processes and Threads/","link":"","permalink":"http://blog.lmj.wiki/2013/06/25/docs/Processes and Threads/","excerpt":"Processes and Threads当一个application组件启动时，系统会启动一个单线程的Linux进程来执行它。默认情况下，同一个application的所有组件都运行在相同的一个进程和线程（该线程我们通常称之为主线程“main thread”或UI线程“UI thread”）里。当然，你可以让你的application的组件运行在不同进程，也可以在任意进程中创建额外的线程。","text":"Processes and Threads当一个application组件启动时，系统会启动一个单线程的Linux进程来执行它。默认情况下，同一个application的所有组件都运行在相同的一个进程和线程（该线程我们通常称之为主线程“main thread”或UI线程“UI thread”）里。当然，你可以让你的application的组件运行在不同进程，也可以在任意进程中创建额外的线程。 Processes默认情况下，相同application的所有组件都运行在同一个进程中，而且大多数情况下，你也没有必要去修改此点。当然，当你确实需要指定不同组件运行在不同进程时，你可以在manifest文件中指定。manifest文件声明, , , 时，都有一个属性“android:process”来让你指定该组件所运行的进程。你也可以为不同application的组件指定一个相同的进程，以便分享数据。不同的application分享同样的Linux user ID，且具有相当的签名。 标签也支持“android:process”属性，来设置改application的所有组件所运行的进程。 当可用内存很小，且有更直接服务用户的进程请求内存时，Android系统可能会杀死进程。被杀死的进程里所有application组件将随之被销毁(destroyed)。当这些组件再次运行时该进程会重新启动。Android系统会根据进程的相对重要关系来决定杀死哪些进程。例如，保留那些不可见activity的进程相比于保留可见activityde进程更容易被杀死。总来的说，决定杀死哪个进程，取决于该进程中所运行的组件状态。规则稍后将在以下章节讨论。 Process lifecycleAndroid系统尽可能的去维护每个application的进程，但是最终总会为了新的、更重要的进程而删除、杀死旧的进程。系统根据进程的重要级别（importance hierarchy）来决定哪些进程应该被杀死，哪些应该保留。系统将重要级别分成五个等级，根据重要性排列如下： Foreground process（前台进程）用户正在操作的组件所在进程。以下几种情况的进程将被视为前台进程： 用户正在交互的activity（该activity的onResume方法已被调用）所运行的进程。 用户正在交互的activity绑定的service所运行的进程。 前台service（调用了startForeground的service，具体参见Service）所运行的进程. 正在执行生命周期回调（onCreate、onStart、onDestroy）的service所运行的进程。 正在执行onReceive的BroadcastReceiver所运行的进程。通常，在一定时间内只有很少的一部分进程是前台进程。他们在极端情况下才会被杀死—–内存低到前台进程都无法正常运行的情况。 Visible process（可见进程）不包含任何前台组件，但是还是可以影响用户所见的进程。有以下两者之一的进程被视为可见进程： 包含的activity不在前台，但是还是可见（onPause被执行，onStop未执行）。比如前台dialog覆盖下的activity。 可见activity绑定的service运行的进程。 可是进程也被认为是极端重要的，除非是为了保证前台进程的运行才会被杀死。 Service process（服务进程）运行一个通过startService()方法启动的service，且不属于以上两种类型的进程。虽然服务进程不绑定任何用户看到的，但是通常来说该service做的事情是用户关心的（例如在后台播放音乐或是下载文件等），所以系统会保证其运行除非没有足够内存来运行前台进程和可见进程。 Background process（后台进程）保留一个当前不可见的activity（onStop被执行）的进程。这些进程不会直接影响用户体验，所以系统会随时回收它们来保证前台、可见、服务进程的运行。它们会被保存在一个LRU（least recently used）队列里，以此来保证最近被用户看到的activity所在的进程是最后被杀死的。如果activity正确实现了其生命周期回调，且保存了它的当前状态，杀死这些进程并不会对用户造成可见影响，因为当用户返回该activity时，该activity会恢复其所有可见状态。具体参看Activity的保存恢复状态章节。 Empty process（空进程）没有保留任何活动application组件的进程。保留此类进程的唯一理由是缓存目的，来提升下一次组件的启动速度。系统会经常性的杀死这些进程来在进程缓存和内核缓存的系统资源上做一个平衡。 Android系统根据进程的最高能力来决定其排名。例如运行着一个service和一个可见activity的进程会被认为是一个可见进程而非服务进程。另外，一个进程的排名可能会因为其他进程的依赖而提高—一个为其他进程提供服务的进程排名不能低于其服务的进程。举个例子，A进程中的content provider服务于B进程中的client，又或是A进程中的service被B进程的组件绑定着，那么A进程至少应该被视为与B进程同等重要。因为一个运行service的进程重要性比一个运行后台activity的进程高，activity中的长时间运行操作就应该启动一个service来做，而不是简单的创建一个工作线程（worker thread）—特别是如果该操作是可以脱离activity的。比方说，上传图片的activity应该启动一个service来做上传操作，这样即使用户离开了该activity，上传动作还可以在后台执行。使用service保证了该操作至少拥有了“服务进程”的级别，不管activity怎么样了。同样的理由，broadcast receiver中也应该启动service而非起线程来执行长时间的操作。 Threads当application启动后，系统会创建一个线程来执行它，该线程称之为“main”主线程。该线程非常重要，它负责将事件分发给合适的用户UI控件，包括绘制事件。它还是你的application与UI控件（Android UI toolkit，from android.widget, android.view）交互的线程。如此，该主线程也通常被叫做UI线程。系统不会为每个application组件创建单独的线程。所有运行在同一个进程下的application组件都实例化在UI线程。因此，响应系统回调的方法（例如onKeyDown，或者生命周期的回调）都是运行在该进程的UI线程。例如，当用户点击屏幕上的一个按钮时，你的app的UI线程会分发此事件到该控件，该控件会转换为按压状态并发送一个请求到事件队列。UI线程会出列该请求并通知控件重绘。当你的应用需要处理频繁的用户操作时，单线程模型是性能低下的。特别是，当所有的事情都运行在UI线程，执行一个长时间的操作例如网络请求或数据库查询就会阻塞整个UI。当UI线程被阻塞时，事件不会被分发，包括绘制事件。从用户角度，该app就挂死了。更糟的是，如果UI线程阻塞超过一段时间（现在是大约5秒），用户将会看到“application not response”的ANR对话框。另外，Android的UI控件不是线程安全的，所以，不能在worker线程操作UI控件，只能在UI线程操作UI。综上，有两个基本规则针对Android的单线程模型： 不要阻塞UI线程。 不要在非UI线程中操作UI控件。Worker Threads根据上述原则，至关重要的是不要阻塞你的UI线程。如果你的一些操作不是瞬时的，你应该让它们运行在一个单独的线程（“background”或“worker”线程）。例如，如下代码在一个单独的线程下载网络图片并显示在ImageView中： 12345678public void onClick(View v) &#123; new Thread(new Runnable() &#123; public void run() &#123; Bitmap b = loadImageFromNetwork(\"http://example.com/image.png\"); mImageView.setImageBitmap(b); &#125; &#125;).start();&#125; 初看，这代码可以很好的工作，创建了一个新的线程来执行网络下载操作。然而，它违背了第二个原则—不要再非UI线程操作UI控件。这可能产生不确定、意外的行为，且很难去追踪。Android提供了一些从其他线程访问UI线程的方式来解决这个问题： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) 例如，我们可以用View.post(Runnable)来改写上述代码： 12345678910111213public void onClick(View v) &#123; new Thread(new Runnable() &#123; public void run() &#123; final Bitmap bitmap = loadImageFromNetwork(\"http://example.com/image.png\"); mImageView.post(new Runnable() &#123; public void run() &#123; mImageView.setImageBitmap(bitmap); &#125; &#125;); &#125; &#125;).start();&#125; 现在，此实现线程安全了，网络请求在子线程中执行，ImageView在UI线程被维护。然而，随着操作的复杂度增加，此类代码就会变得越来越复杂，越来越难以维护。为了处理与worker线程的复杂交互，你可以考虑在worker线程中使用Handler的消息分发来处理与UI线程的交互。另外有一个更好的方式，那就是继承AsyncTask来执行一些异步操作。 Using AsyncTaskAsyncTask可以让你在UI线程中执行异步操作。它执行耗时操作在子线程，分发结果在UI线程。使用AsyncTask，首先你得继承AsyncTask并实现其doInBackground()方法—运行在一个线程池的后台线程的方法。其次如果要更新UI，你还得实现onPostExecute()方法—分发从doInBackground得到的结果，且运行在UI线程。可以直接在UI线程中调用execute()方法来执行该任务： 1234567891011121314151617public void onClick(View v) &#123; new DownloadImageTask().execute(\"http://example.com/image.png\");&#125;private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; &#123; /** The system calls this to perform work in a worker thread and * delivers it the parameters given to AsyncTask.execute() */ protected Bitmap doInBackground(String... urls) &#123; return loadImageFromNetwork(urls[0]); &#125; /** The system calls this to perform work in the UI thread and delivers * the result from doInBackground() */ protected void onPostExecute(Bitmap result) &#123; mImageView.setImageBitmap(result); &#125;&#125; 如下简单描述了AsyncTask的工作方式： 你可以通过泛型来指定参数、进度值、返回结果的类型。 doInBackground()方法自动在一个worker线程执行。 onPreExecute(), onPostExecute() 和 onProgressUpdate()会在UI线程调用。 doInBackground()的返回值会发送给onPostExecute()。 在doInBackground()的任意时间，你都可以调用publishProgress()来触发onProgressUpdate()。 你可以在任何时候，任意线程取消该任务。 注意：你可能会遇到的一个问题是，当你的activity在意外重启（例如用户转屏）时，会销毁你的worker线程。 Thread-safe methods在某些情况下，你实现的方法可能不止被一个线程所调用，因此，你应该将你的方法写成是线程安全的。主要是针对会被远程调用的方法—例如bound service里的方法。当一个在IBinder实现的方法调用发生在与IBinder运行的同一进程中的时候，这个方法在调用者的线程中被执行。然而，当这个调用发生在其他进程中时，这个方法在与IBinder相同的进程中，系统维护的线程池中的线程上被执行（它不运行在这个进程的UI线程上）。例如，一个service的onBind()方法会被service进程的UI线程调用，方法实现在onBind()返回的对象上（例如，一个实现RPC方法的子类），此方法会被池中线程调用，因为一个service可以有多个客户端，多个线程池中的线程可以在相同时间使用同一个IBinder方法。IBinder方法因此必须被实现成线程安全的。相似的，一个content provider可以收到其他进程发起的数据请求。尽管ContentResolver和ContentProvider隐藏了进程间通信的管理细节，ContentProvider响应那些请求的方法 - query(), insert(), delete(), update(),和getType()方法—被content provider的进程中的一个线程池的线程调用，而不是进程中的UI线程。因为这些方法可能会在任何时候被任何数量的线程调用，他们必须实现为线程安全的。 Interprocess CommunicationAndroid提供了一种进程间通信机制用来做远程过程调用（RPCs）。在这种机制中，被一个activity或是其他application组件调用的方法，执行在远程进程或返回结果给调用者。这需要分解这个方法调用以及它的数据到一个操作系统能理解的层面，把它们从一个本地进程和地址空间转换成一个远程进程和地址空间，然后再远程进程重新组装和执行。返回值反向传送回来。Android提供了这些IPC处理的所有代码，你只需关注定义和实现RPC接口。要执行IPC，你的应用必须使用bindService()绑定到一个service上。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"翻译","slug":"翻译","permalink":"http://blog.lmj.wiki/tags/翻译/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"[译]Content Provider","slug":"docs/Content Provider","date":"2013-06-21T09:14:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2013/06/21/docs/Content Provider/","link":"","permalink":"http://blog.lmj.wiki/2013/06/21/docs/Content Provider/","excerpt":"Content ProviderContent Provider管理结构化数据集的入口。封装数据并提供定义数据安全的机制。Content Provider是进程间数据共享的标准接口。 当你想要使用一个Content Provider来访问数据，你使用Application的Context中的ContentResolver对象作为一个client与provider（实现ContentProvider的类实例）交互。此provider接收client端的数据请求，执行请求并返回结果。 如果你不想与其他Application共享你的数据，你不需要开发你自己的provider。然而，你要为你的Application提供search suggestion（全局搜索）时你需要实现自己的provider。当你想要从你的应用复制/粘贴复杂数据或文件到另一个应用时你需要实现自己的provider。 Android本身就包含一些管理数据（诸如audio，video，image或是contacts）的Content Provider。可以查看android.package包的文档。任何Application都可以访问这些provider。","text":"Content ProviderContent Provider管理结构化数据集的入口。封装数据并提供定义数据安全的机制。Content Provider是进程间数据共享的标准接口。 当你想要使用一个Content Provider来访问数据，你使用Application的Context中的ContentResolver对象作为一个client与provider（实现ContentProvider的类实例）交互。此provider接收client端的数据请求，执行请求并返回结果。 如果你不想与其他Application共享你的数据，你不需要开发你自己的provider。然而，你要为你的Application提供search suggestion（全局搜索）时你需要实现自己的provider。当你想要从你的应用复制/粘贴复杂数据或文件到另一个应用时你需要实现自己的provider。 Android本身就包含一些管理数据（诸如audio，video，image或是contacts）的Content Provider。可以查看android.package包的文档。任何Application都可以访问这些provider。 Content Provider BasicsContent Provider管理数据仓库的入口。Provider是Android Application组件之一，通常被用来为UI提供数据。但是，Content Provider的主要目的是被其他Application使用（通过一个provider client）。Provider和Provider client一起提供一个一致的，标准的数据访问接口，且可以处理进程间通信和数据安全访问。 以下议题包括： Content Provider如何运作 用来通过Content Provider获取数据的API 用来在Content Provider中insert，delete，update数据的API 其他一些有利provider运作的API OverviewContent Provider以一个或多个表（类似于关系型数据库中创建的表）的形式为其他Application展示数据。每一行表示一个数据实例，每一列表示一个数据实例的一个单独的部分。 比如，一个Android平台内置的provider—–用户词典，它保存在用户需要的一些不标准的拼写。如下是其中的表： word app_id frequency locale _ID mapreduce|user1|100|en_US|1precompiler|user14|200|fr_FR|2applet|user2|225|fr_CA|3const|user1|255|pt_BR|4int|user5|100|en_UK|5表中，每一行表示一个在标准词典中可能找不到的单词数据实例。每一列表示该单词的一些数据，比如属地。列标题是在provider中存储的列名。在此provider中，_ID作为主钥“primary key”列，provider会自动维护。 一个provider不要求必须有一个primary key，且如果有也不要求一定要使用_ID来作为列名。但是，如果你要将此provider的数据bind到一个ListView，就必须有一列为_ID。具体解释在Displaying query results章节有说明。 Accessing a provider一个Application使用ContentResolver对象来访问一个Content Provider的数据。此对象的方法会调用provider对象（一个ContentProvider子类的实例）的同名方法，ContentResolver提供了基本的“CRUD”（create，retrieve，update，delete）方法操作持久型数据。 在客户端Application进程的ContentResolver和持有provider的Application中的ContentProvider之间会自动处理进程间通信（IPC）。ContentProvider同样扮演数据仓库和数据表形式之间的一个抽象层。 要访问一个Provider，你的Application通常需要在manifest文件中请求指定的权限（permission）。将会在Content Provider Permissions章节详细介绍。 例如：要获取用户词典Provider中的word和local的列表，你可以调用ContentResolver.query()。此query会调用用户词典Provider中定义的ContentProvider.query()。如下： 1234567// Queries the user dictionary and returns resultsmCursor = getContentResolver().query( UserDictionary.Words.CONTENT_URI, // The content URI of the words table mProjection, // The columns to return for each row mSelectionClause // Selection criteria mSelectionArgs, // Selection criteria mSortOrder); // The sort order for the returned rows 下表展示了query(Uri,projection,selection,selectionArgs,sortOrder)方法中参数的对应SQL语句中的意思： query()参数 SELECT语句的关键字及条件 说明 Uri|FROM table_name|对应要查询的表名。projection|col,col……|要查询的列名（字段）。selection|WHERE col=value|查询条件selectionArgs|Selection中的？对应value|查询条件中对应的？sortOrder|ORDER BY col…|排序方式 Content URIsContent URI是一个标识provider中数据的URI。Content URI包含一个provider的标识名（authority）和一个指定table的名字（path）。当你调用一个方法去访问一个provider中的table时，要包含一个指定table的Content URI作为方法参数。 在之前的代码中，常量CONTENT_URI表示用户词典Provider中的“word”表。ContentResolver对象解析出此URI的authority，通过此authority去匹配系统中已知的provider，然后将query方法分发给正确的provider执行。 ContentProvider使用Content URI的path部分去选择访问的table。通常一个provider的每一个对外的table对应的path。 在之前的代码中，“word”表的URI全写如下： 1content://user_dictionary/words User_dictionary是此provider的authority，而words是“word”表对应的path。content://称之为scheme，总是存在的，它表示这是一个Content URI。 一些provider允许你直接在URI后附着一个ID来访问table的某一行数据。比如，要访问“word”表中的ID为4的数据： 1Uri singleUri = ContentUri.withAppendedId(UserDictionary.Words.CONTENT_URI,4); 你会经常使用这种方式（ID指定）来查询某一行数据或是更新，删除。 注意：Uri和Uri.Builder提供了一些方便的方法来从String构建形式良好的Uri对象。ContentUri中包含了方便的方法去在URI后附着一个ID。上述代码就是使用wirhAppendedId()方法来给URI附着ID的。 Retrieving Data from the Provider此段讨论如何从一个provider中检索（retrieve，query）数据。将用户词典Provider作为例子。 说明：为了清晰起见，此章节中代码调用ContentProvider.query()是在“UI Thread”。实际上，你应该使用异常查询方式（使用单独线程）。其中一种方式就是使用CursorLoader类，（在Loader文档中有详细介绍，译者注Loader是3.0提供的，之前的API不提供）。还有，讲解的代码都是片段而非一个完整的Application。 从一个Provider中query数据，基本有以下两步： 请求到此provider的读权限 定义代码去发送一个query给Provider Requesting read access permission 要访问一个provider，你的Application需要此provider的读权限。你不能在运行时请求此权限，而是要在manifest文件中指明你需要的权限，使用元素和provider中定义的明确permission name。当你在你的manifest中指明了此元素，你的Application就可以有效请求此权限。当用户安装你的Application时，会被隐式授予此请求权限。 更多permission相关知识，参看Content Provider Permissions章节。 用户词典Provider在manifest中定义了android.permission.READ_USER_DICTIONARY的权限，所以想要从此Provider中读取数据的Application都必须请求此权限。 Constructing the query下一步就是构造一个query来从provider检索数据。如下代码定义了一些列的查询参数变量： 12345678910111213// A \"projection\" defines the columns that will be returned for each rowString[] mProjection =&#123; UserDictionary.Words._ID, // Contract class constant for the _ID column name UserDictionary.Words.WORD, // Contract class constant for the word column name UserDictionary.Words.LOCALE // Contract class constant for the locale column name&#125;;// Defines a string to contain the selection clauseString mSelectionClause = null;// Initializes an array to contain selection argumentsString[] mSelectionArgs = &#123;\"\"&#125;; 下一段代码展示如何去使用ContentResolver.query()，使用用户词典Provider作为例子。Provider的query类似于SQL的query，包含一系列的返回列，一系列的选择准则，一系列的排序规则。 返回列称之为projection。 检索准则的表达式分为一个查询条件（selection clause）和查询参数（selection argument）。查询条件是一个逻辑和Boolean表达式（列名和值匹配）的组合。可以使用查询参数的值去对应查询条件中“？”。 在下面的代码片段中，如果用户不输入单词，查询语句就会设置为null，这样会查询出provider的所有单词。如果用户输入了一个word，查询语句会设置成“UserDictionary.Words.Word + “ = ?””且“？”被相应替换成用户输入的word值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * This defines a one-element String array to contain the selection argument. */String[] mSelectionArgs = &#123;\"\"&#125;;// Gets a word from the UImSearchString = mSearchWord.getText().toString();// Remember to insert code here to check for invalid or malicious input.// If the word is the empty string, gets everythingif (TextUtils.isEmpty(mSearchString)) &#123; // Setting the selection clause to null will return all words mSelectionClause = null; mSelectionArgs[0] = \"\";&#125; else &#123; // Constructs a selection clause that matches the word that the user entered. mSelectionClause = \" = ?\"; // Moves the user's input string to the selection arguments. mSelectionArgs[0] = mSearchString;&#125;// Does a query against the table and returns a Cursor objectmCursor = getContentResolver().query( UserDictionary.Words.CONTENT_URI, // The content URI of the words table mProjection, // The columns to return for each row mSelectionClause // Either null, or the word the user entered mSelectionArgs, // Either empty, or the string the user entered mSortOrder); // The sort order for the returned rows// Some providers return null if an error occurs, others throw an exceptionif (null == mCursor) &#123; /* * Insert code here to handle the error. Be sure not to use the cursor! You may want to * call android.util.Log.e() to log this error. * */// If the Cursor is empty, the provider found no matches&#125; else if (mCursor.getCount() &lt; 1) &#123; /* * Insert code here to notify the user that the search was unsuccessful. This isn't necessarily * an error. You may want to offer the user the option to insert a new row, or re-type the * search term. */&#125; else &#123; // Insert code here to do something with the results&#125; 与此query相类似的SQL语句如下： 1SELECT _ID, word, frequency, locale FROM words WHERE word = &lt;userinput&gt; ORDER BY word ASC; Protecting against malicious input如果Provider管理的数据是在一个SQL数据库中，在原始SQL语句中包含不被信任的数据会导致SQL注入。 看如下的selection clause： 12// Constructs a selection clause by concatenating the user's input to the column nameString mSelectionClause = \"var = \" + mUserInput; 如果你这样做，用户就可以在你的SQL语句中串联恶意SQL。例如，用户可能输入“nothing; DROP TABLE ;”来代替mUserInput，这样会导致selection clause变成“var = nothing; DROP TABLE ;”。因为此selection clause会被当做一个SQL语句，这可能导致provider清除掉SQLite数据库下的所有table（除非provider设置了捕获SQL注入尝试）。 为了避免这种问题，可以在selection clause中使用“？”作为可代替的参数，而在一个单独的数组中赋值（selection arguments）。当你这样做时，用户的输入会直接绑定到query而不是被解释成SQL语句的一部分。因为它不是被当做一个SQL来对待，所以用户不能注入恶意SQL。如下： 12// Constructs a selection clause with a replaceable parameterString mSelectionClause = \"var = ?\"; 如此初始化一个selection argument的数组： 12// Defines an array to contain the selection argumentsString[] selectionArgs = &#123;\"\"&#125;; 如此将用户输入放入数组中： 12// Sets the selection argument to the user's inputselectionArgs[0] = mUserInput; Selection clause使用“？”而对应selection argument数组是一个Select的首选方式，即使provider不是基于SQLite数据库。 Displaying query resultsContentResolver.query()方法通常会返回一个Cursor：包含query的projection指定的列和与query的selection匹配的行。Cursor提供随机读访问其包含的行和列。使用Cursor的方法，你可以遍历结果集中的行，确定每一列的数据类型，获取每一列的数据以及获取结果集的其他属性。一些Cursor实现会在provider的数据变化时自动更新对象，或是在Cursor变化时触发一个Observer的方法，或是二者兼是。 注意：Provider可能限制访问基于对象性质查询出的列（不理解，需看源码分析）。例如Contacts Provider限制访问一些列给同步适配器，所以它不会返回给一个Activity或Service。 如果没有行匹配此查询准则，provider会返回一个空的Cursor，cursor的count为0。 如果出现内部错误，查询的结果取决于特定的provider，可能是null也可能抛出一个Exception。 因为Cursor是一个行的列表，所以显示Cursor中内容的最好方式是通过一个SimpleCursorAdapter与一个ListView关联。 下列代码片段是上面代码的延续。创建一个包含Cursor的SimpleCursorAdapter的对象，且设置此对象为ListView的适配器。 123456789101112131415161718192021// Defines a list of columns to retrieve from the Cursor and load into an output rowString[] mWordListColumns =&#123; UserDictionary.Words.WORD, // Contract class constant containing the word column name UserDictionary.Words.LOCALE // Contract class constant containing the locale column name&#125;;// Defines a list of View IDs that will receive the Cursor columns for each rowint[] mWordListItems = &#123; R.id.dictWord, R.id.locale&#125;;// Creates a new SimpleCursorAdaptermCursorAdapter = new SimpleCursorAdapter( getApplicationContext(), // The application's Context object R.layout.wordlistrow, // A layout in XML for one row in the ListView mCursor, // The result from the query mWordListColumns, // A string array of column names in the cursor mWordListItems, // An integer array of view IDs in the row layout 0); // Flags (usually none are needed)// Sets the adapter for the ListViewmWordList.setAdapter(mCursorAdapter); 注意：要使一个Cursor支持ListView，此Cursor必须包含一个名为_ID的列。为此，前面查询“word”表时也检索了_ID列，虽然ListView并不显示此列。这个限制也解释了为什么大多数的provider的每个表都有_ID列字段。 Getting data from query results除了简单的显示查询的结果，你还可以以其他方式使用它。比如，你可以在用户词典中检索拼写，然后在其他provider中查找。你可以遍历Cursor中的行： 1234567891011121314151617181920212223242526272829// Determine the column index of the column named \"word\"int index = mCursor.getColumnIndex(UserDictionary.Words.WORD);/* * Only executes if the cursor is valid. The User Dictionary Provider returns null if * an internal error occurs. Other providers may throw an Exception instead of returning null. */if (mCursor != null) &#123; /* * Moves to the next row in the cursor. Before the first movement in the cursor, the * \"row pointer\" is -1, and if you try to retrieve data at that position you will get an * exception. */ while (mCursor.moveToNext()) &#123; // Gets the value from the column. newWord = mCursor.getString(index); // Insert code here to process the retrieved word. ... // end of while loop &#125;&#125; else &#123; // Insert code here to report an error if the cursor is null or the provider threw an exception.&#125; Cursor实现包含了一系列“get”方法去从该对象中检索出不同类型的数据。比如上述代码片段中使用的getString()方法。还有getType()方法来获取指示每列数据类型的值。 Content Provider Permissions一个provider的Application可以指定一个permission，其他Application要访问此provider的数据就必须包含此permission。这些permission确保用户知道一个Application将会尝试访问哪些数据。基于Provider的要求，其他Application需要请求相应的permission去访问此Provider。终端用户会在他们安装Application看到应用请求的permission。 一个provider的Application没有指定任何permission，那么其他Application不能访问此provider的数据。然而，此provider的Application的其他组件总是拥有全部的读写权限，无论是否指定permission。 如前所述，用户词典Provider需要android.permission.READ_USER_DICTIONARY权限从它检索数据，需要另外一个android.permission.WRITE_USER_DICTIONARY权限来插入，更新和删除数据。 为了获得访问一个Provider的权限，一个Application需要在其manifest文件中指定元素。当Android Package Manager安装此Application时，用户必须同意此Application请求的所有权限。如果用户同意所有请求的权限，Package Manager继续安装，否则会取消安装。 如下是访问用户词典Provider定义的permission： 1&lt;uses-permission android:name=\"android.permission.READ_USER_DICTIONARY\"&gt; 关于Provider权限的更多细节参看Security and Permissions文档。 Inserting, Updating, and Deleting Data和检索数据一样，你也可以通过client端与provider的交互去修改数据。你可以调用ContentResolver中的带参方法执行ContentProvider中的相应方法。Provider和client端会自动处理IPC以及安全性。 Inserting data插入数据到provider，可以调用ContentResolver.insert()方法。此方法会向provider插入一行数据并返回此行数据的URI。下面的代码段就是展示如何向用户词典provider插入一个word： 123456789101112131415161718192021// Defines a new Uri object that receives the result of the insertionUri mNewUri;...// Defines an object to contain the new values to insertContentValues mNewValues = new ContentValues();/* * Sets the values of each column and inserts the word. The arguments to the \"put\" * method are \"column name\" and \"value\" */mNewValues.put(UserDictionary.Words.APP_ID, \"example.user\");mNewValues.put(UserDictionary.Words.LOCALE, \"en_US\");mNewValues.put(UserDictionary.Words.WORD, \"insert\");mNewValues.put(UserDictionary.Words.FREQUENCY, \"100\");mNewUri = getContentResolver().insert( UserDictionary.Word.CONTENT_URI, // the user dictionary content URI mNewValues // the values to insert); 一行数据由一个单独的ContentValues包含，此ContentValues类似于一个单行的Cursor。此对象中的列不需要是相同的数据类型，如果你不想指定一个值，你可以使用ContentValues.putNull()方法设置一个null值。 上述代码中没有添加_ID值，这是因为此列是自动维护的。Provider会给每一个新加的行赋予一个唯一的_ID值。Provider通常将此值作为table的主钥（primary key）。 Insert方法会返回一个表示新加行的URI，格式如下：1content://user_dictionary/words/&lt;id_value&gt; 就是此新加行的_ID。大多数的provider都能自动检测此格式的URI并且在指定行上执行请求。 可以使用ContentUri.parseId()来从返回的URI中获取_ID。 Updating data要更新一行数据，你要使用一个ContentValues作为更新值，和一个查询条件。然后调用ContentResolver.update()方法。你仅仅需要将你想要更新的列的值加入ContentValues中。如果你想清除某列的内容，可以给它赋予一个null值。 如下代码展示了修改所有local为en的行的local为null。Update的返回值为更新行的个数： 1234567891011121314151617181920212223// Defines an object to contain the updated valuesContentValues mUpdateValues = new ContentValues();// Defines selection criteria for the rows you want to updateString mSelectionClause = UserDictionary.Words.LOCALE + \"LIKE ?\";String[] mSelectionArgs = &#123;\"en_%\"&#125;;// Defines a variable to contain the number of updated rowsint mRowsUpdated = 0;.../* * Sets the updated value and updates the selected words. */mUpdateValues.putNull(UserDictionary.Words.LOCALE);mRowsUpdated = getContentResolver().update( UserDictionary.Words.CONTENT_URI, // the user dictionary content URI mUpdateValues // the columns to update mSelectionClause // the column to select on mSelectionArgs // the value to compare to); 调用ContentResolver.update()方法你也应该过滤用户输入，参考Protecting against malicious input章节。 Deleting data删除行类似于查询，你要指定一个你想要删除行的查询条件，delete方法会返回你删除了的行的个数。如下代码展示了删除appid为user的行： 123456789101112131415// Defines selection criteria for the rows you want to deleteString mSelectionClause = UserDictionary.Words.APP_ID + \" LIKE ?\";String[] mSelectionArgs = &#123;\"user\"&#125;;// Defines a variable to contain the number of rows deletedint mRowsDeleted = 0;...// Deletes the words that match the selection criteriamRowsDeleted = getContentResolver().delete( UserDictionary.Words.CONTENT_URI, // the user dictionary content URI mSelectionClause // the column to select on mSelectionArgs // the value to compare to); 调用ContentResolver.delete()方法你也应该过滤用户输入，参考Protecting against malicious input章节。 Provider Data TypesContentProvider提供诸多不同的数据类型。例如text，integer，long，float，double。还有一个经常会使用到数据类型是BLOB（Binary Large Object，一个64KB的字节数组）。你可以通过Cursor的“get”方法查看有效的数据类型。 Provider中的每列的数据类型一般会在其文档中说明。你也可以使用Cursor.getType()来确定数据类型。 Provider还维护着他们定义的Content URI的MIME数据类型信息。你可以使用MIME类型信息来确定你的Application是否可以处理Provider提供的数据，或是基于MIME类型来选择一个类型去处理。通常在平provider包含复杂数据或是文件。可以调用ContentResolver.getType()去获取相应URI的MIME类型。 如下MIME Type Reference章节会描述标准MIME和自定义MIME类型的语法。 Alternative Forms of Provider Access在Application开发时有三种重要的可选provider访问格式： Batch access：你可以在ContentProviderOperation类中绑定一组访问调用，然后通过调用ContentResolver.applyBatch()来应用此Batch。 Asynchronous queries：你应该在一个单独线程中做query操作。其中一种方式就是使用CursorLoader对象，在Loader文档中有此实例。（注：此是3.0引入，之前的API可以使用AsyncQueryHandler处理）。 Data access via intents：虽然你不能直接发送一个Intent给provider，但是你可以发送一个Intent给此provider的Application，通常是最好的修改provider数据的方式。 Batch access使用Batch方式访问provider对于insert多行数据，或者是在同样一个方法调用中往多个table中insert行，又或者类似事务（transaction）那样跨进程执行一系列操作是非常有用的。 要以“Batch mode”访问一个Provider，你要创建一组ContentProviderOperation对象，然后调用ContentResolver.applyBatch()发送给ContentProvider。你给此方法传一个provider的authority作为参数而不是一个具体的Content URI，这样你那一系列ContentProviderOperation就可以针对不同的table工作。ContentResolver.applyBatch会放回一个结果集的数组。 Data access via intentsIntent提供对一个Content Provider的直接访问。允许用户访问一个provider中数据即使你的Application没有访问权限，无论是从一个有访问权限的Application获得一个结果Intent，或是激活一个有访问权限的Application且让用户在那里执行操作。 Getting access with temporary permissions你可以访问你一个provider的数据，即使你没有合适的访问权限，通过发送一个Intent给拥有权限的Application然后接受一个带有“URI”权限的结果Intent。这些指定特定URI的权限持续到接收的Activity finished。拥有永恒权限的Application通过在其结果Intent中设置如下Flag来授予临时权限。 读权限： FLAG_GRANT_READ_URI_PERMISSION 写权限：FLAG_GRANT_WRITE_URI_PERMISSION 注意：这些Flag不会授予一般的读写权限给包含此URI的authority。此访问仅限于此URI本身。 Provider在manifest文件中为content URI定义URI权限，在元素中使用android:grantUriPermission属性，与在元素中添加子元素。此URI权限机制会在Security and Permissions文档的“URI Permissions”章节详细介绍。 例如，你可以在Contacts Provider检索一个Contact的数据，即使你没有READ_CONTACTS的权限。你可能想要在一个Application中发送一封电子贺卡（当一个联系人生日时）。不是请求READ_CONTACTS权限（这会给你访问所有联系人及其信息的权限），你更应该让用户控制你的Application要用到的联系人。你可以使用如下步骤： 你的Application调用startActivityForResult()发送一个包含Action为“ACTION_PICK”和MIME type为“CONTENT_ITEM_TYPE”的Intent。 因为此Intent与联系人应用的选择Activity的Intent filter匹配，此Activity会切换到前台。 在此选择Activity中，用户可以选择一个联系人。一旦选定，此Activity会调用setResult(resultCode, Intent)来初始化一个Intent会传回给你的Application。此Intent包含用户选择的联系人的Content URI，还有额外的flag（FLAG_GRANT_READ_URI_PERMISSION）。此flag会授予你的Application读取此返回的Content URI指定的联系人的信息的权限。之后此选择Activity会调用finish()切换回你的Application。 你的Activity回到前台，系统会调用你的Activity的onActivityResult方法，此方法接收联系人应用的选择Activity创建的结果Intent。 使用此结果Intent中的Content URI，你可以从Contacts Provider中读取此联系人的数据，虽然你没有在你的manifest文件中请求访问此Provider的永恒权限。你可以获取此联系人的生日信息以及email地址来发送一个电子贺卡。 Using another application在你的Application没有访问权限时，一个简单的允许用户修改数据的方式是激活一个拥有权限的Application，然后让用户在那儿工作。 例如：日历应用接收ACTION_INSERT intent，它允许你激活此应用的insert界面。你可以在此Intent中添加额外数据，这用应用就会使用预填充的界面。因为周期性事件有很复杂的逻辑语法，更好的往Calendar Provider中插入事件的方式是使用ACTION_INSERT激活Calendar应用然后让用户在此应用中insert。 Contract ClassesContract类定义了一些协助Application工作的常量，包括content URI、列名、intent Action和provider的其他的特性等。Contract类不是provider自动包含的，provider的开发者需要自己定义他们并让他们对其他开发者可用。Android平台中很多provider拥有相应的Contract类。 具体实例，参看源码。Contacts Provider的ContactsContract类。 MIME Type ReferenceContent Provider可以返回标准的MIME媒体类型，或自定义的MIME类型字符串，或是二者兼并。 MIME类型有如下格式： 1type/subtype 例如：知名的MIME类型text/html，包含text类型和html子类型。如果一个provider返回一个此类型给URI，意味着使用此URI的query会返回一个包含HTML标签的text。 自定义的MIME类型字符串也称之为“vendor-specific”MIME类型，有更复杂的type和subtype值。此type值通常为 1vnd.android.cursor.dir 来表示多行数据，或者 1vnd.android.cursor.item 来表示单行。 subtype是provider-specific。Android内置的provider通常有一个简单的subtype。例如，当联系人应用创建一行电话号码的数据时，它会设置MIME类型如下： 1vnd.android.cursor.item/phone_v2 注意，subtype只是简单的phone_v2。 Provider开发者可以基于provider的authority和table名创建自己的subtype格式。例如：假设一个provider包含列车时刻表，provider的authority是com.example.train，包含Line1、Line2、Line3的table。对于以下content URI： 1content://com.example.trains/Line1 请求table Line1，provider返回如下MIME类型： 1vnd.android.cursor.dir/vnd.example.line1 对于这个Content URI： 1content://com.example.trains/Line2/5 请求table Line2的第5行，provider返回如下MIME类型： 1vnd.android.cursor.item/vnd.example.line2 大多数provider在其Contract类中定义了他们用到的MIME类型。 Creating a Content ProviderContent Provider管理数据仓储的入口。你通过一个或多个类来在你Application实现一个provider，并在manifest文件中添加元素。你的其中一个类实现ContentProvider，它会作为你的provider与其他Application的交互接口。虽然Content Provider意味着你在共享你的数据给其他Application，你自己Application内的Activity也可以通过你的provider允许用户查询和修改数据。 如下章节会描述创建一个provider的步骤以及可用的一些API。 Before You Start Building在你开始创建一个provider之前，确认以下几点： 确定你是否需要一个Content Provider。在以下的情况下你需要创建一个provider：a) 你想要提供复杂数据或文件给其他Applicationb) 你想要允许用户从你的app复制复杂数据给其他appc) 你想要通过Search框架提供一个自定义本地搜索你不需要为一个SQLite DB提供一个provider，如果你仅仅是在你的Application内部使用。 如果你还没有做以上工作，请阅读Content Provider Basics章节来了解Provider的更多知识。 下面，如下步骤帮助你创建一个provider： 设计你的数据的原存储。Content Provider以下面两种方式提供数据：a) File Data数据通常是file的形式，例如photo，audio，video。在你的App的私有空间存储这些数据。当其他App请求一个文件时，你的provider会提供一个此文件的操作句柄（handle）。 b) “Structured Data”数据通常是database，array或类似结构的形式。数据以类似table的行列形式表格存储。一行代表一个数据实体，比如一个人或一个库存条目等。每列代表给数据实体的一些数据，例如人的名字或库存条目的价格等。通常以此方式存储数据的是使用SQLite Database，但你也可以使用其他的持久存储类型。更过Android系统的存储类型信息，参见Designing Data Storage章节。 定义一个ContentProvider的具体实现类并实现其需要的方法。此类是你的数据与Android系统的其他部分的交互接口。更多信息，参见Implementing the ContentProvider Class章节。 定义provider的authority字符串，content URI，列名等。如果你想provider的App处理Intent，还要定义Intent Action，extra data，Flag等。还要定义permission作为你的App请求访问你的数据的权限。你应该考虑在一个单独的Contract类中定义以上所有的值，然后，你可以暴露此类给其他开发者。更多content URI的信息，参考Designing Content URIs章节。更多Intent信息，参考Intent and Data Access章节。 添加其他可选项，例如实例数据，或是实现AbstractThreadedSyncAdapter使你可以在provider和基于云的数据（云端）进行同步。 Designing Data StorageContent Provider是一个结构化数据的接口。在你创建这个接口之前，你必须决定如何存储你的数据。你可以以你喜欢的任何方式保存数据，然后设计一个读写此数据的接口。 Android中如下几种数据存储技术是有效的： Android系统包含了SQLite数据库的API，Android内置的provider使用SQLite来保存表型（table-oriented）数据。SQLiteOpenHelper类协助你创建database，SQLiteDatabase类是访问数据的基类。 你不需要使用一个database去实现你的数据仓储。Provider的外观是一系列表格，类似于关系型数据库，但是这不是Provider内部实现的要求。 对于文件存储，Android包含各种面向文件（file-oriented）的API。更多file存储信息，参见Data Storage章节。如果你为媒体相关的数据（例如music，video）设计一个Provider，你可能使用table和file相结合的方式。 对于基于网络存储的数据，使用java.net和android.net中的类。你也可以同步网络数据到你的本地数据（比如数据库）中，然后以table或者file的形式提供出来。同步数据可以参考Sample Sync Adapter的Demo。 Data design considerations如下有些建议，当你设计你的provider的数据结构时： Table数据应该总是有一个主钥（primary key）列，provider将其作为每行数据的唯一数值来维护。你可以使用此行的此值与其他table关联（作为一个外键（foreign key））。虽然你可以使用为此列选择任何名字，但是使用BaseColumns._ID是最好的选择。 如果你想要提供一个Bitmap的图片或是其他基于文件的大数据，直接保存在文件中提供出来而不是使用table。如果你这样做了，你需要告诉你的Provider的用户，他们需要使用ContentResolver的file方法去访问这些数据。 使用BLOB类型去保存不同大小不同结构的数据。例如，你可以使用BLOB列去保存一个协议缓存或是JSON结构。 你也可以使用BLOB去实现一个schema-independent的表，在这种类型的table中，你定义一个主键列，一个MIME类型的列，还一个或多个BLOB的普通列。这意味着BLOB列的数据通过MIME列来指示。它允许你在一张table的不同行存储不同的数据类型。参见Contacts Provider中的“data”表。 Designing Content URIsContent URI是一个标识provider中数据的URI。Content URI包含整个provider的标识符（authority）和一个指定table或file的名称（path）。一个可选的id部分指定table的某一行。所有ContentProvider的数据访问方法都有一个Content URI的参数；它允许你确定要访问的table，row或是file。 Designing an authority一个Provider通常拥有一个单一的authority，作为Android内部名称。为了避免去其他provider冲突，你应该使用你的所有权域名反序（com.android.xxx）作为你的provider的authority的基础。因为此建议同样针对Android的包名，你可以定义你的provider的authority作为包名的扩展。例如，如果你的Android应用包名为com.example.xxx，你应该定义你的provider的authority为com.example.xxx.provider。 Designing a path structure开发者通常在authority后附着一个path来创建一个Content URI去指定一个确定的table。例如，如果你有两个table：table1和table2，你可以使用com.example.xxx.provider/table1和com.example.xxx.provider/table2分别表示。Path不仅限于一个分部（segment），且每级path都不是必须指定一个table。 Handling content URI IDs为了方便，provider提供了直接访问table中单独行的方式，通过一个附着ID的content URI。Provider会将此ID与table中的_ID列进行匹配，并在相应的匹配行中执行操作。 此设计有利于app访问provider。App对应provider执行一个query，然后使用CursorAdapter在一个ListView中显示结果。CursorAdapter中的Cursor要求必须定义有_ID。 用户可能选择UI上显示的一行数据去查看或是修改。App会从ListView的Cursor中获取相应的行，取得此行的_ID，加入到content URI后，然后发送访问请求给provider。Provider可以对用户指定的行进行query或modify操作。 Content URI patterns为了协助更好处理传入的Content URI执行的操作，provider API提供了一个方便的类：UriMatcher，它映射content URI为integer值。你可以使用switch语句来选择执行请求的操作。 Content URI可以使用以下通配符： ：任意长度的任意有效字符 ：任意长度的数字字符 假设有一个authority为com.example.app.provider的Provider，以下分别表示： content://com.example.app.provider/table1：叫table1的表 content://com.example.app.provider/table2/dataset1：叫dataset1的表 content://com.example.app.provider/table2/dataset2：叫dataset2的表 content://com.example.app.provider/table3：叫table3的表。 Provider同样可以识别带行ID的URI，例如content://com.example.app.provider/table3/1表示table3中_ID为1的行。 以下content URI也是可以的： 1234567content://com.example.app.provider/*``` 匹配provider中的任意URI```javacontent://com.example.app.provider/table2/* 匹配dataset1和dataset2表，但是不匹配table1和table3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970content://com.example.app.provider/table3/#``` 匹配table3中的一行底下的代码片段展示了UriMatcher的方法是如何工作的。此段代码分别不同处理代表整个table的URI和代表单独行的URI。addURI()方法映射一个authority和path为一个integer值。match()方法为一个URI放回一个integer值。Switch语句判断此integer值来分别处理：```javapublic class ExampleProvider extends ContentProvider &#123;... // Creates a UriMatcher object. private static final UriMatcher sUriMatcher;... /* * The calls to addURI() go here, for all of the content URI patterns that the provider * should recognize. For this snippet, only the calls for table 3 are shown. */... /* * Sets the integer value for multiple rows in table 3 to 1. Notice that no wildcard is used * in the path */ sUriMatcher.addURI(\"com.example.app.provider\", \"table3\", 1); /* * Sets the code for a single row to 2. In this case, the \"#\" wildcard is * used. \"content://com.example.app.provider/table3/3\" matches, but * \"content://com.example.app.provider/table3 doesn't. */ sUriMatcher.addURI(\"com.example.app.provider\", \"table3/#\", 2);... // Implements ContentProvider.query() public Cursor query( Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123;... /* * Choose the table to query and a sort order based on the code returned for the incoming * URI. Here, too, only the statements for table 3 are shown. */ switch (sUriMatcher.match(uri)) &#123; // If the incoming URI was for all of table3 case 1: if (TextUtils.isEmpty(sortOrder)) sortOrder = \"_ID ASC\"; break; // If the incoming URI was for a single row case 2: /* * Because this URI was for a single row, the _ID value part is * present. Get the last path segment from the URI; this is the _ID value. * Then, append the value to the WHERE clause for the query */ selection = selection + \"_ID = \" uri.getLastPathSegment(); break; default: ... // If the URI is not recognized, you should do some error handling here. &#125; // call the code to actually do the query &#125; 另外一个类ContentUris提供了一些方便的方法来操作Content URI的id部分。Uri和Uri.Builder类提供了一些方法来解析Uri对象和新建一个Uri对象。 Implementing the ContentProvider ClassContentProvider通过处理其他App的请求来管理数据入口。所有形式的访问最终会调到ContentProvider，然后通过ContentProvider的具体方法来访问。 Required methodsContentProvider抽象类定义6个抽象方法，你必须在你的具体实现类中实现它们。所有这些方法除了onCreate都被client app用来调用去访问你的provider。 query从你的Provider中检索数据。使用参数来确定要查询的table，返回的行和列，以及结果集的排序方式。返回的数据是一个Cursor。 insert往你的Provider中插入一行数据。使用参数来确定具体的table和对应列值。返回一个URI代表新插入的那行数据。 update更新你的Provider中的已有行。使用参数来确定更新的table，要更新的行，以及更新的对应列值。返回一个int表示更新了多少行。 delete从你的Provider中删除行。使用参数确定对应的table，以及需要删除的行。返回一个int表示删除了多少行。 getType返回一个Content URI的对应MIME类型。此方法在Implementing Content Provider MIME Types有详细说明。 onCreate初始化你的Provider。Android系统会调用此方法后立即创建你的Provider。注意：你的Provider不会被创建直到一个ContentResolver对应视图去访问你的Provider。此处很重要，通俗的说，数据库是在第一次请求时创建的，而不是开启应用时就创建了。 实现上述方法时要注意以下几点： 所有以上方法除了onCreate可以被多个线程同时调用，所以它们必须是线程安全的。更多多线程的细节，参见Processes and Threads文档。 避免在onCreate中执行长时间的操作。延迟初始化任务知道真正需要。参看Implementing the onCreate method章节。 虽然你必须实现这些方法，你的代码可以不做任何处理除了返回预期的数据类型。例如，你可能想要阻止其他App往table中insert数据，你可以实现insert方法只是返回0而不做其他实现。 Implementing the query() methodContentResolver.query()方法必须返回一个Cursor对象，如果失败则抛出一个Exception。如果你使用SQLite数据库作为数据存储。你可以通过SQLiteDatabase类的query方法简单的返回一个Cursor。如果这个query没有匹配任何行，你应该返回一个Cursor实例（其getCount方法返回0）。仅仅在query过程中发生内部错误时你应该放回null。 如果你不是使用SQLite数据库作为数据存储，使用Cursor的一个具体子类。例如，MatrixCursor实现Cursor，每行是一个对象数组。使用此类，addRow()方法添加一个新行。 Android系统必须可以跨进程与一个Exception关联（也就是说跨进程捕获Exception）。Android在处理query错误时，通常抛出以下类型的Exception： IllegalArgumentException（通常在无效URI时抛出此异常） NullPointerException Implementing the insert() methodInsert方法往对应的table中插入一行数据，使用ContentValues值对参数。如果某一列在ContentValues参数中没有定义，你可能需要提供一个默认值，不管是在provider代码还是数据库架构中。 此方法应该返回新增行的URI。可以使用withAppendedId()方法在此table对应的URI后附着主键_ID。 Implementing the delete() method实现此delete方法，并不是必须要将数据从数据存储中实际删除。如果你在你的Provider中使用了同步适配器，你应该考虑标记要删除的行一个“delete flag”而不是彻底的删除此行。同步适配器可以监测这些将要被删除的行数据，在删除provider中数据之前将server中的对应数据删除。 Implementing the update() methodUpdate方法拥有一个和insert方法相同的ContentValues参数，和delete，query相同的selection，selectionArgs参数。这可以允许你在这些方法之间重用代码。 Implementing the onCreate() methodAndroid在启动provider时会调用其onCreate方法。你应该在此方法中仅仅执行快速初始化任务，推迟数据库创建和数据加载到provider实际接收到数据请求时。如果你在onCreate中执行长时间操作，将会使provider的启动变慢。依次，会使provider与其他App之间的响应变慢。 例如：如果你使用SQLite数据库，你可以在ContentProvider.onCreate方法中创建一个SQLiteOpenHelper对象，然后在你第一次打开数据库时创建table。为了达成这样，你第一次调用getWritableDatabase方法时，会自动调用SQLiteOpenHelper.onCreate方法。 如下的代码片段展示了ContentProvider.onCreate和SQLiteOpenHelper.onCreate之间的交互。第一段是ContentProvider.onCreate的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class ExampleProvider extends ContentProvider /* * Defines a handle to the database helper object. The MainDatabaseHelper class is defined * in a following snippet. */ private MainDatabaseHelper mOpenHelper; // Defines the database name private static final String DBNAME = \"mydb\"; // Holds the database object private SQLiteDatabase db; public boolean onCreate() &#123; /* * Creates a new helper object. This method always returns quickly. * Notice that the database itself isn't created or opened * until SQLiteOpenHelper.getWritableDatabase is called */ mOpenHelper = new SQLiteOpenHelper( getContext(), // the application context DBNAME, // the name of the database) null, // uses the default SQLite cursor 1 // the version number ); return true; &#125; ... // Implements the provider's insert method public Cursor insert(Uri uri, ContentValues values) &#123; // Insert code here to determine which table to open, handle error-checking, and so forth ... /* * Gets a writeable database. This will trigger its creation if it doesn't already exist. * */ db = mOpenHelper.getWritableDatabase(); &#125;&#125;下面是SQLiteOpenHelper.onCreate的实现：...// A string that defines the SQL statement for creating a tableprivate static final String SQL_CREATE_MAIN = \"CREATE TABLE \" + \"main \" + // Table's name \"(\" + // The columns in the table \" _ID INTEGER PRIMARY KEY, \" + \" WORD TEXT\" \" FREQUENCY INTEGER \" + \" LOCALE TEXT )\";.../** * Helper class that actually creates and manages the provider's underlying data repository. */protected static final class MainDatabaseHelper extends SQLiteOpenHelper &#123; /* * Instantiates an open helper for the provider's SQLite data repository * Do not do database creation and upgrade here. */ MainDatabaseHelper(Context context) &#123; super(context, DBNAME, null, 1); &#125; /* * Creates the data repository. This is called when the provider attempts to open the * repository and SQLite reports that it doesn't exist. */ public void onCreate(SQLiteDatabase db) &#123; // Creates the main table db.execSQL(SQL_CREATE_MAIN); &#125;&#125; Implementing ContentProvider MIME TypesContentProvider类提供了两个方法来返回一个MIME类型。 getType实现一个Provider必须实现的方法。 getStreamType如果你的provider提供file，你可能要实现此方法。 MIME types for tablesgetType放回一个MIME格式的String，描述content URI参数对应返回的数据的类型。此URI参数可能是一个模式而非一个具体的URI。在这种情况下，你要返回与此模式匹配的Content URI的数据类型。 常见的数据类型例如text，html或jpeg。getType方法应该返回数据的标准MIME类型. 由于Content URI表示table数据中一行或多行。getType应该返回Android供应商指定的MIME格式： 类型部分：vnd 子类型部分： 单行数据：android.cursor.item/ 多行数据：android.cursor.dir/ Provider指定部分：vnd.. 你提供name和type。Name的值应该是全局唯一的，type应该对应URI模式唯一。一个好的定义name方式是使用你的公司名或你的App的包名，type的话，选择代表URI关联的table的String是一个好选择。 例如，一个Provider的authority为com.example.app.provider，且有一个暴露的table名为table1。那么table1中多行数据的MIME为： 1vnd.android.cursor.dir/vnd.com.example.provider.table1 table1中的单行数据： 1vnd.android.cursor.item/vnd.com.example.provider.table1","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"翻译","slug":"翻译","permalink":"http://blog.lmj.wiki/tags/翻译/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"[译]Tasks and Back Stack","slug":"docs/Tasks and Back Stack","date":"2013-05-28T02:12:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2013/05/28/docs/Tasks and Back Stack/","link":"","permalink":"http://blog.lmj.wiki/2013/05/28/docs/Tasks and Back Stack/","excerpt":"Tasks and Back Stack一个Application通常包括多个Activity。每一个Activity都应该被设计为执行用户特定行为和启动其他Activity。比如，一个Email Application可能拥有一个列举Email的Activity，当用户选择一封Email时，启动一个新的Activity来阅读这封Email。","text":"Tasks and Back Stack一个Application通常包括多个Activity。每一个Activity都应该被设计为执行用户特定行为和启动其他Activity。比如，一个Email Application可能拥有一个列举Email的Activity，当用户选择一封Email时，启动一个新的Activity来阅读这封Email。 一个Activity甚至可以启动device中其他Application存在的Activity。比如，如果你的Application想要发送Email，你可以定义一个执行Send Action并且包含一些数据（Email地址和Message）的Intent。其他应用中可以处理此类Intent的Activity会打开。在这个例子里，Intent是send Email，所以Email Application的编辑Activity会启动（当有多个Activity可以处理该Intent时，会给出选择供用户选择）。当Email发送完成后会返回resume到你的Activity，看起来Email Activity像是你的Application的一部分，即使这些Activity是在不同的Application。Android通过保持这个两个Activity在同一个Task中来提供无缝的用户体验。 Task是用户执行某个特定工作时交互的Activity的集合。这些Activity按照他们打开的顺序排列在一个Stack中（Back Stack）。 Device的主界面（Home Screen）是大多数Task的起点。当用户点击Application的启动图标（也可能是快捷方式）时，此Application的Task会切换到前台（foreground）。如果此Application还没有Task存在（此Application最近没有被启动过），会有一个新的Task生成，这个Application的main Activity会被作为这个Stack的根Activity打开。 当当前Activity启动另外一个时，新Activity被push到栈顶并且获得焦点。前一个Activity保留在Stack中，但是Stopped。当一个Activity Stopped，系统会保留它的UI的当前状态。当用户点击Back按钮，当前Activity会从Stack中弹出（并且Destroy），前一个Activity resume（UI状态会恢复）。Stack中的Activity永远不会被重新排列，只会在Stack中push和pop。被当前Activity启动时push到栈顶，用户点击Back离开Activity时pop出栈。 此Back Stack做为一种“LIFO”（后进先出）的对象结构。下图展示了这种进出关系： 如果用户不断的点击Back按钮，Activity会Pop出栈而现实它之前的一个，知道用户回到Home Screen（或者回到这个Task开始时正在运行的Activity）。当所有Activity都从这个Stack移除时，这个Task就不存在了。当用户启动一个新的Task或回到Home Screen时，Task可以作为一个凝聚的单位整体切换到后台background。在后台，Task中的所有Activity都Stopped了，但是这个Task的Stack不变——-只是另一个Task执行时此Task失去了focus，如图所示： 图解：Task B由于用户交互切换到前台，Task切换到后台等待resume。 一个Task可以切换到foreground，所有用户可以在任何他们离开的地方再次开始。举个例子：Task A在它的Stack中有三个Activity（两个在当前Activity之下）。用户点击Home按钮，然后启动另外一个Application，系统会启动一个新的拥有自己的Stack的Task（Task B）。与此交互完之后，用户再次回到Home启动Task A的Application。现在，Task A处于foreground（其Stack中的三个Activity不变，且栈顶的Activity Resumed）。关键是，用户可以通过Home再次回到Task B。这就是Android中多任务处理的实例。 注意：多个任务可以同时存在于后台background。然而，当用户同时在后台运行了过多的任务是，系统可能为了回收内存而销毁一些后台Activity，导致Activity的状态丢失。参见以下Activity State章节。 因为Back Stack中Activity绝对不会被重排，如果你的Application中允许用户通过多个Activity去启动一个特定的Activity，此Activity的一个新实例被创建并push到栈顶（而不是将该Activity之前的实例至于栈顶）。这样，你的Application的一个Activity可能被实例化多次（甚至可能在不同的Task），如图所示： 图解：HomeActivity被实例化多次。 这样，当用户使用Back键向后导航时，每个实例根据打开的顺序都会被显示（每个都有自己的UI状态）。当然，如果你不想Activity被实例化多次，你可以更改这种行为。具体怎么做会在Managing Tasks章节讨论。 总结下Activity和Task的默认行为： 当Activity A启动Activity B，A stopped，但是系统会保存其状态（比如滚动的位置和表单中输入的text）。当用户在B中按Back键，A会恢复状态并resume。 当用户点击Home键退出一个Task时，当前Activity会Stop且它所在的Task切入后台background。系统会保持Task中所有Activity的状态。当用户之后resume此Task时，此Task切换到前台foreground且Task的Stack中栈顶的Activity reusme。 当用户点击Back键时，当前Activity会pop出栈并销毁。Stack中前一个Activity resume。当一个Activity被销毁时，系统不会保存其状态。 Activity可以被实例化多次，即使是在不同的Task中。 Saving Activity State如上讨论，系统默认在Activity Stopped时保存其状态。这么说，当用户通过Back键回到之前的Activity时，展示的UI和他离开时是一样的。但是，你可以或者说应该，主动的调用lifecycle的回调保存Activity的状态，来避免万一Activity被销毁而必须重建。 当系统Stop你的Activity（启了一个新的Activity或是Task移到后台），系统都可能在它回收系统内存时将此Activity完全销毁。此时，Activity的状态信息都将丢失，系统仍然知道此Activity在Back Stack中的位置，但是当此Activity回到前台时系统会重建它（而不是resume）。为了避免丢失用户工作，你应该在你的Activity中实现onSaveInstanceState方法积极的保存状态。 更多Activity状态信息，参见Activity文档。 Managing TasksAndroid管理Task和Back Stack的方式，如上讨论：将连续的Activity置于一个Task和一个Stack中，大多数Application都可以很好的运作而且你不用担心你的Activity如何与Task关联，如何存在于Back Stack中。 然后，你可能想要中断一些正常行为。也许你想你的Application中的一个Activity单独启动一个新的Task；或者当你启动一个Activity时，你希望使用之前创建的实例而不是重新在Back Stack建一个新的实例；又或者你希望用户离开Task时清除你的Back Stack除了根Activity。 在元素中使用属性或是startActivity的Intent中添加flag，你可以做的更多。 有如下属性可以使用： taskAffinity launchMode allowTaskReparenting clearTaskOnLaunch alwaysRetainTaskState finishOnTaskLaunch 主要有以下flag可以使用： FLAG_ACTIVITY_NEW_TASK FLAG_ACTIVITY_CLEAR_TOP FLAG_ACTIVITY_SINGLE_TOP 在以下的章节，你将看到如何使用这些属性和flag去定义Activity关联Task和Back Stack。 注意：大多数Application不需要打断Activity和Task的默认行为。如果你认为改变你Activity的默认行为是必要的，请谨慎使用，且测试Activity在运行时以及通过Back按钮从别的Activity或Task返回时的可用性。一定要测试可能与用户体验冲突的导航行为。 Defining launch modesLaunch Mode让你可以定义你的Activity新实例与当前Task的关联关系。你可以通过两种方式定义Launch Mode： 使用Manifest文件 使用Intent Flag 当Activity A启动Activity B，B可以在manifest文件中定义它与当前Task的关系，A也可以请求B与当前Task的关系。如果两种方式都定义了，则A的请求（Intent）覆盖B的请求（manifest）。 注意：一些Launch mode作用于manifest而不作用于intent flag，同样的一些Launch mode对intent flag有效而不能在manifest中定义。 Using the manifest file当我们在manifest文件中声明Activity时，我们可以使用的launchMode属性来指定我们的Activity应该如何关联一个Task。 launchMode属性指明你的Activity如何在一个Task中启动。有四种属性值： Standard默认值。当Activity启动时系统会在Task中创建一个该Activity的实例。此类Activity可以被实例化多次，每个实例可以属于不同的Task，且一个Task可以拥有它的多个实例。 singleTop如果已经有一个该Activity的实例处于当前Task的栈顶了，系统会通过调用onNewIntent方法引导Intent去调用该实例，而不是为此Activity创建一个新的实例。此类Activity可以被实例化多次，每个实例可以属于不同的Task，且一个Task可以拥有它的多个实例（但是当栈顶是该Activity的现有实例，不会创建新的实例）。 例如：假设一个Task的Back Stack里面有A、B、C、D四个Activity，A-B-C-D（D在栈顶）。一个Intent要启动D，如果D是standard模式的话，会创建一个新的D实例，Stack变为A-B-C-D-D。然而，如果D是singeTop模式的话，已存在的D实例会通过onNewIntent方法来接收这个Intent，以为D已经在栈顶了，此时Stack依然是A-B-C-D。但是，如果来了一个启动B的Intent，Stack中会新建一个B的实例而不管B的launchMode是不是singleTop。 注意：当Activity被创建一个新的实例时，用户可以通过Back键回到前一个Activity。当时当一个当前Activity实例处理一个新的Intent时，用户不可以通过Back回到这个Activity的onNewIntent之前的状态。 singleTask系统会创建一个新的Task，且在这个新的Task的root实例化此Activity。然而，当已经有一个该Activity的实例存在于一个单独的Task时，系统会通过调用onNewIntent方法引导Intent传向已有的这个Activity实例，而不是创建一个新的实例。同一时间只能存在一个Activity实例。 注意：虽然此Activity运行在一个新的Task中，用户点击Back键依然可以回到前一个Activity。 singleInstance与singleTask类似，除了系统在该Activity所在的Task中不会再启动其他任何Activity。Task中有且仅有一个此Activity，任何该Activity启动的Activity都会在另外的Task中打开。 另外一个例子：Android Browser应用声明网页浏览Activity应该总是在自己的Task中打开（在元素中定义singleTask launch mode）。这意味着如果你的Application发送一个Intent去打开Browser，它的Activity不会置于你的Application的Task中。系统会为Browser启动一个新的Task（或者如果已经有一个Browser的task运行在后台了，该Task会切换到前台来处理这个Intent）。 不管一个Activity是运行在一个新的Task还是原来的Task（启动这个Activity的Task）中，用户点击Back键总是可以回到上一个Activity。但是，如果你以singleTask的方式启动一个Activity，且如果已经有一个该Activity的实例存在于后台Task，此Task会整个切换到前台。此时，此Task的Back Stack中的所有Activity都会切换回来处于Stack的顶部。下图展示了此种场景： 图解：Activity Y以singleTask的方式运行于后台Task中，此时Activity2启动Y，会将Y所在的Task的整个Back Stack带回前台。用户按Back键会从Y所在的Task开始回退。 注意：你在manifest中定义的Activity的launch mode属性可以被启动它的Intent flag所覆盖。如下面讨论。 Using Intent flags当你启动一个Activity时，你可以在启动的Intent加上flag来指明Activity关联的Task。有以下几种flag： FLAG_ACTIVITY_NEW_TASK在新的Task中启动Activity。如果已经有一个Task运行着你要启动的Activity，此Task会恢复其最后的状态并切换到前台，而此Activity会在onNewIntent中接收到Intent。与“singleTask”的行为一样。 FLAG_ACTIVITY_SINGLE_TOP当你要启动的Activity正是当前Activity（已经处于栈顶），此已存在的Activity实例会接收Intent并调用onNewIntent，而不是重新创建一个Activity实例。与“singleTop”行为一致。 FLAG_ACTIVITY_CLEAR_TOP当你要启动的Activity之前已经在当前Task运行，不会创建一个新的Activity实例，而是将Stack中该Activity实例之上的Activity全部销毁（此时该实例位于栈顶），该Activity实例resume调用onNewIntent处理Intent。没有相应的launch mode与此flag对应。FLAG_ACTIVITY_CLEAR_TOP通常与FLAG_ACTIVITY_NEW_TASK一起使用。当他们一起使用时，共同目标是把一个已经存在的Activity放入另一个Task且放在一个可以响应Intent的位置。 注意：如果一个Activity的launch mode指定为“standard”，当接收到新的Intent时，它也会被从Stack中移除而新启一个新实例在它的位置去处理该Intent。这是因为launch mode为“standard”的Activity总是会为Intent新建一个实例。 Handling affinities（亲合力）Affinity指明Activity更倾向于属于哪个Task。默认情况下，同一个Application的Activity彼此拥有一个Affinity。所以，默认同一个Application的Activity运行于同一个Task。但是，你可以改变一个Activity的默认Affinity。不同Application的Activity可以共享一个Affinity，或者同一个Application的Activity可以被赋予不同的Task Affinity。 你可以通过元素的taskAffinity属性来改变Activity的Affinity。 taskAffinity是一个字符串值，它必须来自定义与manifest中的唯一包名（package name）。因为系统会使用该名字去区分Application的task affinity。 在以下两种情况Affinity发挥它的作用： 启动Activity的Intent带有FLAG_ACTIVITY_NEW_TASK默认情况下，startActivity启动的新Activity会与它的调用者处于同一个Task，被push到同一个Back Stack。但是，如果startActivity的Intent带有FLAG_ACTIVITY_NEW_TASK，系统会寻找一个不同的Task来容纳新的Activity。通常，这是一个新的Task。然而也不是必须的，如果已经存在着一个与新Activity相同Affinity的Task，新Activity会在此Task中运行。如果没有，才会产生一个新的Task。如果此Flag导致Activity运行在一个新的Task，用户点击Home键离开时，应该有一些方式让用户返回到此Task。一些实体（比如Notification Manager）总是在另外的Task中启动Activity，而非他们本身，所以他们总是使用带有FLAG_ACTIVITY_NEW_TASK的intent来startActivity。如果你有一个Activity可以被其他的实体通过此flag方式调用，注意用户有一个独立的方式Back到原来的Task。比如通过Launcher icon（Task的根Activity具有CATEGORY_LAUNCHER的Intent filter，参见Staring a Task章节）。 Activity的allowTaskReparenting的属性值为true在这种情况下，一个Activity可以从启动它的Task移动到和它拥有同一个Affinity的Task（当此Task切换到前台时）。比如：假设一个旅游Application定义了一个预报选定城市的天气状况的Activity。它与此Application中的其他Activity具有相同的Affinity（默认的Application Affinity），且其allowTaskReparenting属性为true。当你的Activity启动此天气预报Activity时，它会被初始化与你的Activity相同的Task。但是，当此旅游Application的Task切换到前台时，此天气预报的Activity会重新分配到这个Task，且在此Task中显示。 注意：从用户角度看，如果一个apk包含了多个“Application”，你可能要使用“taskAffinity”属性来给属于不同“Application”的Activity分配不同的Affinity值。 Clearing the back stack如果用户离开一个Task很长时间，系统会清除这个Task中Activity除了root Activity。当用户在此回到此Task时，只有此root Activity会被恢复。系统如此设计是因为经过很长时间之后，用户可能已经放弃了之前所做的，重新回来是想做新的事情。 有一些Activity属性可以用来修改此默认行为。 alwaysRetainTaskState如果Task中的root Activity的此属性设置为true，上述默认行为不会发生。此Task会保留Stack中的所有Activity，即使经过了很长时间。 clearTaskOnLaunch如果Task中的root Activity的此属性设置为true，无论什么时候用户离开此Task后再返回它，此Stack都会清除只剩下root Activity。换句话说，此属性是alwaysRetainTaskState的对立面，用户总是以初始状态回到此Task，即使只是离开了一瞬间。 finishOnTaskLaunch此属性类似于clearTaskOnLaunch，但是它仅作用与单独的Activity而不是整个Task。它会导致任意一个Activity出栈，包括root Activity。当它设置为true，此Activity仅仅会为当前会话作为Task的一部分保留。当用户离开并重新返回该Task时，此Activity不再存在。 Starting a task你可以设定一个Activity作为一个Task的入口，通过给他的Intent filter一个“android.intent.action.MAIN”的action和一个“android.intent.category_LAUNCHER”的category。如： 1234567&lt;activity ... &gt; &lt;intent-filter ... &gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; ...&lt;/activity&gt; 拥有此intent filter的Activity会在Launcher Application中显示其icon和label，给用户一种方式去启动此Activity或是在其已经被创建的情况回到创建它的Task。 第二个能力相当重要：用户必须可以在离开一个Task后通过Launcher重新回来。为此，“singleTask”和“singleInstance”这两个标记Activity总是新启一个Task的launch mode属性，应该仅仅用于拥有“ACTION_MAIN”和“CATEGORY_LAUNCHER”的Activity。试想一下，如果没有此Intent filter（main/launcher）什么会发生：一个Intent启动一个“singleTask”的Activity，初始化一个新的Task，而且用户在此Task中做了一定的工作。之后用户按了Home按钮，此Task切换到后台且对用户不可见，此时用户将回不去此Task，因为在Launcher中没有icon呈现。 对于那些你不想用户再回去的Activity，可以设置元素的finishOnTaskLaunch为true。参见Clearing the back stack。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"翻译","slug":"翻译","permalink":"http://blog.lmj.wiki/tags/翻译/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"[译]Bound Service","slug":"docs/Bound Service","date":"2013-05-04T04:31:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2013/05/04/docs/Bound Service/","link":"","permalink":"http://blog.lmj.wiki/2013/05/04/docs/Bound Service/","excerpt":"Bound ServiceBound Service在C-S中属于服务端（server）。Bound Service允许其他组件（比如Activity）来bind它，发送请求，接收响应，甚至通过IPC。Bound Service通常仅在为其他组件服务时才存活，且不会在后台无限运行。 此文档告诉你如何创建一个Bound Service，包括如何通过其他组件来bind此Service。当然，你也可以参看Services文档来获得更多信息。","text":"Bound ServiceBound Service在C-S中属于服务端（server）。Bound Service允许其他组件（比如Activity）来bind它，发送请求，接收响应，甚至通过IPC。Bound Service通常仅在为其他组件服务时才存活，且不会在后台无限运行。 此文档告诉你如何创建一个Bound Service，包括如何通过其他组件来bind此Service。当然，你也可以参看Services文档来获得更多信息。 The BasicsBound Service是一个Service的实现，允许其他Application去bind并与之交互。你必须实现onBind方法来提供Service的bind。此onBind方法会返回一个IBinder对象（定义client与你的Service交互的接口）。 Client可以调用bindService来bind一个Service。如果这么做了，client必须实现提供一个ServiceConnection的实现，用来监听与Service的连接。bindService会直接无结果返回，但是当Android系统创建Service与Client的连接时，会调用ServiceConnection中的onServiceConnected方法，分发IBinder使Client可以用来与Service交互。 多个Client可以同时与一个Service保持连接。然而，系统仅会在第一个Client bind时调用你的Service的onBind方法去获取IBinder，系统会分发同样的IBinder给其他bind的Client，而不再调用onBind。 当最后一个Client从Service unbind后，系统会销毁此Service（除非此Service是通过startService启动的）。 当你实现一个Bound Service，重要的部分是你要实现一个IBinder的接口来给onBind返回。有几种方式可以实现这个IBinder接口，下面的章节将会讨论到。 Creating a Bound Service创建一个Bound Service时，必须提供一个IBinder来供client用来与Service交互。以下有三种定义接口的方式： Extending the Binder class如果你的Service是你的Application私有的，且与Client运行在相同的process（通常是这样的），你应该通过继承Binder来实现你的接口，Client接收到此Binder后可以使用它直接访问这个Binder实现甚至是Service的public方法。如果你的Service仅仅是为你自己的Application提供后台工作，此方式是建议使用的。仅当你的Service要被其他Application使用或是跨进程的时候才不使用这种方式。 Using a Messenger如果你需要你的接口工作在不同的process，你可以使用Messenger来为Service创建接口。通过这种方式，Service定义一个Handler来响应不同类型的Message对象。此Handler是Messenger的基础，可以与Client共享一个IBinder，允许Client使用Message对象发送命令给Service。另外，Client可以定义自己的Messenger，这样Service就可以回馈Message。这是一个简单的执行IPC的方式，因为Messenger会在一个简单的线程里排列所有请求，所以你没有必要设计你的Service的线程安全。 Using AIDLAIDL（Android接口定义语言）所要做的事是将对象分解成基本类型使系统可以识别并marshall（整编）通过IPC跨进程传送。在前一种方式中（使用Messenger），事实上底层结构也是基于AIDL的。如上所述，Messenger使用一个简单线程来排列client的请求，所以Service一次只能接受一个请求。然而，如果你想要Service能同时处理多个请求，你可以直接使用AIDL。这种情况下，你的Service必须建立线程安全来处理多线程。要直接使用AIDL，你必须创建一个.aidl文件来定义一个编程接口。Android SDK工具使用此文件来生成一个抽象类来实现此接口并处理IPC，你可以在你Service中继承此抽象类。 注意：大多数应用不需要使用AIDL来创建Bound Service，因为这样会要求有多线程处理能力并且会导致更加复杂的实现。因此，AIDL不适用与大多数Application，此文档不讨论如何在你的Service中使用它，如果你确实需要使用，可以参见AIDL文档。 Extending the Binder class如果你的Service仅仅在你自己的Application中使用且不用跨进程工作，你可以实现自己的Binder类提供给你的Client直接访问Service的public方法。 注意：仅在client和Service在同一Application和process时使用这种方式（这是最常见的）。例如，音乐播放器的Activity需要与自己的播放音乐的后台Service bind的时候，这个就可以使用。 如何创建: 在你的Service中，创建一个Binder的实例：a) 包含Client可以调用的public方法b) 返回当前Service的实例，拥有Client可以调用的public方法c) 或者返回一个Service中其他类的实例（拥有Client可以调用的public方法） 在onBind回调方法中返回此Binder实例。 在Client端，在onServiceConnected回调中接收此Binder，使用同的public方法调用使用Bound Service。 注意：Service和Client必须是同一个Application是因为这样的话Client可以转换返回的结果和正确的调用API。Service和Client也必须是同一个process，因为这个方式不会执行跨进程的重组（marshall）。 如下实例： 123456789101112131415161718192021222324252627public class LocalService extends Service &#123; // Binder given to clients private final IBinder mBinder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don't need to deal with IPC. */ public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125;&#125; LocalBinder提供一个getService方法来让client获取当前LocalService的实例，允许client调用Service的public方法。比如client可以调用Service的getRandomNumber方法。如下有一个Activity bind此Service并调用getRandomNumber方法，当按钮点击时： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BindingActivity extends Activity &#123; LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, \"number: \" + num, Toast.LENGTH_SHORT).show(); &#125; &#125; /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; // We've bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mBound = false; &#125; &#125;;&#125; 上述例子展示了Client如何bind到Service，使用ServiceConnection的实现及其onServiceConnected回调。下一章节会详细说明这一bind过程。 注意：例子代码没有明确从Service中unbind，但是所有client应该在合适的时间（例如Activity的onPause等）unbind。 Using a Messenger如果你需要你的Service与远程进程（remote process）交互，你可以使用Messenger为你的Service提供一个接口。此方式允许你跨进程（IPC）而不需要使用AIDL。 使用Messenger时有以下要点: Service实现一个Handler来接收client的每一个调用 使用Handler创建一个Messenger对象（与此Handler关联） Messenger创建一个IBinder供Service的onBind方法返回 Client使用此IBinder实例化Messenger（Client用来发送Message给Service） Service在它的Handler的handleMessage方法中接收每个Message 这种方式，Service没有供Client调用的方法，而是通过Client发送message给Service的Handler处理。 参见如下例子： 1234567891011121314151617181920212223242526272829303132333435public class MessengerService extends Service &#123; /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ class IncomingHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_SAY_HELLO: Toast.makeText(getApplicationContext(), \"hello!\", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; /** * Target we publish for clients to send messages to IncomingHandler. */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(getApplicationContext(), \"binding\", Toast.LENGTH_SHORT).show(); return mMessenger.getBinder(); &#125;&#125; 注意Handler中的handleMessage，在此Service接收Message并基于what成员来决定怎么做。 Client所有要做是就是基于Service返回的IBinder创建一个Messenger并使用send方法发送Message。例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ActivityMessenger extends Activity &#123; /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); mBound = true; &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; &#125; &#125;; public void sayHello(View v) &#123; if (!mBound) return; // Create and send a message to the service, using a supported 'what' value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125;&#125; 实例中没有展示Service如何给Client回应。如果你想要Service予以回应，你需要在你的Client也创建一个Messenger。放Client接收到onServiceConnected回调，调用send方法发送一个replyTo参数为Client的Messenger的Message给Service。 Binding to a ServiceApplication组件（Client）调用bindService来bind一个Service，之后Android系统会调用Service的onBind方法，返回一个与Service交互的IBinder。 这个bind是异步的。bindService会直接返回而不会给Client返回IBinder。要接收这个IBinder，Client必须创建一个ServiceConnection实例并传送给bindService方法。ServiceConnection有一个回调方法，系统会调用它来分发此IBinder。 注意：只有Activity，Content Provider和Service才可以bind一个Service，Broadcast Receiver不能bind Service。 为了在你的Client绑定一个Service，你必须： 实现ServiceConnection你的实现必须override两个回调：onServiceConnected系统调用它来分发Service的onBind方法返回的IBinder。onServiceDisconnected系统在Service的连接意外丢失（例如Service崩溃或是被kill）时调用此方法。当Client与Service unbind时不会调用。 调用bindService并传入此ServiceConnection的实现 当系统调用onServiceConnected回调时，你可以使用接口中的方法调用Service 调用unbindService来与Service断开连接 如果你的Client销毁了，它会与Service unbind，但是你必须总是自己unbind，当你与Service交互完成或是你的Activity处于pause状态的时候，这样Service就可以在不使用的时候关闭（合适的时间bind，unbind在下面会讨论）。 在上述Extending the Binder class的例子中，都必须将返回的IBinder转型为LocalBinder，从而得到LocalService实例： 123456789101112131415161718LocalService mService;private ServiceConnection mConnection = new ServiceConnection() &#123; // Called when the connection with the service is established public void onServiceConnected(ComponentName className, IBinder service) &#123; // Because we have bound to an explicit // service that is running in our own process, we can // cast its IBinder to a concrete class and directly access it. LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; // Called when the connection with the service disconnects unexpectedly public void onServiceDisconnected(ComponentName className) &#123; Log.e(TAG, \"onServiceDisconnected\"); mBound = false; &#125;&#125;; Client可以将此ServiceConnection传给bindService来bind一个Service。如下： 12Intent intent = new Intent(this, LocalService.class);bindService(intent, mConnection, Context.BIND_AUTO_CREATE); bindService的第一个参数是一个Intent，显式指明了要bind的Service的class name（此Intent也可以是隐式的） 第二个参数就是ServiceConnection对象 第三个参数是一个flag，标识bind的选项。通常使用BIND_AUTO_CERATE来指明如果Service还未存活的话则创建该Service。其他可用的选项包括BIND_DEBUG_UNBIND，BIND_NOT_FOREGROUND或是0。 Additional notesBind一个Service时有一些重要的注意事项： 你应该总是捕捉DeadObjectException异常，此异常会在连接被破坏时抛出。这是远程方法（remote method）抛出的唯一异常。 Objects are reference counted across processes. （理解：跨进程对象引用计数）。 你通常应该成对使用bind和unbind对应你的client端生命周期的“bring-up”和“tear-down”时刻。例如： 如果你仅仅是在你的Activity可见时与Service交互，你应该在onStart中bind而在onStop中unbind。 如果你想你的Activity就算是stop在后台的情况仍能接收到响应，你可以在onCreate中bind而在onDestroy中unbind。要当心的是这意味着你的Activity的整个生命周期都要用到Service（即使在后台），所以如果此Service运行在另外的process，当你增加了此process的负担时，此Service会变得更可能被系统kill掉。 注意：你通常不应该在你的Activity的onResume和onPause中进行bind和unbind，因为这两个回调在每次生命周期转换中都会发生，你应该确保这种处理（bind和unbind）发生在转换最少的时候。同样，如果你的Application中多个Activity绑定了同一个Service并且在其中两个Activity之间有一个状态转换，在当前Activity unbind（onPause中）之后，下一个Activity bind（onResume中）之前，此Service可能被销毁而重新创建。 Managing the Lifecycle of a Bound Service当Service从所有Client unbind之后，Android系统会销毁它（除非它也通过onStartCommand启动）。所以一个纯的Bound Service，你不需要去管理其生命周期，系统会根据它bind的client来管理它的生命周期。 然而，如果你选择实现onStartCommand回调，你就必须显式的stop该Service，因为该Service现在被认为是Started Service。这种情况下，Service会一直运行直到Service调用stopSelf或是其他组件调用stopService来stop它，不管它是否与其他Client bind。 另外，如果你的Service是Started且接受bind，当系统调用你的onUnbind回调时，你可以返回一个true，这样在下次Client来bind它时你将接收onRebind而非onBind。onRebind返回一个void，但是Client依旧会在onServiceConnected中接收到一个IBinder。下图展示了此类型Service的生命周期： 图解：Started 且允许Bind的Service的生命周期。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"翻译","slug":"翻译","permalink":"http://blog.lmj.wiki/tags/翻译/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"[译]Service","slug":"docs/Service","date":"2013-04-21T11:12:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2013/04/21/docs/Service/","link":"","permalink":"http://blog.lmj.wiki/2013/04/21/docs/Service/","excerpt":"##Services Service是一种Application组件，可以在后台执行长时间的操作且不提供UI。其他的Application组件可以启动它并且它会一直在后台持续运行即使是用户切换到了另一个Application。同时，一个组件可以bind一个Service并与之交互甚至是进程间的通信（IPC）。例如：一个Service可以处理网络事务，播放音乐，执行文件I/O，或者与Content Provider交互，所有这些都是在后台执行。","text":"##Services Service是一种Application组件，可以在后台执行长时间的操作且不提供UI。其他的Application组件可以启动它并且它会一直在后台持续运行即使是用户切换到了另一个Application。同时，一个组件可以bind一个Service并与之交互甚至是进程间的通信（IPC）。例如：一个Service可以处理网络事务，播放音乐，执行文件I/O，或者与Content Provider交互，所有这些都是在后台执行。 Service可以两种方式运行： Started当一个Application组件（比如一个Activity）通过调用startService方法启动一个Service，我们称之为“Started”。一旦Started，Service可以在后台无限运行，即使是这个启动它的组件已经销毁。通常，一个Started的Service执行单一的操作且不为它的调用者返回结果。例如，它可以通过网络下载或上传文件。当一个操作执行完成，Service应当Stop自己。 Bound当一个Application组件通过调用bindService绑定一个Service，我们称之为“Bound”。一个Bound Service会提供一个Client-Server的接口来允许其他组件与之交互，发送请求，获取结果，甚至是通过跨进程的方式（IPC）。一个Bound Service仅与绑定它的Application组件的运行时间一样。多个组件可以同时绑定一个Service，但是所有绑定项unbind时，该Service才可以被销毁。 虽然此文档基本上都是单独讨论这两种类型的Service，你的Service可以同时以两种方式工作（Started：无限运行，允许绑定）。这是很简单的事，你只需要实现两个回调方法：onStartCommand允许其他组件Start它，onBind允许bind它。 不管你的Service是Started，Bound或者二者皆是，任何其他Application都可以使用这个Service（即使是另外的Application），就像其他组件使用你的Activity那样（通过Intent）。当然，你也可以在manifest文件中私有化声明你的Service，从而阻止别的Application访问。这个会在Declaring the service in the manifest中讨论。 注意：Service运行在它所在process的主线程（main thread）中——-Service不会创建它自己的Thread，且不会运行在另一个单独的process（除非你特别声明）。这意味着如果你的Service要做任何耗CPU或阻塞操作（例如MP3播放，网络获取等），你应该在Service中新建一个Thread来处理这些事。通过使用单独的Thread，你可以减少ANR的风险，而Application的主线程（main thread）可以关注于你的Activity与用户的交互。 The Basics要创建一个Service，你必须创建一个Service.java的子类（或其子类的子类）。在你的实现里，你需要override Service生命周期中一些处理关键环节的回调方法，和提供一种其他组件bind此Service的机制。你需要override的最重要的回调如下： onStartCommand当其他组件，比如一个Activity调用startService方法来请求启动该Service时，系统会调用此方法。一旦此方法执行，Service已经被Started且可以无限在后台运行。如果你实现了此方法，你有责任在任务完成后调用stopSelf或stopService来stop此Service（如果你仅仅是想提供来bind，则无需实现此方法）。 onBind当其他组件通过调用bindService想要与此Service绑定（比如执行RPC）时，系统会调用此方法。如果你实现了此方法，你必须提供一个接口（返回一个IBinder）供用户用来与Srevice交流。你必须总是实现此方法，但是如果你不想Service可以Bind，在此方法中返回null即可。 onCreate当Service第一次创建时会调用，用来执行一次性的初始化程序（在onStartCommand和onBind之前）。如果此Service已经在运行了，该方法不会被调用。 onDestroy在Service不再使用将要销毁时系统调用此方法。你的Service应该实现该方法去清除释放资源，比如线程，注册的监听，receiver等等。这是Service接收到的最后一个方法。 如果一个组件通过调用startService启动一个Service（这会导致onStartCommand的调用），此Service会持续运行直到它自己stopSelf或是其他组件调用stopService来stop它。 如果一个组件通过调用bindService创建一个Service（onStartCommand不会调用），此Service的运行时间与Bind它的组件一样。一旦所有客户端（client）都unBound此Service，系统会销毁它。 Android系统只有在低内存且必须为与用户交互（user focus）的Activity回收系统资源时才会强制stop Service。如果此Service与当前用户focus的Activity绑定，它不太可能被kill。如果此Service被声明为run in the foreground（之后会讲到），它几乎绝不会被kill。另外，如果Service被start后长时间运行，系统会随着时间的推移降低其在后台Task列表中位置，从而此Service会变得高概率被kill。如果你的Service启动起来，你应该设计一种良好的方式去处理系统去重启它。因为如果系统kill你的Service，它会在资源可用之后尽快的重新启动（虽然它也依赖与你从onStartCommand返回的值，后续讨论）。更多系统销毁Service的信息，参加Processes and Threading文档。 下面章节将讨论如果创建不同类型的Service和其他组件如何去使用它。 Declaring a service in the manifest和Activity（以及其他组件）一样，你必须在你的manifest文件中声明所有的Service。为了声明Service，要在元素中添加一个的子元素，如： 1234567&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;service android:name=\".ExampleService\" /&gt; ... &lt;/application&gt;&lt;/manifest&gt; 还有一些属性你可以在中定义，比如启动此Service的权限（permission），Service应该运行的process。android:name是唯一必须要有的属性，它指定此Service的class name。一旦你发布你的应用，你就不应该改变它的名字，因为如果你改变了，一些使用显式Intent关联你的Service的功能可能阻塞。 和Activity一样，Service可以定义intent filter来允许其他组件通过隐式Intent的方式启动它。通过声明Intent filter，用户设备中安装的任何应用的组件都可以潜在的启动你的Service。 如果你计划仅仅本地使用此Service（其他Application不能使用），你不需要且不应该提供任何intent filter。没有任何intent filter，你必须使用显式class name的Intent来启动Service。更多信息将在以下starting a service中说到。 另外，你可以设置Service的android:exported属性为false来确保你的Service对你的Application私有化。此属性同样作用于你提供了intent filter的情况。 更多Service的intent filter信息，参见Intents and Intent Filters文档。 Creating a Started Service另一个Application组件调用startServie启动的Service称之为Started Service，会调用Service的onStartCommand方法。 一旦Service Started，它的生命周期不依赖于启动它的组件，它可以在后台无限运行，即使启动它的组件已经销毁。同样，Service可以在工作完成后调用stopSelf来stop自己，或是其他组件可以通过调用stopService来stop此Service。 一个Application组件（比如Activity）可以调用startService来启动Service（传送一个Intent指定Service，包含Service需要使用的数据）。Service在它的onStartCommand方法中接收此Intent。注意：Android1.6以及之前，你应该实现onStart, Android2.0后使用onStartCommand代替onStart。 例如，假设一个Activity需要往数据库中保存一些数据。Activity可以启动一个Service，并将需要保存的数据通过intent传送。Service在onStartCommand中接收此Intent，连接到互联网并执行数据库事务。当事务执行完毕，Service自己Stop且销毁。 默认情况下，Service运行在声明它的Application所在的process，且在Application的主线程（main thread）运行。所以，如果你的Service在用户与Activity（同一个Application的）交互时执行高密度和阻塞操作，将会减慢Activity的执行。为了避免影响Application的运行，你应该在Service中启动一个新的Thread。 通常，你可以继承以下两个Class来创建一个Started Service。 Service所有Service的基类。当你继承此class，重要的是你要创建一个新的Thread来做Service的工作，因为此Service使用你Application的main thread，默认，这会减慢你的Application的所有Activity的运行。 IntentService这是一个Service的子类，它使用一个工作线程来处理启动请求，每次一个。如果你不想你的Service同时处理多个请求，这是最好的选择。所有你要做的就是实现onHandleIntent方法，它会接收每个启动请求的Intent，所以你可以做后台处理。 下面的章节将描述你的Service如何实现其中任一种。 Extending the IntentService class因为绝大多数Started Service不需要同时处理过个请求（有多线程风险），也许最好的方式是继承IntentService实现你的Service。 IntentService做以下工作： 创建一个默认的工作线程（与你的Application的主线程分离）来处理onStartCommand分发的所有Intent。 创建一个工作队列，一次传送一个Intent给你的onHandleIntent实现，所以你不用担心多线程。 在所有请求处理完成后Stop Service，所以你不需要调用stopSelf。 提供一个默认返回null的onBind实现。 提供一个默认的onStartCommand实现，它会传送intent给工作队列，最终给onHandleIntent处理。 所有你需要做的其实就是实现onHandleIntent方法。（虽然你也需要提供一个简单的构造）以下是一个实现IntentService的例子： 123456789101112131415161718192021222324252627282930public class HelloIntentService extends IntentService &#123; /** * A constructor is required, and must call the super IntentService(String) * constructor with a name for the worker thread. */ public HelloIntentService() &#123; super(\"HelloIntentService\"); &#125; /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ @Override protected void onHandleIntent(Intent intent) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. long endTime = System.currentTimeMillis() + 5*1000; while (System.currentTimeMillis() &lt; endTime) &#123; synchronized (this) &#123; try &#123; wait(endTime - System.currentTimeMillis()); &#125; catch (Exception e) &#123; &#125; &#125; &#125; &#125;&#125; 所有你需要做的：一个onHandleIntent的实现和一个构造函数。 如果你决定也override其他的回调方法，例如onCreate、onStartCommand或onDestroy，确保你调用了父类（super）的实现，这样IntentService才能妥善处理工作线程的生命周期。 例如，onStartCommand必须返回一个默认的实现（Intent被发送到onHandleIntent）： 12345@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show(); return super.onStartCommand(intent,flags,startId);&#125; 除了onHandleIntent，唯一你不需要调用父类实现的是onBind方法（但是仅当你的Service可以被bind的时候才需要实现此方法）。 在下一章节中，你将看到如何通过继承Service来实现同类的Service（Started Service），如果你要同时处理启动请求，这个是比较适合的。（虽然有较多代码要写） Extending the Service class如你所见，上一章节中使用IntentService来实现一个Started Service是非常简单的。但是，如果，你需要你的Service可以处理多线程（而不是通过一个工作队列来处理请求），你可以继承Service来处理每个Intent。 比较起见，底下的代码继承Service实现的功能与以上继承IntentService的一样。也就是说，对于每一个请求，使用工作线程来处理，且每次一个请求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class HelloService extends Service &#123; private Looper mServiceLooper; private ServiceHandler mServiceHandler; // Handler that receives messages from the thread private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. long endTime = System.currentTimeMillis() + 5*1000; while (System.currentTimeMillis() &lt; endTime) &#123; synchronized (this) &#123; try &#123; wait(endTime - System.currentTimeMillis()); &#125; catch (Exception e) &#123; &#125; &#125; &#125; // Stop the service using the startId, so that we don&apos;t stop // the service in the middle of handling another job stopSelf(msg.arg1); &#125; &#125; @Override public void onCreate() &#123; // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process&apos;s // main thread, which we don&apos;t want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread thread = new HandlerThread(&quot;ServiceStartArguments&quot;, Process.THREAD_PRIORITY_BACKGROUND); thread.start(); // Get the HandlerThread&apos;s Looper and use it for our Handler mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show(); // For each start request, send a message to start a job and deliver the // start ID so we know which request we&apos;re stopping when we finish the job Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; mServiceHandler.sendMessage(msg); // If we get killed, after returning from here, restart return START_STICKY; &#125; @Override public IBinder onBind(Intent intent) &#123; // We don&apos;t provide binding, so return null return null; &#125; @Override public void onDestroy() &#123; Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 如你所见，比起IntentService做了更多的工作。 然而，因为你可以自己调用onStartCommand来处理每个请求，你可以同时执行多个请求。如果这是你的需求，你可以为每个请求创建一个线程去正确的运行（而不是等待前一个请求处理完成）。 需要注意是onStartCommand必须返回一个integer。此整形值描述了系统在kill掉Service后该如何持续此Service（如上讨论，IntentService的默认实现会处理这些，虽然你也可以改变此默认实现）。onStartCommand的返回包括以下几种： START_NOT_STICKY如果系统在onStartCommand返回之后kill Service，不重新创建Service。除非还有pending的Intent要deliver（分发）。这是最安全的选项去避免运行你的Service，当不必要或是当你的Application可以简单的恢复任何未完成的任务时。 START_STICKY如果系统在onStartCommand返回之后kill Service，重建该Service并调用onStartCommand，但是不重新分发（redeliver）最后的Intent。相反的，系统以一个null Intent调用onStartCommand，除非还有pending的Intent去启动此Service，此情况下，所有的Intent都会被delivered。这个比较适合媒体播放器（或类似的服务），他们不执行命令，而是无限运行等待一个任务。 START_REDELIVER_INTENT如果系统在onStartCommand返回之后kill Service，重建该Service并以最后一个deliver给此Service的Intent调用onStartCommand。每个pending的Intent都以顺序分发给此Service。这个适用于积极执行一个应该被立即resume的任务的Service，例如下载一个文件。 Starting a Service你可以从一个Activity或其他Application组件启动一个Service，通过传送一个Intent（指定要启动的Service）给startService。Android系统会调用Service的onStartCommand方法并传送给它该Intent（你绝不应该直接调用onStartCommand）。 如下，Activity可以通过显式的Intent启动一个Service。 12Intent intent = new Intent(this, HelloService.class);startService(intent); startService方法会直接返回而Android系统会调用Service的onStartCommand方法。如果此Service尚未运行，系统会先调用onCreate，然后调用onStartCommand。 如果此Service没有也提供bind。发送给startService的Intent是Application组件与Service的唯一模式。当然，如果你想你的Service返回一个结果，启动Service的客户端可以为一个Broadcast（使用getBroadcast()）创建一个PendingIntent，且将此Intent传送给Service。Service可以使用此Broadcast来分发结果。 多个启动Service的请求导致多个对应的onStartCommand的调用。但是，只有一个请求可以stop此Service（通过stopSelf和stopService）。 Stopping a service一个Started Service必须管理自己的生命周期。也就是说，系统不会stop或是destroy此Service除非必须回收系统内存且此服务持续运行到onStartCommand返回之后。所以，Service必须通过调用stopSelf来Stop自己，会是其他组件调用stopService方法。 一旦调用stopSelf或stopService，系统会尽快destroy掉该Service。 然而，如果你的Service在onStartCommand中同时处理多个请求，你不应该在start请求完成后stop你的Service，因为你可能又收到了一个新的start请求（第一次请求后的Stop可能会终结第二个请求）。为了避免这种问题，你可以使用stopSelf(int)来确保你请求stop此Service总是基于最近的start请求。也就是说，当你调用stopSelf(int)，你可以传一个与你的Stop请求相对应的start请求ID（onStartCommand有此startId）。这样，如果Service在你可以调用stopSelf(int)之前接收到一个新的start请求，由于ID不匹配所有Service不会stop。（此段需要再根据实际代码理解） 注意：你的Application在Service不工作时stop它是非常重要的，为了避免浪费系统资源和消耗电池电量。如果必要，其他组件可以调用stopService来stop此Service。即使你为Service开启绑定（理解为Bound Service），如果Service曾经接收过调用onStartCommand的请求，你都必须自己手动stop这个Service。 Service生命周期的更多信息，参见Managing the lifecycle of a Service章节。 Creating a Bound ServiceBound Service允许Application的组件通过调用bindService来绑定它，以创建一个长期的连接（且通常不允许组件调用startService来启动它）。 当你想要Service与你的Application中的Activity或其他组件交互，或是通过IPC暴露你的Application的功能给其他应用，此时你应该创建一个Bound Service。 要创建一个Bound Service，你必须实现onBind回调并返回一个IBinder（定义Service的通信接口）。其他Application组件可以调用bindService来获取此接口并调用Service的方法。此Service仅为服务于绑定它的Application组件而生存，所以当没有任何组件绑定此Service时，系统会销毁它（你不需要stop一个Bound Service，但是你必须stop当此Service是通过onStartCommand启动时）。 要创建一个Bound Service，第一件必须要做的事是定义一个客户端如何于此Service交互的接口。此Service与Client间的接口必须实现IBinder，且你的Service必须在onBind中返回此接口。一旦Client接收到此接口，它就可以开始通过此接口与你的Service进行交互。 有很多方式去实现一个Bound Service，而且实现起来比Started Service复杂得多，所以我们在一个单独的文档讨论Bound Service。参见Bound Services文档。 Sending Notifications to the User一旦Service运行起来，它可以通过Toast Notification和Status Bar Notification两种方式向用户通知事件。 Toast Notification是一种短时间显示在当前窗口的消息，而Status Bar Notification在StatusBar上提供一个icon和message（用户可以选择它来执行一个Action，例如启动一个Activity）。 通常，当一些后台工作完成（文件下载完成）时提供一个Status Bar Notification是最好的方式，此时用户可以采取一些行动。当用户在下拉通知栏（Expand View）选择此通知时，此Notification可以启动一个Activity（例如查看此下载完的文件）。 Toast Notification和Status Bar Notification参见其他开发文档。 Running a Service in the ForegroundForeground Service被认为是用户actively aware of（理解为保持积极工作意识）因此不作为系统低内存下kill候选的Service。Foreground Service必须提供一个Status Bar Notification（放置一个“Ongoing/正在进行”的标题），这意味着除非此Service stop或是从前台移除此Notification才会消失。 例如：一个音乐播放器的播放音乐的Service应该设定为Foreground Service，因为用户明确的知道它的操作。在Status Bar上的Notification必须指明当前播放的曲目，且允许用户启动一个Activity来与音乐播放器交互。 调用startForeground可以让你的Service在前台运行。此方法有两个参数：一个唯一的整型标识Notification和一个StatusBar上要显示的Notification。如下： 1234567Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION, notification); 可以调用stopForeground来将此Service从前台移除。此方法有一个boolean参数，指明是否也移除Status Bar上的Notification。此方法不会stop Service。当然，如果你在Service仍旧运行于前台时stop它，Notification也会被移除。 注意：startForeground和stopForeground是在Android2.0中提出的，在之前的平台，你必须使用setForeground（参见startForeground的API文档）。 Managing the Lifecycle of a ServiceService的生命周期相比于Activity要简单很多。但是，你要特别关注你的Service的创建与销毁，因为Service可以在用户无意识的状态下在后台运行。 Service的生命周期（从创建到销毁）有两种不同的路径： Started Service通过其他组件调用startService创建的。此类Service无限期运行所以必须手动stop，（stopSelf或是其他组件调用stopService）。当Service stop后，系统会销毁它。 Bound Service通过其他组件（client）调用bindService创建的。该Client通过一个IBinder接口与Service交互。此Client也可以调用unbindService来关闭此链接。多个client可以绑定同一个Service，且当所有client都unbind后，系统才会销毁Service（此种Service不需要自己stop）。 这两条路径不是完全独立的，也就是说，你可以Bind一个已经通过startService启动的Service。比如：一个后台播放音乐的服务可能被一个指定音乐播放的Intent起来（startService）。之后，可能用户可能想要对播放器进行一些控制或是获取当前播放音乐的信息，可以使用一个Activity来bind此Service（bindService）。在这种情况下，调用stopService或是stopSelf都不会实质上stop此Service直到所有client都与Service unbind。 Implementing the lifecycle callbacks与Activity类似，Service也拥有一些生命周期的回调函数，你可以去实现来监听Service的状态变化或是在合适的时间做合适的事。如下： 12345678910111213141516171819202122232425262728293031323334public class ExampleService extends Service &#123; int mStartMode; // indicates how to behave if the service is killed IBinder mBinder; // interface for clients that bind boolean mAllowRebind; // indicates whether onRebind should be used @Override public void onCreate() &#123; // The service is being created &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // The service is starting, due to a call to startService() return mStartMode; &#125; @Override public IBinder onBind(Intent intent) &#123; // A client is binding to the service with bindService() return mBinder; &#125; @Override public boolean onUnbind(Intent intent) &#123; // All clients have unbound with unbindService() return mAllowRebind; &#125; @Override public void onRebind(Intent intent) &#123; // A client is binding to the service with bindService(), // after onUnbind() has already been called &#125; @Override public void onDestroy() &#123; // The service is no longer used and is being destroyed &#125;&#125; 注意：与Activity中的回调不同的是，你不需要必须调用父类的实现。 通过实现以上的回调方法，你可以监听Service生命周期中的两个嵌套循环： Entire lifetimeonCreate和onDestroy之间。与Activity类似，Service在onCreate中初始化而在onDestroy中释放所有保留的资源。例如，一个音乐播放的Service可以在onCreate中创建播放音乐的Thread，而在onDestroy中stop此Thread。 Active lifetime从onStartCommand或是onBind开始，分别处理从startService或bindService中传过来的Intent。如果是一个Started Service，它的Active Lifetime的结束与Entire lifetime的结束是一样的（即使在onStartCommand返回之后此Service还是Active）。如果是一个Bound Service，在onUnbind返回后Active lifetime就结束了。 注意：虽然一个Started Service可以通过调用stopService或是StopSelf来stop，他们没有对应的回调（没有诸如onStop之类的）。所以，除非Service绑定了一个client，系统在Service stopped之后销毁它（onDestroy是唯一接收到的回调）。 下图展示了Service的典型回调。虽然图示将Service以创建方式（startService或bindService）分开。但是要记住，不管一个Service如何启动，都潜在的允许client去bind它。所以，一个onStartCommand的Service（startService）仍然可以调用onBind（当其他client调用bindService时）。 图解：左边是Started Service，右边是Bound Service。更多Bound Service的信息，参见Bound Service文档。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"翻译","slug":"翻译","permalink":"http://blog.lmj.wiki/tags/翻译/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]},{"title":"[译]Activity","slug":"docs/Activity","date":"2013-04-18T08:08:00.000Z","updated":"2017-09-12T15:16:05.000Z","comments":true,"path":"2013/04/18/docs/Activity/","link":"","permalink":"http://blog.lmj.wiki/2013/04/18/docs/Activity/","excerpt":"ActivitiesActivity是一个应用组件（Application Component），它提供一个与用户交互的界面。比如拨打电话，拍照，发送Email，查看地图等。每个Activity都提供展示UI的Window。通常情况下这个Window都是全屏的，当然也可以是小于屏幕或者浮在其他Window上面的。","text":"ActivitiesActivity是一个应用组件（Application Component），它提供一个与用户交互的界面。比如拨打电话，拍照，发送Email，查看地图等。每个Activity都提供展示UI的Window。通常情况下这个Window都是全屏的，当然也可以是小于屏幕或者浮在其他Window上面的。 一个Application通常包含很多个Activity，这些Activity之间的关系彼此松散。典型的，一个Application中有一个称作为Main Activity的Activity，此Main Activity在用户首次启动这个Application时展示给用户。每个Activity都可以为了执行不同的Action启动另外一个Activity。每次当一个新的Activity启动时，前一个Activity会被stop，但是系统会保存这个Activity在一个栈（Back Stack）中。当一个新的Activity启动时，会被push到这个Stack的Top，并且获得用户焦点（User focus）。此Back Stack遵循“LIFO（先进后出）”的原则，所以，当用户完成此Activity的工作并点击“Back”键返回时，此Activity会从Back Stack中pop（并且destroy），前一个Activity会被resume。关于Back Stack的部分详细请参照Tasks and Back Stack文档。 当一个Activity是被另一个Activity的start所stop时，它会通过Activity’s Lifecycle来通知状态的变化。由于这个状态的变化（creating，stopping，resuming 或者destroying ），Activity会接收一系列的回调方法，这些回调方法提供给你一个机会去根据状态的变化来做一些工作。比如，当Stopped的时候，你的Activity应该释放所有大的Object，比如数据库或者网络连接。当Resume，你可以重新获取必要的资源和重新开始之前中断的工作。这些状态转换是所有Activity Lifecycle的一部分。 底下的文档会讨论一些基础知识，怎么去创建和使用Activity，Activity Lifecycle如何工作，帮助你妥善管理和处理这些状态之间的转换。 Creating an Activity要创建一个Activity，你必须创建一个Activity.java的子类，（或是子类的子类）。在这个我们自己创建的Activity子类中， 需要去实现一些Activity Liftcycle的回调方法。 onCreate()你必须实现此方法，系统会在创建Activity时调用它。在你的实现里面，你应用初始化一些必要的组件。最重要的是，你必须调用setContentView()去定义这个Activity要展示给用户的UI。 onPause()当用户要离开此Activity的第一时间系统会调用此方法，（此处“离开”并不一定意味着这个Activity会被destroyed）。通常在这里你应该保存那些在此用户会话外且应该持久化的变化（因为用户可能不会回来）。 为了在Activity的切换或者在意外情况打断你的Activity stop甚至destroy的情况给用户流畅的体验，还需要了解更多其它的Lifecycle的回调方法。在Managing the Activity Liftcycle章节详细讨论。 Implementing a user interfaceActivity通过一个层级（hierarchy）的View（全部继承自View.java）来展示UI。每一个View控制着这个Activity’s Window的一个特定的矩形区域，并且可以与用户交互。比如，这个View可以是一个Button，用户可以touch它来触发一些操作。 Android提供了大量现成的View，你可以用来设计和组织你的Layout。“Widget”作为View提供在屏幕上可视（可交互）的元素，比如Button，TextView，Checkbox等等；“Layout”作为继承自ViewGroup的View给它的子View提供一种独特的布局方式，比如LinearLayout，GridLayout，RelativeLayout等。你也可以自己继承View后ViewGroup来实现你自己特有的View或Layout显示在Activity中。 定义一个Layout的最通常的方式是在你的Application Resource中顶一个XML布局文件。这种方式可以保持你的UI与你的Activity行为代码分离。你可以通过setContentView()（传一个此Layout的resource id作为参数）来将此Layout设置成UI。当然，你也可以自己创建一个View来作为此方法的参数初始化UI。 更多UI方面的信息，参见User Interface文档。 Declaring the activity in the manifest为了让系统可以访问你的Activity，你必须在Application的Manifest文件中定义此Activity。格式如下： 1234567&lt;manifest ... &gt; &lt;application ... &gt; &lt;activity android:name=\".ExampleActivity\" /&gt; ... &lt;/application ... &gt; ... &lt;/manifest &gt; 你可以定义为此元素定义一些属性，比如说activity的label，icon或者主题样式等。android:name是必须要有的属性，它指定此Activity元素所对应的class name。一旦你发布了你的Application，你就不应该更改这个name。 Using intent filters元素还可以使用元素指定不同的intent filter，来声明其他的Activity怎么来激活它。 当你使用SDK创建一个Application时，会自动创建一个包含“main” action和“launcher”category的子Activity。如下： 123456&lt;activity android:name=\".ExampleActivity\" android:icon=\"@drawable/app_icon\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 此元素指明此Activity作为Application的main入口。 元素指明此Activity会被列举在系统应用Launcher中（允许用户在Launcher界面启动它）。 如果你想你的Application的Activity不能被其他Application激活，你不需要任何其他的Intent filter。只有一个Activity应用有main action和launcher category。不想让其他Application可用的Activity可以不声明intent filter， 在你的Application内部你可以使用显式的intent方式启动它。 当然，如果你想你的Activity能过响应其他Application（或是本Application）发出的隐式的Intent，你就必须给你的Activity添加额外的Intent filter。在添加的元素中，必须包含一个元素，作为可选的，你还可以添加一些， 的元素。这些元素结合在一起决定了你的Activity可以响应的Intent 类型。 关于Intent的更多信息，参考Intents and Intent Filters文档。 Starting an Activity你可以通过调用startActivity()方法来启动一个Activity，传一个Intent作为参数来指定你想启动的Activity。此Intent不仅可以指明确切的Activity，还可以描述你想要执行的Action type（系统会选择适当的Activity（可能是别的Application的）来执行）。此Intent还可以为你将要启动的Activity携带少量的数据。 在Application内部运作时，你通常只需要简单的指定一个可知的Activity。你可以指明你想要启动的Activity的class name去显示的启动它。比如： 12Intent intent = new Intent(this, SignInActivity.class); startActivity(intent); 你的Application还可能想要处理一些action，比如发送Email，SMS或者是状态更新等等。在这种情况下，你可以不需要在你的Application中处理这些action，你可以使用设备中其他的Application来处理这些action。这正是Intent的价值所在——-你可以创建一个描述你想干什么的Intent，然后通过系统来为你从其他Application中启动合适的Activity。如果有多个Activity可以处理这个Intent，用户可以选择其中的一个来使用。比如，你想发Email，你可以创建如下的Intent： 123Intent intent = new Intent(Intent.ACTION_SEND); intent.putExtra(Intent.EXTRA_EMAIL, recipientArray); startActivity(intent); 此EXTRA_EMAIL包含了Email要发送的Email地址。当Email Application响应此Intent时，会读取出此数据，放在Email的to地址中。当用户处理完此Email后，会回到你的Activity。 Starting an activity for a result有时，你可能需要从你启动的Activity中获取一个result。在这种情况下，我们使用startActivityForResult()来启动Activity。在我们接收result的Activity中需要实现onActivityResult()回调方法。当被调用Activity执行完会传送一个包含result的intent给我们的onActivityResult()回调。 例如，你想要用户去Contacts中pick一位联系人，以便你的Activity对此联系人进行一些处理。你可以类似如下这样： 1234567891011121314151617181920private void pickContact() &#123; // Create an intent to \"pick\" a contact, as defined by the content provider URI Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI); startActivityForResult(intent, PICK_CONTACT_REQUEST); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; // If the request went well (OK) and the request was PICK_CONTACT_REQUEST if (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) &#123; // Perform a query to the contact's content provider for the contact's name Cursor cursor = getContentResolver().query(data.getData(), new String[] &#123;Contacts.DISPLAY_NAME&#125;, null, null, null); if (cursor.moveToFirst()) &#123; // True if the cursor is not empty int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME); String name = cursor.getString(columnIndex); // Do something with the selected contact's name... &#125; &#125; &#125; 此实例展示了一些基本逻辑，你可以在onActivityResult()中处理你得到的result。你需要先check这个请求是否成功了（resultCode为RESULT_OK），还要此次返回的result是不是你请求的（requestCode和startActivityForResult()的第二个参数一致）。如果是，你可以在传回来的Intent中获取你想要的result data。 此处实例中涉及的ContentResolver，Cursor等概念，详见ContentProvider文档。Intent的更多信息，参见Intents and Intent Filters文档。 Shutting Down an Activity你可以调用finish()来关闭一个Activity。也可以调用finishActivity()来关闭一个你之前启动的Activity。 注意：绝大多数情况下，你都不应该调用这些方法开显示的finish一个Activity。在地下的Activity生命周期章节我们会讨论到，Android系统会为我们管理Activity的Life，所以不需要我们自己去finish这些Activity。调用这些方法可能产生不利不可预期的用户体验，所以这些finish方法应该在只有你绝对确定不想用户再回到某一Activity的情况下使用。 Managing the Activity Lifecycle通过实现这些回调方法来管理我们的Activity Lifecycle是开发一个强健和灵活的Application的关键。一个Activity的生命周期直接影响与它关联了其他Activity以及它坐在的Task和Back Stack。 一个Activity基本上有三种状态： ResumedActivity处在屏幕前台（foreground）且获得用户focus。通常也称之为running状态。 Paused另外一个Activity处于foreground且获得focus，但是此Activity还是可见的。也就是说，有另外一个可见的Activity处在当前Activity的上方，但是另外的这个Activity是部分透明或没有覆盖整个屏幕的。一个Paused状态的Activity完全是alive（这个Activity的对象还保留在内存中，它维持着所有状态和成员信息，且保持与Window Manager的连接）的。但是在系统极端低内存的情况下此种状态的Activity也是可以被kill掉的。 Stopped此Activity完全被另一个Activity遮盖，（此Activity已经处于background）。Stopped状态的Activity依然是alive（与Paused不同的是，它不再与Window Manager保持连接）的。它不再是对用户可见的，系统会在别处需要内存时将它kill掉。 如果一个Activity处于Paused或Stopped状态，不管系统是通过调用finish()还是简单的kill掉它所在的process来把它从内存中拿掉。当这个Activity重新被打开时，它必须重新create。 Implementing the lifecycle callbacks当一个Activity在上述状态中不断转换时，它会通知如下一系列的回调方法。你可以override这些回调来在状态变化时做些适当的工作。以下列举了基本的生命周期回调： 1234567891011121314151617181920212223242526272829303132public class ExampleActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // The activity is being created. &#125; @Override protected void onStart() &#123; super.onStart(); // The activity is about to become visible. &#125; @Override protected void onResume() &#123; super.onResume(); // The activity has become visible (it is now \"resumed\"). &#125; @Override protected void onPause() &#123; super.onPause(); // Another activity is taking focus (this activity is about to be \"paused\"). &#125; @Override protected void onStop() &#123; super.onStop(); // The activity is no longer visible (it is now \"stopped\") &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // The activity is about to be destroyed. &#125; &#125; 注意：如例子所示，实现这些生命周期回调来处理你的工作之前你必须在此前调用父类的此方法。合起来，这些方法定义了一个Activity的整个Lifecycle。实现这些方法，你可以监测Activity lifecycle中的三个嵌套循环： Entire LifetimeonCreate()和onDestroy()之间。你的Activity应该在onCreate()初始化全局状态，比如定义Layout。在onDestroy()中释放所有持有的资源。例如。如果你的Activity中有一个线程在后台下载网络数据，这个线程应该在onCreate()创建而在onDestroy()中停止。 Visible LifetimeonStart()和onStop()之间。这段时间，用户可以在屏幕中看到此Activity且可以与之交互。例如，onStop()会在另一个Activity启动而这个不可见时被调用。在这两个方法之间，可以维持Activity所需要的资源展示给用户。例如，可以在onStart()中register一个BroadcastReceiver去监测一些变化来改变你的UI， 在onStop()中unRegister它，因为用户已经看不到你展示了界面了。我们的Activity在不断对用户可见于不可见的轮换中，onStart()和onStop()在Entire Lifetime可能被多次调用。 Foreground LifttimeonResume()和onPause()之间。这个阶段，Activity显示在屏幕上（其他所有Activity之上），且拥有用户的输入焦点（input focus）。Activity可以经常切换到（in/out）foreground。例如，onPause()会在屏幕休眠或弹出Dialog时调用。正因为这个状态会经常性的切换，这两个方法的代码要尽量保持轻量级以避免在状态切换时迫使用户等待。 下图展示了这些循环和状态之间互相可能的路径。矩形区域表示我们可以实现的回调方法。 另外，下表也展示了同样的lifecycle，包含一些方法的描述以及系统是否可以再方法调用之后kill它。 Method Description Killable after? Next onCreate() Activity第一次创建时会调用。在这里可以做一些静态的初始化——常见View、为List绑定数据等等。这个方法有一个包含之前Activity状态的Bundle对象作为其参数 (参见Saving Activity State, later)。 No 之后总是onStart(). onRestart() 在Activity被Stopped之后，再次启动时调用。 No onStart() onStart() 当Activity变得对用户可见时调用。如果Activity切换到foreground会调用onResume(). 如果被隐藏不可见会调用onStop()。 No onResume() or onStop() onResume() 当Activity开始可以与用户交互时调用。此时，Activity处于Stack的最顶端，用户可以与其交互（touch，focus，input）。之后总是onPause(). No onPause() onPause() 当系统开始resume另外一个Activity时调用。这个方法通常被用来保存持久数据，停止动画以及其他消费CPU的操作等等。它应该尽可能快的执行，因为下一个Activity要等它执行完后才能resumed。如果Activity重新回到前台会执行onResume()。当变得对用户不可见时会执行onStop()。 Yes onResume() or onStop() onStop() 当Activity对用户不再可见时调用。这种情况可能发生在Activity正在被destroy，或是另外一个Activity resumed且覆盖了它。如果Activity重新回到前台与用户交互会调用onRestart()。当Activity是要被销毁时会调用onDestroy()。 Yes onRestart() or onDestroy() onDestroy() 在Activity被销毁之前调用。这是这个Activity最后接收到的回调方法。情况发生可能是因为这个Activity正在finish（调用了finish()方法），或是系统要暂时销毁这个Activity的实例一边节省空间。你可以使用isFinishing()方法来区分这两种情况。 Yes nothing “Killable after”这列指明系统是否可以在这个方法执行返回后kill掉它所在process（不执行后续的代码）。onPause()、onStop()、onDestroy()被标记为“Yes”。 因为onPause方法是在Activity创建后，process可以被kill之前最后一个肯定会被调用的方法（如果系统要紧急恢复memory，onStop和onDestroy都可能不被执行）。所以，我们应该在onPause中保存重要的持久数据到storage。然而，你也应该考虑在onPause里选择性的保存必须保存的信息，因为此方法中的任何阻塞将会阻塞下一个Activity的状态转换，从而带来很慢的用户体验。 标记为“No”的方法系统会保证在这些方法调用时Activity所在的process不会被kill。所以当一个Activity从onPause返回到onResume，在它的onPause方法再次被调用之前不会被kill。 在表上表明的理论上不可能被kill的Activity，在极端（没有任何其他资源可用）的情况下仍然是可以被kill的。关于此部分更多内容参见Processes and Threading文档。 Saving activity state在Managing the Activity Lifecycle中我们简略提到了当Activity Paused或Stopped时，Activity保存状态的一些知识。当Activity Paused或Stopped的时候，因为Activity对象还存在于Memory中，所以所有信息（成员变量和当前状态）都是存在的。因此，所有用户在此Activity内的改变都被保存下来，当此Activity再回到前台（resume foreground）时，这些改变依然存在。 然而，当系统为了回收memory而destroy一个Activity时，这个Activity对象会被销毁。系统将不能以完整的状态resume到这个Activity，当用户再次回到这Activity时，系统必须重新创建一个Activity对象，然而对于用户来说，他不知道系统销毁并重新创建了Activity，所以他们期待Activity正确的工作。在这种情况下，你要确保Activity的一些重要信息被保存下来，通过实现另外一个回调方法（onSaveInstanceState()）我们可以保存这些状态信息。 系统会在Activity变得“容易”（见附录一）遭受毁坏之前调用onSaveInstanceState方法。系统会传一个Bundle的参数给这个方法，你可以使用putString或putInt方法以name-value的方式保存Activity的状态到这个Bundle中。这样，当系统kill你的Application process而用户重新启动这个Activity时，系统会在重新创建这个Activity的同时把这个Bundle传给onCreate和onRestoreInstanceState。使用其中任一个，你都可以从Bundle中解析出你保存的状态数据来恢复你的Activity。如果没有任何信息要被恢复，此Bundle为null，此时Activity就和第一次create一样被创建起来。 注意：在你的Activity被destroyed之前onSaveInstanceState不是一定会被执行的，因为有一些情况下没有必要保存状态（比如用户直接按Back键退出Activity，因为用户明确关闭Activity而不会保存状态）。如果系统调用了onSaveInstanceState，它可能是在onStop甚至onPause之前。 需要强调的是，就算你没有实现onSaveInstanceState或是在此方法中没有做什么保存状态的工作，默认实现的onSaveInstanceState也还是可以恢复Activity的一些状态。默认onSaveInstanceState方法会调用Layout中每个View相应的onSaveInstanceState方法，它允许每个View自己保存一些需要保存的信息。Android框架中几乎每个widget都适当实现了onSaveInstanceState方法。比如，当你的Activity被销毁而重新create时，UI的可视变化会自动保存并恢复。EditText会保存用户输入的text，CheckBox会保存它是否被checked的状态。当然你必须给这个widget赋予唯一的ID（使用android:id属性）。如果widget没有ID，系统将不会保存它的状态。 虽然默认的onSaveInstanceState方法为你的Activity UI保存了一些有用的信息，你还是需要override它来保存更多的信息。比如，你可能需要保存一些Activity的变化的成员变量值（与UI恢复相关但不会被默认保存的值）。 因为默认的onSaveInstanceState方法帮助我们保存了UI的状态，如果你override这个方法来保存更多信息，你应用总是在做你的工作之前调用父类的onSaveInstanceState。同样的，在你恢复状态之前，你也应该先调用父类的onRestoreInstanceState。 注意：因为onSaveInstanceState是不保证一定会执行的，所以你应该只是用来保存一些Activity的瞬时状态数据（UI状态）。你绝对不应该用它来保存持久型数据，而应该使用onPause来在用户离开Activity时保存持久数据（比如一些应该写入数据库的数据）。 一个好而简单的测试你的Application恢复状态的能力的方式是转动你的屏幕，使屏幕的orientation改变。当屏幕orientation改变时，系统会为新的屏幕configuration选择资源而销毁和重新创建Activity。仅仅出于这个原因，你的Activity在重新create时完整恢复状态都是相当重要的，因为用户在使用你的Application时可能经常的rotate屏幕。 Handling configuration changes一些设备配置（device configuration）可以在运行时改变（比如屏幕orientation，键盘可用性，语言等）。当此情况发生时，Android会重新创建当前正在运行的Activity（系统调用onDestroy，然后直接调用onCreate）。这种设计方式是为了帮助你的Application通过自动重新载入资源（比如不同的Layout或屏幕orientation、大小等）来适应新的configuration。 当你正确的设计你的Activity来处理由于屏幕orientation变化导致的重新启动，你的Application在面对生命周期中的突发事件时会更有弹性。 处理此类重启的最好方法是在你的Activity中使用onSaveInstanceState和onRestoreInstanceState/onCreate来保存和恢复状态。参见前一章节。 其他更多关于运行时Configuration变化的处理，参见Handling Runtime Changes章节。 Coordinating activities当一个Activity启动另外一个Activity时，它们都经历了lifecycle的过渡。当第二个Activity被创建时第一个Activity Pause, Stop（不过，如果它还在后台可见，则不会Stop）。一些情况下这些Activity会共享保存在磁盘或其他地方的数据，特别需要注意的是当第二个Activity被Created之前第一个Activity并不完全Stopped。相反的，Stop第一个和Start第二个的过程是重叠的。 Lifecycle的回调顺序要明确定义，尤其是处于同一个process的Activity，一个启动另外一个时。如下是Activity A启动Activity B的操作流程： A的onPause方法执行。 B的onCreate，onStart和onResume顺序执行。（Activity B取得用户focus）。 如果A不再可见，则执行A的onStop方法。 这种可预见的Lifecycle回调允许你管理AB的跳转过程。比如，当你必须在第一个Activity Stop时写数据库一边第二个Activity可以读到数据，你应该在onPause中写入数据库而不是onStop中。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/tags/Android/"},{"name":"翻译","slug":"翻译","permalink":"http://blog.lmj.wiki/tags/翻译/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://blog.lmj.wiki/categories/Android/"}]}]}